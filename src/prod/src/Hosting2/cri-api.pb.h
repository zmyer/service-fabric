// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cri-api.proto

#ifndef PROTOBUF_cri_2dapi_2eproto__INCLUDED
#define PROTOBUF_cri_2dapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_cri_2dapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[119];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsVersionRequestImpl();
void InitDefaultsVersionRequest();
void InitDefaultsVersionResponseImpl();
void InitDefaultsVersionResponse();
void InitDefaultsDNSConfigImpl();
void InitDefaultsDNSConfig();
void InitDefaultsPortMappingImpl();
void InitDefaultsPortMapping();
void InitDefaultsMountImpl();
void InitDefaultsMount();
void InitDefaultsNamespaceOptionImpl();
void InitDefaultsNamespaceOption();
void InitDefaultsInt64ValueImpl();
void InitDefaultsInt64Value();
void InitDefaultsLinuxSandboxSecurityContextImpl();
void InitDefaultsLinuxSandboxSecurityContext();
void InitDefaultsLinuxPodSandboxConfig_SysctlsEntry_DoNotUseImpl();
void InitDefaultsLinuxPodSandboxConfig_SysctlsEntry_DoNotUse();
void InitDefaultsLinuxPodSandboxConfigImpl();
void InitDefaultsLinuxPodSandboxConfig();
void InitDefaultsPodSandboxMetadataImpl();
void InitDefaultsPodSandboxMetadata();
void InitDefaultsPodSandboxConfig_LabelsEntry_DoNotUseImpl();
void InitDefaultsPodSandboxConfig_LabelsEntry_DoNotUse();
void InitDefaultsPodSandboxConfig_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsPodSandboxConfig_AnnotationsEntry_DoNotUse();
void InitDefaultsPodSandboxConfigImpl();
void InitDefaultsPodSandboxConfig();
void InitDefaultsRunPodSandboxRequestImpl();
void InitDefaultsRunPodSandboxRequest();
void InitDefaultsRunPodSandboxResponseImpl();
void InitDefaultsRunPodSandboxResponse();
void InitDefaultsStopPodSandboxRequestImpl();
void InitDefaultsStopPodSandboxRequest();
void InitDefaultsStopPodSandboxResponseImpl();
void InitDefaultsStopPodSandboxResponse();
void InitDefaultsRemovePodSandboxRequestImpl();
void InitDefaultsRemovePodSandboxRequest();
void InitDefaultsRemovePodSandboxResponseImpl();
void InitDefaultsRemovePodSandboxResponse();
void InitDefaultsPodSandboxStatusRequestImpl();
void InitDefaultsPodSandboxStatusRequest();
void InitDefaultsPodSandboxNetworkStatusImpl();
void InitDefaultsPodSandboxNetworkStatus();
void InitDefaultsNamespaceImpl();
void InitDefaultsNamespace();
void InitDefaultsLinuxPodSandboxStatusImpl();
void InitDefaultsLinuxPodSandboxStatus();
void InitDefaultsPodSandboxStatus_LabelsEntry_DoNotUseImpl();
void InitDefaultsPodSandboxStatus_LabelsEntry_DoNotUse();
void InitDefaultsPodSandboxStatus_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsPodSandboxStatus_AnnotationsEntry_DoNotUse();
void InitDefaultsPodSandboxStatusImpl();
void InitDefaultsPodSandboxStatus();
void InitDefaultsPodSandboxStatusResponse_InfoEntry_DoNotUseImpl();
void InitDefaultsPodSandboxStatusResponse_InfoEntry_DoNotUse();
void InitDefaultsPodSandboxStatusResponseImpl();
void InitDefaultsPodSandboxStatusResponse();
void InitDefaultsPodSandboxStateValueImpl();
void InitDefaultsPodSandboxStateValue();
void InitDefaultsPodSandboxFilter_LabelSelectorEntry_DoNotUseImpl();
void InitDefaultsPodSandboxFilter_LabelSelectorEntry_DoNotUse();
void InitDefaultsPodSandboxFilterImpl();
void InitDefaultsPodSandboxFilter();
void InitDefaultsListPodSandboxRequestImpl();
void InitDefaultsListPodSandboxRequest();
void InitDefaultsPodSandbox_LabelsEntry_DoNotUseImpl();
void InitDefaultsPodSandbox_LabelsEntry_DoNotUse();
void InitDefaultsPodSandbox_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsPodSandbox_AnnotationsEntry_DoNotUse();
void InitDefaultsPodSandboxImpl();
void InitDefaultsPodSandbox();
void InitDefaultsListPodSandboxResponseImpl();
void InitDefaultsListPodSandboxResponse();
void InitDefaultsImageSpecImpl();
void InitDefaultsImageSpec();
void InitDefaultsKeyValueImpl();
void InitDefaultsKeyValue();
void InitDefaultsLinuxContainerResourcesImpl();
void InitDefaultsLinuxContainerResources();
void InitDefaultsSELinuxOptionImpl();
void InitDefaultsSELinuxOption();
void InitDefaultsCapabilityImpl();
void InitDefaultsCapability();
void InitDefaultsLinuxContainerSecurityContextImpl();
void InitDefaultsLinuxContainerSecurityContext();
void InitDefaultsLinuxContainerConfigImpl();
void InitDefaultsLinuxContainerConfig();
void InitDefaultsContainerMetadataImpl();
void InitDefaultsContainerMetadata();
void InitDefaultsDeviceImpl();
void InitDefaultsDevice();
void InitDefaultsContainerConfig_LabelsEntry_DoNotUseImpl();
void InitDefaultsContainerConfig_LabelsEntry_DoNotUse();
void InitDefaultsContainerConfig_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsContainerConfig_AnnotationsEntry_DoNotUse();
void InitDefaultsContainerConfigImpl();
void InitDefaultsContainerConfig();
void InitDefaultsCreateContainerRequestImpl();
void InitDefaultsCreateContainerRequest();
void InitDefaultsCreateContainerResponseImpl();
void InitDefaultsCreateContainerResponse();
void InitDefaultsStartContainerRequestImpl();
void InitDefaultsStartContainerRequest();
void InitDefaultsStartContainerResponseImpl();
void InitDefaultsStartContainerResponse();
void InitDefaultsStopContainerRequestImpl();
void InitDefaultsStopContainerRequest();
void InitDefaultsStopContainerResponseImpl();
void InitDefaultsStopContainerResponse();
void InitDefaultsRemoveContainerRequestImpl();
void InitDefaultsRemoveContainerRequest();
void InitDefaultsRemoveContainerResponseImpl();
void InitDefaultsRemoveContainerResponse();
void InitDefaultsContainerStateValueImpl();
void InitDefaultsContainerStateValue();
void InitDefaultsContainerFilter_LabelSelectorEntry_DoNotUseImpl();
void InitDefaultsContainerFilter_LabelSelectorEntry_DoNotUse();
void InitDefaultsContainerFilterImpl();
void InitDefaultsContainerFilter();
void InitDefaultsListContainersRequestImpl();
void InitDefaultsListContainersRequest();
void InitDefaultsContainer_LabelsEntry_DoNotUseImpl();
void InitDefaultsContainer_LabelsEntry_DoNotUse();
void InitDefaultsContainer_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsContainer_AnnotationsEntry_DoNotUse();
void InitDefaultsContainerImpl();
void InitDefaultsContainer();
void InitDefaultsListContainersResponseImpl();
void InitDefaultsListContainersResponse();
void InitDefaultsContainerStatusRequestImpl();
void InitDefaultsContainerStatusRequest();
void InitDefaultsContainerStatus_LabelsEntry_DoNotUseImpl();
void InitDefaultsContainerStatus_LabelsEntry_DoNotUse();
void InitDefaultsContainerStatus_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsContainerStatus_AnnotationsEntry_DoNotUse();
void InitDefaultsContainerStatusImpl();
void InitDefaultsContainerStatus();
void InitDefaultsContainerStatusResponse_InfoEntry_DoNotUseImpl();
void InitDefaultsContainerStatusResponse_InfoEntry_DoNotUse();
void InitDefaultsContainerStatusResponseImpl();
void InitDefaultsContainerStatusResponse();
void InitDefaultsUpdateContainerResourcesRequestImpl();
void InitDefaultsUpdateContainerResourcesRequest();
void InitDefaultsUpdateContainerResourcesResponseImpl();
void InitDefaultsUpdateContainerResourcesResponse();
void InitDefaultsExecSyncRequestImpl();
void InitDefaultsExecSyncRequest();
void InitDefaultsExecSyncResponseImpl();
void InitDefaultsExecSyncResponse();
void InitDefaultsExecRequestImpl();
void InitDefaultsExecRequest();
void InitDefaultsExecResponseImpl();
void InitDefaultsExecResponse();
void InitDefaultsAttachRequestImpl();
void InitDefaultsAttachRequest();
void InitDefaultsAttachResponseImpl();
void InitDefaultsAttachResponse();
void InitDefaultsPortForwardRequestImpl();
void InitDefaultsPortForwardRequest();
void InitDefaultsPortForwardResponseImpl();
void InitDefaultsPortForwardResponse();
void InitDefaultsImageFilterImpl();
void InitDefaultsImageFilter();
void InitDefaultsListImagesRequestImpl();
void InitDefaultsListImagesRequest();
void InitDefaultsImageImpl();
void InitDefaultsImage();
void InitDefaultsListImagesResponseImpl();
void InitDefaultsListImagesResponse();
void InitDefaultsImageStatusRequestImpl();
void InitDefaultsImageStatusRequest();
void InitDefaultsImageStatusResponse_InfoEntry_DoNotUseImpl();
void InitDefaultsImageStatusResponse_InfoEntry_DoNotUse();
void InitDefaultsImageStatusResponseImpl();
void InitDefaultsImageStatusResponse();
void InitDefaultsAuthConfigImpl();
void InitDefaultsAuthConfig();
void InitDefaultsPullImageRequestImpl();
void InitDefaultsPullImageRequest();
void InitDefaultsPullImageResponseImpl();
void InitDefaultsPullImageResponse();
void InitDefaultsRemoveImageRequestImpl();
void InitDefaultsRemoveImageRequest();
void InitDefaultsRemoveImageResponseImpl();
void InitDefaultsRemoveImageResponse();
void InitDefaultsNetworkConfigImpl();
void InitDefaultsNetworkConfig();
void InitDefaultsRuntimeConfigImpl();
void InitDefaultsRuntimeConfig();
void InitDefaultsUpdateRuntimeConfigRequestImpl();
void InitDefaultsUpdateRuntimeConfigRequest();
void InitDefaultsUpdateRuntimeConfigResponseImpl();
void InitDefaultsUpdateRuntimeConfigResponse();
void InitDefaultsRuntimeConditionImpl();
void InitDefaultsRuntimeCondition();
void InitDefaultsRuntimeStatusImpl();
void InitDefaultsRuntimeStatus();
void InitDefaultsStatusRequestImpl();
void InitDefaultsStatusRequest();
void InitDefaultsStatusResponse_InfoEntry_DoNotUseImpl();
void InitDefaultsStatusResponse_InfoEntry_DoNotUse();
void InitDefaultsStatusResponseImpl();
void InitDefaultsStatusResponse();
void InitDefaultsImageFsInfoRequestImpl();
void InitDefaultsImageFsInfoRequest();
void InitDefaultsUInt64ValueImpl();
void InitDefaultsUInt64Value();
void InitDefaultsStorageIdentifierImpl();
void InitDefaultsStorageIdentifier();
void InitDefaultsFilesystemUsageImpl();
void InitDefaultsFilesystemUsage();
void InitDefaultsImageFsInfoResponseImpl();
void InitDefaultsImageFsInfoResponse();
void InitDefaultsContainerStatsRequestImpl();
void InitDefaultsContainerStatsRequest();
void InitDefaultsContainerStatsResponseImpl();
void InitDefaultsContainerStatsResponse();
void InitDefaultsListContainerStatsRequestImpl();
void InitDefaultsListContainerStatsRequest();
void InitDefaultsContainerStatsFilter_LabelSelectorEntry_DoNotUseImpl();
void InitDefaultsContainerStatsFilter_LabelSelectorEntry_DoNotUse();
void InitDefaultsContainerStatsFilterImpl();
void InitDefaultsContainerStatsFilter();
void InitDefaultsListContainerStatsResponseImpl();
void InitDefaultsListContainerStatsResponse();
void InitDefaultsContainerAttributes_LabelsEntry_DoNotUseImpl();
void InitDefaultsContainerAttributes_LabelsEntry_DoNotUse();
void InitDefaultsContainerAttributes_AnnotationsEntry_DoNotUseImpl();
void InitDefaultsContainerAttributes_AnnotationsEntry_DoNotUse();
void InitDefaultsContainerAttributesImpl();
void InitDefaultsContainerAttributes();
void InitDefaultsContainerStatsImpl();
void InitDefaultsContainerStats();
void InitDefaultsCpuUsageImpl();
void InitDefaultsCpuUsage();
void InitDefaultsMemoryUsageImpl();
void InitDefaultsMemoryUsage();
inline void InitDefaults() {
  InitDefaultsVersionRequest();
  InitDefaultsVersionResponse();
  InitDefaultsDNSConfig();
  InitDefaultsPortMapping();
  InitDefaultsMount();
  InitDefaultsNamespaceOption();
  InitDefaultsInt64Value();
  InitDefaultsLinuxSandboxSecurityContext();
  InitDefaultsLinuxPodSandboxConfig_SysctlsEntry_DoNotUse();
  InitDefaultsLinuxPodSandboxConfig();
  InitDefaultsPodSandboxMetadata();
  InitDefaultsPodSandboxConfig_LabelsEntry_DoNotUse();
  InitDefaultsPodSandboxConfig_AnnotationsEntry_DoNotUse();
  InitDefaultsPodSandboxConfig();
  InitDefaultsRunPodSandboxRequest();
  InitDefaultsRunPodSandboxResponse();
  InitDefaultsStopPodSandboxRequest();
  InitDefaultsStopPodSandboxResponse();
  InitDefaultsRemovePodSandboxRequest();
  InitDefaultsRemovePodSandboxResponse();
  InitDefaultsPodSandboxStatusRequest();
  InitDefaultsPodSandboxNetworkStatus();
  InitDefaultsNamespace();
  InitDefaultsLinuxPodSandboxStatus();
  InitDefaultsPodSandboxStatus_LabelsEntry_DoNotUse();
  InitDefaultsPodSandboxStatus_AnnotationsEntry_DoNotUse();
  InitDefaultsPodSandboxStatus();
  InitDefaultsPodSandboxStatusResponse_InfoEntry_DoNotUse();
  InitDefaultsPodSandboxStatusResponse();
  InitDefaultsPodSandboxStateValue();
  InitDefaultsPodSandboxFilter_LabelSelectorEntry_DoNotUse();
  InitDefaultsPodSandboxFilter();
  InitDefaultsListPodSandboxRequest();
  InitDefaultsPodSandbox_LabelsEntry_DoNotUse();
  InitDefaultsPodSandbox_AnnotationsEntry_DoNotUse();
  InitDefaultsPodSandbox();
  InitDefaultsListPodSandboxResponse();
  InitDefaultsImageSpec();
  InitDefaultsKeyValue();
  InitDefaultsLinuxContainerResources();
  InitDefaultsSELinuxOption();
  InitDefaultsCapability();
  InitDefaultsLinuxContainerSecurityContext();
  InitDefaultsLinuxContainerConfig();
  InitDefaultsContainerMetadata();
  InitDefaultsDevice();
  InitDefaultsContainerConfig_LabelsEntry_DoNotUse();
  InitDefaultsContainerConfig_AnnotationsEntry_DoNotUse();
  InitDefaultsContainerConfig();
  InitDefaultsCreateContainerRequest();
  InitDefaultsCreateContainerResponse();
  InitDefaultsStartContainerRequest();
  InitDefaultsStartContainerResponse();
  InitDefaultsStopContainerRequest();
  InitDefaultsStopContainerResponse();
  InitDefaultsRemoveContainerRequest();
  InitDefaultsRemoveContainerResponse();
  InitDefaultsContainerStateValue();
  InitDefaultsContainerFilter_LabelSelectorEntry_DoNotUse();
  InitDefaultsContainerFilter();
  InitDefaultsListContainersRequest();
  InitDefaultsContainer_LabelsEntry_DoNotUse();
  InitDefaultsContainer_AnnotationsEntry_DoNotUse();
  InitDefaultsContainer();
  InitDefaultsListContainersResponse();
  InitDefaultsContainerStatusRequest();
  InitDefaultsContainerStatus_LabelsEntry_DoNotUse();
  InitDefaultsContainerStatus_AnnotationsEntry_DoNotUse();
  InitDefaultsContainerStatus();
  InitDefaultsContainerStatusResponse_InfoEntry_DoNotUse();
  InitDefaultsContainerStatusResponse();
  InitDefaultsUpdateContainerResourcesRequest();
  InitDefaultsUpdateContainerResourcesResponse();
  InitDefaultsExecSyncRequest();
  InitDefaultsExecSyncResponse();
  InitDefaultsExecRequest();
  InitDefaultsExecResponse();
  InitDefaultsAttachRequest();
  InitDefaultsAttachResponse();
  InitDefaultsPortForwardRequest();
  InitDefaultsPortForwardResponse();
  InitDefaultsImageFilter();
  InitDefaultsListImagesRequest();
  InitDefaultsImage();
  InitDefaultsListImagesResponse();
  InitDefaultsImageStatusRequest();
  InitDefaultsImageStatusResponse_InfoEntry_DoNotUse();
  InitDefaultsImageStatusResponse();
  InitDefaultsAuthConfig();
  InitDefaultsPullImageRequest();
  InitDefaultsPullImageResponse();
  InitDefaultsRemoveImageRequest();
  InitDefaultsRemoveImageResponse();
  InitDefaultsNetworkConfig();
  InitDefaultsRuntimeConfig();
  InitDefaultsUpdateRuntimeConfigRequest();
  InitDefaultsUpdateRuntimeConfigResponse();
  InitDefaultsRuntimeCondition();
  InitDefaultsRuntimeStatus();
  InitDefaultsStatusRequest();
  InitDefaultsStatusResponse_InfoEntry_DoNotUse();
  InitDefaultsStatusResponse();
  InitDefaultsImageFsInfoRequest();
  InitDefaultsUInt64Value();
  InitDefaultsStorageIdentifier();
  InitDefaultsFilesystemUsage();
  InitDefaultsImageFsInfoResponse();
  InitDefaultsContainerStatsRequest();
  InitDefaultsContainerStatsResponse();
  InitDefaultsListContainerStatsRequest();
  InitDefaultsContainerStatsFilter_LabelSelectorEntry_DoNotUse();
  InitDefaultsContainerStatsFilter();
  InitDefaultsListContainerStatsResponse();
  InitDefaultsContainerAttributes_LabelsEntry_DoNotUse();
  InitDefaultsContainerAttributes_AnnotationsEntry_DoNotUse();
  InitDefaultsContainerAttributes();
  InitDefaultsContainerStats();
  InitDefaultsCpuUsage();
  InitDefaultsMemoryUsage();
}
}  // namespace protobuf_cri_2dapi_2eproto
namespace runtime {
class AttachRequest;
class AttachRequestDefaultTypeInternal;
extern AttachRequestDefaultTypeInternal _AttachRequest_default_instance_;
class AttachResponse;
class AttachResponseDefaultTypeInternal;
extern AttachResponseDefaultTypeInternal _AttachResponse_default_instance_;
class AuthConfig;
class AuthConfigDefaultTypeInternal;
extern AuthConfigDefaultTypeInternal _AuthConfig_default_instance_;
class Capability;
class CapabilityDefaultTypeInternal;
extern CapabilityDefaultTypeInternal _Capability_default_instance_;
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class ContainerAttributes;
class ContainerAttributesDefaultTypeInternal;
extern ContainerAttributesDefaultTypeInternal _ContainerAttributes_default_instance_;
class ContainerAttributes_AnnotationsEntry_DoNotUse;
class ContainerAttributes_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern ContainerAttributes_AnnotationsEntry_DoNotUseDefaultTypeInternal _ContainerAttributes_AnnotationsEntry_DoNotUse_default_instance_;
class ContainerAttributes_LabelsEntry_DoNotUse;
class ContainerAttributes_LabelsEntry_DoNotUseDefaultTypeInternal;
extern ContainerAttributes_LabelsEntry_DoNotUseDefaultTypeInternal _ContainerAttributes_LabelsEntry_DoNotUse_default_instance_;
class ContainerConfig;
class ContainerConfigDefaultTypeInternal;
extern ContainerConfigDefaultTypeInternal _ContainerConfig_default_instance_;
class ContainerConfig_AnnotationsEntry_DoNotUse;
class ContainerConfig_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern ContainerConfig_AnnotationsEntry_DoNotUseDefaultTypeInternal _ContainerConfig_AnnotationsEntry_DoNotUse_default_instance_;
class ContainerConfig_LabelsEntry_DoNotUse;
class ContainerConfig_LabelsEntry_DoNotUseDefaultTypeInternal;
extern ContainerConfig_LabelsEntry_DoNotUseDefaultTypeInternal _ContainerConfig_LabelsEntry_DoNotUse_default_instance_;
class ContainerFilter;
class ContainerFilterDefaultTypeInternal;
extern ContainerFilterDefaultTypeInternal _ContainerFilter_default_instance_;
class ContainerFilter_LabelSelectorEntry_DoNotUse;
class ContainerFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal;
extern ContainerFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal _ContainerFilter_LabelSelectorEntry_DoNotUse_default_instance_;
class ContainerMetadata;
class ContainerMetadataDefaultTypeInternal;
extern ContainerMetadataDefaultTypeInternal _ContainerMetadata_default_instance_;
class ContainerStateValue;
class ContainerStateValueDefaultTypeInternal;
extern ContainerStateValueDefaultTypeInternal _ContainerStateValue_default_instance_;
class ContainerStats;
class ContainerStatsDefaultTypeInternal;
extern ContainerStatsDefaultTypeInternal _ContainerStats_default_instance_;
class ContainerStatsFilter;
class ContainerStatsFilterDefaultTypeInternal;
extern ContainerStatsFilterDefaultTypeInternal _ContainerStatsFilter_default_instance_;
class ContainerStatsFilter_LabelSelectorEntry_DoNotUse;
class ContainerStatsFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal;
extern ContainerStatsFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal _ContainerStatsFilter_LabelSelectorEntry_DoNotUse_default_instance_;
class ContainerStatsRequest;
class ContainerStatsRequestDefaultTypeInternal;
extern ContainerStatsRequestDefaultTypeInternal _ContainerStatsRequest_default_instance_;
class ContainerStatsResponse;
class ContainerStatsResponseDefaultTypeInternal;
extern ContainerStatsResponseDefaultTypeInternal _ContainerStatsResponse_default_instance_;
class ContainerStatus;
class ContainerStatusDefaultTypeInternal;
extern ContainerStatusDefaultTypeInternal _ContainerStatus_default_instance_;
class ContainerStatusRequest;
class ContainerStatusRequestDefaultTypeInternal;
extern ContainerStatusRequestDefaultTypeInternal _ContainerStatusRequest_default_instance_;
class ContainerStatusResponse;
class ContainerStatusResponseDefaultTypeInternal;
extern ContainerStatusResponseDefaultTypeInternal _ContainerStatusResponse_default_instance_;
class ContainerStatusResponse_InfoEntry_DoNotUse;
class ContainerStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal;
extern ContainerStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal _ContainerStatusResponse_InfoEntry_DoNotUse_default_instance_;
class ContainerStatus_AnnotationsEntry_DoNotUse;
class ContainerStatus_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern ContainerStatus_AnnotationsEntry_DoNotUseDefaultTypeInternal _ContainerStatus_AnnotationsEntry_DoNotUse_default_instance_;
class ContainerStatus_LabelsEntry_DoNotUse;
class ContainerStatus_LabelsEntry_DoNotUseDefaultTypeInternal;
extern ContainerStatus_LabelsEntry_DoNotUseDefaultTypeInternal _ContainerStatus_LabelsEntry_DoNotUse_default_instance_;
class Container_AnnotationsEntry_DoNotUse;
class Container_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern Container_AnnotationsEntry_DoNotUseDefaultTypeInternal _Container_AnnotationsEntry_DoNotUse_default_instance_;
class Container_LabelsEntry_DoNotUse;
class Container_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Container_LabelsEntry_DoNotUseDefaultTypeInternal _Container_LabelsEntry_DoNotUse_default_instance_;
class CpuUsage;
class CpuUsageDefaultTypeInternal;
extern CpuUsageDefaultTypeInternal _CpuUsage_default_instance_;
class CreateContainerRequest;
class CreateContainerRequestDefaultTypeInternal;
extern CreateContainerRequestDefaultTypeInternal _CreateContainerRequest_default_instance_;
class CreateContainerResponse;
class CreateContainerResponseDefaultTypeInternal;
extern CreateContainerResponseDefaultTypeInternal _CreateContainerResponse_default_instance_;
class DNSConfig;
class DNSConfigDefaultTypeInternal;
extern DNSConfigDefaultTypeInternal _DNSConfig_default_instance_;
class Device;
class DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class ExecRequest;
class ExecRequestDefaultTypeInternal;
extern ExecRequestDefaultTypeInternal _ExecRequest_default_instance_;
class ExecResponse;
class ExecResponseDefaultTypeInternal;
extern ExecResponseDefaultTypeInternal _ExecResponse_default_instance_;
class ExecSyncRequest;
class ExecSyncRequestDefaultTypeInternal;
extern ExecSyncRequestDefaultTypeInternal _ExecSyncRequest_default_instance_;
class ExecSyncResponse;
class ExecSyncResponseDefaultTypeInternal;
extern ExecSyncResponseDefaultTypeInternal _ExecSyncResponse_default_instance_;
class FilesystemUsage;
class FilesystemUsageDefaultTypeInternal;
extern FilesystemUsageDefaultTypeInternal _FilesystemUsage_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageFilter;
class ImageFilterDefaultTypeInternal;
extern ImageFilterDefaultTypeInternal _ImageFilter_default_instance_;
class ImageFsInfoRequest;
class ImageFsInfoRequestDefaultTypeInternal;
extern ImageFsInfoRequestDefaultTypeInternal _ImageFsInfoRequest_default_instance_;
class ImageFsInfoResponse;
class ImageFsInfoResponseDefaultTypeInternal;
extern ImageFsInfoResponseDefaultTypeInternal _ImageFsInfoResponse_default_instance_;
class ImageSpec;
class ImageSpecDefaultTypeInternal;
extern ImageSpecDefaultTypeInternal _ImageSpec_default_instance_;
class ImageStatusRequest;
class ImageStatusRequestDefaultTypeInternal;
extern ImageStatusRequestDefaultTypeInternal _ImageStatusRequest_default_instance_;
class ImageStatusResponse;
class ImageStatusResponseDefaultTypeInternal;
extern ImageStatusResponseDefaultTypeInternal _ImageStatusResponse_default_instance_;
class ImageStatusResponse_InfoEntry_DoNotUse;
class ImageStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal;
extern ImageStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal _ImageStatusResponse_InfoEntry_DoNotUse_default_instance_;
class Int64Value;
class Int64ValueDefaultTypeInternal;
extern Int64ValueDefaultTypeInternal _Int64Value_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class LinuxContainerConfig;
class LinuxContainerConfigDefaultTypeInternal;
extern LinuxContainerConfigDefaultTypeInternal _LinuxContainerConfig_default_instance_;
class LinuxContainerResources;
class LinuxContainerResourcesDefaultTypeInternal;
extern LinuxContainerResourcesDefaultTypeInternal _LinuxContainerResources_default_instance_;
class LinuxContainerSecurityContext;
class LinuxContainerSecurityContextDefaultTypeInternal;
extern LinuxContainerSecurityContextDefaultTypeInternal _LinuxContainerSecurityContext_default_instance_;
class LinuxPodSandboxConfig;
class LinuxPodSandboxConfigDefaultTypeInternal;
extern LinuxPodSandboxConfigDefaultTypeInternal _LinuxPodSandboxConfig_default_instance_;
class LinuxPodSandboxConfig_SysctlsEntry_DoNotUse;
class LinuxPodSandboxConfig_SysctlsEntry_DoNotUseDefaultTypeInternal;
extern LinuxPodSandboxConfig_SysctlsEntry_DoNotUseDefaultTypeInternal _LinuxPodSandboxConfig_SysctlsEntry_DoNotUse_default_instance_;
class LinuxPodSandboxStatus;
class LinuxPodSandboxStatusDefaultTypeInternal;
extern LinuxPodSandboxStatusDefaultTypeInternal _LinuxPodSandboxStatus_default_instance_;
class LinuxSandboxSecurityContext;
class LinuxSandboxSecurityContextDefaultTypeInternal;
extern LinuxSandboxSecurityContextDefaultTypeInternal _LinuxSandboxSecurityContext_default_instance_;
class ListContainerStatsRequest;
class ListContainerStatsRequestDefaultTypeInternal;
extern ListContainerStatsRequestDefaultTypeInternal _ListContainerStatsRequest_default_instance_;
class ListContainerStatsResponse;
class ListContainerStatsResponseDefaultTypeInternal;
extern ListContainerStatsResponseDefaultTypeInternal _ListContainerStatsResponse_default_instance_;
class ListContainersRequest;
class ListContainersRequestDefaultTypeInternal;
extern ListContainersRequestDefaultTypeInternal _ListContainersRequest_default_instance_;
class ListContainersResponse;
class ListContainersResponseDefaultTypeInternal;
extern ListContainersResponseDefaultTypeInternal _ListContainersResponse_default_instance_;
class ListImagesRequest;
class ListImagesRequestDefaultTypeInternal;
extern ListImagesRequestDefaultTypeInternal _ListImagesRequest_default_instance_;
class ListImagesResponse;
class ListImagesResponseDefaultTypeInternal;
extern ListImagesResponseDefaultTypeInternal _ListImagesResponse_default_instance_;
class ListPodSandboxRequest;
class ListPodSandboxRequestDefaultTypeInternal;
extern ListPodSandboxRequestDefaultTypeInternal _ListPodSandboxRequest_default_instance_;
class ListPodSandboxResponse;
class ListPodSandboxResponseDefaultTypeInternal;
extern ListPodSandboxResponseDefaultTypeInternal _ListPodSandboxResponse_default_instance_;
class MemoryUsage;
class MemoryUsageDefaultTypeInternal;
extern MemoryUsageDefaultTypeInternal _MemoryUsage_default_instance_;
class Mount;
class MountDefaultTypeInternal;
extern MountDefaultTypeInternal _Mount_default_instance_;
class Namespace;
class NamespaceDefaultTypeInternal;
extern NamespaceDefaultTypeInternal _Namespace_default_instance_;
class NamespaceOption;
class NamespaceOptionDefaultTypeInternal;
extern NamespaceOptionDefaultTypeInternal _NamespaceOption_default_instance_;
class NetworkConfig;
class NetworkConfigDefaultTypeInternal;
extern NetworkConfigDefaultTypeInternal _NetworkConfig_default_instance_;
class PodSandbox;
class PodSandboxDefaultTypeInternal;
extern PodSandboxDefaultTypeInternal _PodSandbox_default_instance_;
class PodSandboxConfig;
class PodSandboxConfigDefaultTypeInternal;
extern PodSandboxConfigDefaultTypeInternal _PodSandboxConfig_default_instance_;
class PodSandboxConfig_AnnotationsEntry_DoNotUse;
class PodSandboxConfig_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxConfig_AnnotationsEntry_DoNotUseDefaultTypeInternal _PodSandboxConfig_AnnotationsEntry_DoNotUse_default_instance_;
class PodSandboxConfig_LabelsEntry_DoNotUse;
class PodSandboxConfig_LabelsEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxConfig_LabelsEntry_DoNotUseDefaultTypeInternal _PodSandboxConfig_LabelsEntry_DoNotUse_default_instance_;
class PodSandboxFilter;
class PodSandboxFilterDefaultTypeInternal;
extern PodSandboxFilterDefaultTypeInternal _PodSandboxFilter_default_instance_;
class PodSandboxFilter_LabelSelectorEntry_DoNotUse;
class PodSandboxFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxFilter_LabelSelectorEntry_DoNotUseDefaultTypeInternal _PodSandboxFilter_LabelSelectorEntry_DoNotUse_default_instance_;
class PodSandboxMetadata;
class PodSandboxMetadataDefaultTypeInternal;
extern PodSandboxMetadataDefaultTypeInternal _PodSandboxMetadata_default_instance_;
class PodSandboxNetworkStatus;
class PodSandboxNetworkStatusDefaultTypeInternal;
extern PodSandboxNetworkStatusDefaultTypeInternal _PodSandboxNetworkStatus_default_instance_;
class PodSandboxStateValue;
class PodSandboxStateValueDefaultTypeInternal;
extern PodSandboxStateValueDefaultTypeInternal _PodSandboxStateValue_default_instance_;
class PodSandboxStatus;
class PodSandboxStatusDefaultTypeInternal;
extern PodSandboxStatusDefaultTypeInternal _PodSandboxStatus_default_instance_;
class PodSandboxStatusRequest;
class PodSandboxStatusRequestDefaultTypeInternal;
extern PodSandboxStatusRequestDefaultTypeInternal _PodSandboxStatusRequest_default_instance_;
class PodSandboxStatusResponse;
class PodSandboxStatusResponseDefaultTypeInternal;
extern PodSandboxStatusResponseDefaultTypeInternal _PodSandboxStatusResponse_default_instance_;
class PodSandboxStatusResponse_InfoEntry_DoNotUse;
class PodSandboxStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxStatusResponse_InfoEntry_DoNotUseDefaultTypeInternal _PodSandboxStatusResponse_InfoEntry_DoNotUse_default_instance_;
class PodSandboxStatus_AnnotationsEntry_DoNotUse;
class PodSandboxStatus_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxStatus_AnnotationsEntry_DoNotUseDefaultTypeInternal _PodSandboxStatus_AnnotationsEntry_DoNotUse_default_instance_;
class PodSandboxStatus_LabelsEntry_DoNotUse;
class PodSandboxStatus_LabelsEntry_DoNotUseDefaultTypeInternal;
extern PodSandboxStatus_LabelsEntry_DoNotUseDefaultTypeInternal _PodSandboxStatus_LabelsEntry_DoNotUse_default_instance_;
class PodSandbox_AnnotationsEntry_DoNotUse;
class PodSandbox_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern PodSandbox_AnnotationsEntry_DoNotUseDefaultTypeInternal _PodSandbox_AnnotationsEntry_DoNotUse_default_instance_;
class PodSandbox_LabelsEntry_DoNotUse;
class PodSandbox_LabelsEntry_DoNotUseDefaultTypeInternal;
extern PodSandbox_LabelsEntry_DoNotUseDefaultTypeInternal _PodSandbox_LabelsEntry_DoNotUse_default_instance_;
class PortForwardRequest;
class PortForwardRequestDefaultTypeInternal;
extern PortForwardRequestDefaultTypeInternal _PortForwardRequest_default_instance_;
class PortForwardResponse;
class PortForwardResponseDefaultTypeInternal;
extern PortForwardResponseDefaultTypeInternal _PortForwardResponse_default_instance_;
class PortMapping;
class PortMappingDefaultTypeInternal;
extern PortMappingDefaultTypeInternal _PortMapping_default_instance_;
class PullImageRequest;
class PullImageRequestDefaultTypeInternal;
extern PullImageRequestDefaultTypeInternal _PullImageRequest_default_instance_;
class PullImageResponse;
class PullImageResponseDefaultTypeInternal;
extern PullImageResponseDefaultTypeInternal _PullImageResponse_default_instance_;
class RemoveContainerRequest;
class RemoveContainerRequestDefaultTypeInternal;
extern RemoveContainerRequestDefaultTypeInternal _RemoveContainerRequest_default_instance_;
class RemoveContainerResponse;
class RemoveContainerResponseDefaultTypeInternal;
extern RemoveContainerResponseDefaultTypeInternal _RemoveContainerResponse_default_instance_;
class RemoveImageRequest;
class RemoveImageRequestDefaultTypeInternal;
extern RemoveImageRequestDefaultTypeInternal _RemoveImageRequest_default_instance_;
class RemoveImageResponse;
class RemoveImageResponseDefaultTypeInternal;
extern RemoveImageResponseDefaultTypeInternal _RemoveImageResponse_default_instance_;
class RemovePodSandboxRequest;
class RemovePodSandboxRequestDefaultTypeInternal;
extern RemovePodSandboxRequestDefaultTypeInternal _RemovePodSandboxRequest_default_instance_;
class RemovePodSandboxResponse;
class RemovePodSandboxResponseDefaultTypeInternal;
extern RemovePodSandboxResponseDefaultTypeInternal _RemovePodSandboxResponse_default_instance_;
class RunPodSandboxRequest;
class RunPodSandboxRequestDefaultTypeInternal;
extern RunPodSandboxRequestDefaultTypeInternal _RunPodSandboxRequest_default_instance_;
class RunPodSandboxResponse;
class RunPodSandboxResponseDefaultTypeInternal;
extern RunPodSandboxResponseDefaultTypeInternal _RunPodSandboxResponse_default_instance_;
class RuntimeCondition;
class RuntimeConditionDefaultTypeInternal;
extern RuntimeConditionDefaultTypeInternal _RuntimeCondition_default_instance_;
class RuntimeConfig;
class RuntimeConfigDefaultTypeInternal;
extern RuntimeConfigDefaultTypeInternal _RuntimeConfig_default_instance_;
class RuntimeStatus;
class RuntimeStatusDefaultTypeInternal;
extern RuntimeStatusDefaultTypeInternal _RuntimeStatus_default_instance_;
class SELinuxOption;
class SELinuxOptionDefaultTypeInternal;
extern SELinuxOptionDefaultTypeInternal _SELinuxOption_default_instance_;
class StartContainerRequest;
class StartContainerRequestDefaultTypeInternal;
extern StartContainerRequestDefaultTypeInternal _StartContainerRequest_default_instance_;
class StartContainerResponse;
class StartContainerResponseDefaultTypeInternal;
extern StartContainerResponseDefaultTypeInternal _StartContainerResponse_default_instance_;
class StatusRequest;
class StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class StatusResponse_InfoEntry_DoNotUse;
class StatusResponse_InfoEntry_DoNotUseDefaultTypeInternal;
extern StatusResponse_InfoEntry_DoNotUseDefaultTypeInternal _StatusResponse_InfoEntry_DoNotUse_default_instance_;
class StopContainerRequest;
class StopContainerRequestDefaultTypeInternal;
extern StopContainerRequestDefaultTypeInternal _StopContainerRequest_default_instance_;
class StopContainerResponse;
class StopContainerResponseDefaultTypeInternal;
extern StopContainerResponseDefaultTypeInternal _StopContainerResponse_default_instance_;
class StopPodSandboxRequest;
class StopPodSandboxRequestDefaultTypeInternal;
extern StopPodSandboxRequestDefaultTypeInternal _StopPodSandboxRequest_default_instance_;
class StopPodSandboxResponse;
class StopPodSandboxResponseDefaultTypeInternal;
extern StopPodSandboxResponseDefaultTypeInternal _StopPodSandboxResponse_default_instance_;
class StorageIdentifier;
class StorageIdentifierDefaultTypeInternal;
extern StorageIdentifierDefaultTypeInternal _StorageIdentifier_default_instance_;
class UInt64Value;
class UInt64ValueDefaultTypeInternal;
extern UInt64ValueDefaultTypeInternal _UInt64Value_default_instance_;
class UpdateContainerResourcesRequest;
class UpdateContainerResourcesRequestDefaultTypeInternal;
extern UpdateContainerResourcesRequestDefaultTypeInternal _UpdateContainerResourcesRequest_default_instance_;
class UpdateContainerResourcesResponse;
class UpdateContainerResourcesResponseDefaultTypeInternal;
extern UpdateContainerResourcesResponseDefaultTypeInternal _UpdateContainerResourcesResponse_default_instance_;
class UpdateRuntimeConfigRequest;
class UpdateRuntimeConfigRequestDefaultTypeInternal;
extern UpdateRuntimeConfigRequestDefaultTypeInternal _UpdateRuntimeConfigRequest_default_instance_;
class UpdateRuntimeConfigResponse;
class UpdateRuntimeConfigResponseDefaultTypeInternal;
extern UpdateRuntimeConfigResponseDefaultTypeInternal _UpdateRuntimeConfigResponse_default_instance_;
class VersionRequest;
class VersionRequestDefaultTypeInternal;
extern VersionRequestDefaultTypeInternal _VersionRequest_default_instance_;
class VersionResponse;
class VersionResponseDefaultTypeInternal;
extern VersionResponseDefaultTypeInternal _VersionResponse_default_instance_;
}  // namespace runtime
namespace runtime {

enum Protocol {
  TCP = 0,
  UDP = 1,
  Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Protocol_IsValid(int value);
const Protocol Protocol_MIN = TCP;
const Protocol Protocol_MAX = UDP;
const int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* Protocol_descriptor();
inline const ::std::string& Protocol_Name(Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    Protocol_descriptor(), value);
}
inline bool Protocol_Parse(
    const ::std::string& name, Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
enum MountPropagation {
  PROPAGATION_PRIVATE = 0,
  PROPAGATION_HOST_TO_CONTAINER = 1,
  PROPAGATION_BIDIRECTIONAL = 2,
  MountPropagation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MountPropagation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MountPropagation_IsValid(int value);
const MountPropagation MountPropagation_MIN = PROPAGATION_PRIVATE;
const MountPropagation MountPropagation_MAX = PROPAGATION_BIDIRECTIONAL;
const int MountPropagation_ARRAYSIZE = MountPropagation_MAX + 1;

const ::google::protobuf::EnumDescriptor* MountPropagation_descriptor();
inline const ::std::string& MountPropagation_Name(MountPropagation value) {
  return ::google::protobuf::internal::NameOfEnum(
    MountPropagation_descriptor(), value);
}
inline bool MountPropagation_Parse(
    const ::std::string& name, MountPropagation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MountPropagation>(
    MountPropagation_descriptor(), name, value);
}
enum PodSandboxState {
  SANDBOX_READY = 0,
  SANDBOX_NOTREADY = 1,
  PodSandboxState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PodSandboxState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PodSandboxState_IsValid(int value);
const PodSandboxState PodSandboxState_MIN = SANDBOX_READY;
const PodSandboxState PodSandboxState_MAX = SANDBOX_NOTREADY;
const int PodSandboxState_ARRAYSIZE = PodSandboxState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PodSandboxState_descriptor();
inline const ::std::string& PodSandboxState_Name(PodSandboxState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PodSandboxState_descriptor(), value);
}
inline bool PodSandboxState_Parse(
    const ::std::string& name, PodSandboxState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PodSandboxState>(
    PodSandboxState_descriptor(), name, value);
}
enum ContainerState {
  CONTAINER_CREATED = 0,
  CONTAINER_RUNNING = 1,
  CONTAINER_EXITED = 2,
  CONTAINER_UNKNOWN = 3,
  ContainerState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ContainerState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ContainerState_IsValid(int value);
const ContainerState ContainerState_MIN = CONTAINER_CREATED;
const ContainerState ContainerState_MAX = CONTAINER_UNKNOWN;
const int ContainerState_ARRAYSIZE = ContainerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerState_descriptor();
inline const ::std::string& ContainerState_Name(ContainerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerState_descriptor(), value);
}
inline bool ContainerState_Parse(
    const ::std::string& name, ContainerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerState>(
    ContainerState_descriptor(), name, value);
}
// ===================================================================

class VersionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.VersionRequest) */ {
 public:
  VersionRequest();
  virtual ~VersionRequest();

  VersionRequest(const VersionRequest& from);

  inline VersionRequest& operator=(const VersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionRequest(VersionRequest&& from) noexcept
    : VersionRequest() {
    *this = ::std::move(from);
  }

  inline VersionRequest& operator=(VersionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionRequest* internal_default_instance() {
    return reinterpret_cast<const VersionRequest*>(
               &_VersionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VersionRequest* other);
  friend void swap(VersionRequest& a, VersionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  VersionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VersionRequest& from);
  void MergeFrom(const VersionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VersionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:runtime.VersionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsVersionRequestImpl();
};
// -------------------------------------------------------------------

class VersionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.VersionResponse) */ {
 public:
  VersionResponse();
  virtual ~VersionResponse();

  VersionResponse(const VersionResponse& from);

  inline VersionResponse& operator=(const VersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionResponse(VersionResponse&& from) noexcept
    : VersionResponse() {
    *this = ::std::move(from);
  }

  inline VersionResponse& operator=(VersionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionResponse* internal_default_instance() {
    return reinterpret_cast<const VersionResponse*>(
               &_VersionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(VersionResponse* other);
  friend void swap(VersionResponse& a, VersionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  VersionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VersionResponse& from);
  void MergeFrom(const VersionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VersionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string runtime_name = 2;
  void clear_runtime_name();
  static const int kRuntimeNameFieldNumber = 2;
  const ::std::string& runtime_name() const;
  void set_runtime_name(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_name(::std::string&& value);
  #endif
  void set_runtime_name(const char* value);
  void set_runtime_name(const char* value, size_t size);
  ::std::string* mutable_runtime_name();
  ::std::string* release_runtime_name();
  void set_allocated_runtime_name(::std::string* runtime_name);

  // string runtime_version = 3;
  void clear_runtime_version();
  static const int kRuntimeVersionFieldNumber = 3;
  const ::std::string& runtime_version() const;
  void set_runtime_version(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_version(::std::string&& value);
  #endif
  void set_runtime_version(const char* value);
  void set_runtime_version(const char* value, size_t size);
  ::std::string* mutable_runtime_version();
  ::std::string* release_runtime_version();
  void set_allocated_runtime_version(::std::string* runtime_version);

  // string runtime_api_version = 4;
  void clear_runtime_api_version();
  static const int kRuntimeApiVersionFieldNumber = 4;
  const ::std::string& runtime_api_version() const;
  void set_runtime_api_version(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_api_version(::std::string&& value);
  #endif
  void set_runtime_api_version(const char* value);
  void set_runtime_api_version(const char* value, size_t size);
  ::std::string* mutable_runtime_api_version();
  ::std::string* release_runtime_api_version();
  void set_allocated_runtime_api_version(::std::string* runtime_api_version);

  // @@protoc_insertion_point(class_scope:runtime.VersionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr runtime_name_;
  ::google::protobuf::internal::ArenaStringPtr runtime_version_;
  ::google::protobuf::internal::ArenaStringPtr runtime_api_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsVersionResponseImpl();
};
// -------------------------------------------------------------------

class DNSConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.DNSConfig) */ {
 public:
  DNSConfig();
  virtual ~DNSConfig();

  DNSConfig(const DNSConfig& from);

  inline DNSConfig& operator=(const DNSConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DNSConfig(DNSConfig&& from) noexcept
    : DNSConfig() {
    *this = ::std::move(from);
  }

  inline DNSConfig& operator=(DNSConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DNSConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DNSConfig* internal_default_instance() {
    return reinterpret_cast<const DNSConfig*>(
               &_DNSConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DNSConfig* other);
  friend void swap(DNSConfig& a, DNSConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DNSConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DNSConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DNSConfig& from);
  void MergeFrom(const DNSConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DNSConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string servers = 1;
  int servers_size() const;
  void clear_servers();
  static const int kServersFieldNumber = 1;
  const ::std::string& servers(int index) const;
  ::std::string* mutable_servers(int index);
  void set_servers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_servers(int index, ::std::string&& value);
  #endif
  void set_servers(int index, const char* value);
  void set_servers(int index, const char* value, size_t size);
  ::std::string* add_servers();
  void add_servers(const ::std::string& value);
  #if LANG_CXX11
  void add_servers(::std::string&& value);
  #endif
  void add_servers(const char* value);
  void add_servers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& servers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_servers();

  // repeated string searches = 2;
  int searches_size() const;
  void clear_searches();
  static const int kSearchesFieldNumber = 2;
  const ::std::string& searches(int index) const;
  ::std::string* mutable_searches(int index);
  void set_searches(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_searches(int index, ::std::string&& value);
  #endif
  void set_searches(int index, const char* value);
  void set_searches(int index, const char* value, size_t size);
  ::std::string* add_searches();
  void add_searches(const ::std::string& value);
  #if LANG_CXX11
  void add_searches(::std::string&& value);
  #endif
  void add_searches(const char* value);
  void add_searches(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& searches() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_searches();

  // repeated string options = 3;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  const ::std::string& options(int index) const;
  ::std::string* mutable_options(int index);
  void set_options(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_options(int index, ::std::string&& value);
  #endif
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  ::std::string* add_options();
  void add_options(const ::std::string& value);
  #if LANG_CXX11
  void add_options(::std::string&& value);
  #endif
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // @@protoc_insertion_point(class_scope:runtime.DNSConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> servers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> searches_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsDNSConfigImpl();
};
// -------------------------------------------------------------------

class PortMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PortMapping) */ {
 public:
  PortMapping();
  virtual ~PortMapping();

  PortMapping(const PortMapping& from);

  inline PortMapping& operator=(const PortMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortMapping(PortMapping&& from) noexcept
    : PortMapping() {
    *this = ::std::move(from);
  }

  inline PortMapping& operator=(PortMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortMapping* internal_default_instance() {
    return reinterpret_cast<const PortMapping*>(
               &_PortMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PortMapping* other);
  friend void swap(PortMapping& a, PortMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  PortMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PortMapping& from);
  void MergeFrom(const PortMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PortMapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host_ip = 4;
  void clear_host_ip();
  static const int kHostIpFieldNumber = 4;
  const ::std::string& host_ip() const;
  void set_host_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_host_ip(::std::string&& value);
  #endif
  void set_host_ip(const char* value);
  void set_host_ip(const char* value, size_t size);
  ::std::string* mutable_host_ip();
  ::std::string* release_host_ip();
  void set_allocated_host_ip(::std::string* host_ip);

  // .runtime.Protocol protocol = 1;
  void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  ::runtime::Protocol protocol() const;
  void set_protocol(::runtime::Protocol value);

  // int32 container_port = 2;
  void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  ::google::protobuf::int32 container_port() const;
  void set_container_port(::google::protobuf::int32 value);

  // int32 host_port = 3;
  void clear_host_port();
  static const int kHostPortFieldNumber = 3;
  ::google::protobuf::int32 host_port() const;
  void set_host_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:runtime.PortMapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_ip_;
  int protocol_;
  ::google::protobuf::int32 container_port_;
  ::google::protobuf::int32 host_port_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPortMappingImpl();
};
// -------------------------------------------------------------------

class Mount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Mount) */ {
 public:
  Mount();
  virtual ~Mount();

  Mount(const Mount& from);

  inline Mount& operator=(const Mount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mount(Mount&& from) noexcept
    : Mount() {
    *this = ::std::move(from);
  }

  inline Mount& operator=(Mount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mount* internal_default_instance() {
    return reinterpret_cast<const Mount*>(
               &_Mount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Mount* other);
  friend void swap(Mount& a, Mount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mount* New() const PROTOBUF_FINAL { return New(NULL); }

  Mount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mount& from);
  void MergeFrom(const Mount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_path = 1;
  void clear_container_path();
  static const int kContainerPathFieldNumber = 1;
  const ::std::string& container_path() const;
  void set_container_path(const ::std::string& value);
  #if LANG_CXX11
  void set_container_path(::std::string&& value);
  #endif
  void set_container_path(const char* value);
  void set_container_path(const char* value, size_t size);
  ::std::string* mutable_container_path();
  ::std::string* release_container_path();
  void set_allocated_container_path(::std::string* container_path);

  // string host_path = 2;
  void clear_host_path();
  static const int kHostPathFieldNumber = 2;
  const ::std::string& host_path() const;
  void set_host_path(const ::std::string& value);
  #if LANG_CXX11
  void set_host_path(::std::string&& value);
  #endif
  void set_host_path(const char* value);
  void set_host_path(const char* value, size_t size);
  ::std::string* mutable_host_path();
  ::std::string* release_host_path();
  void set_allocated_host_path(::std::string* host_path);

  // bool readonly = 3;
  void clear_readonly();
  static const int kReadonlyFieldNumber = 3;
  bool readonly() const;
  void set_readonly(bool value);

  // bool selinux_relabel = 4;
  void clear_selinux_relabel();
  static const int kSelinuxRelabelFieldNumber = 4;
  bool selinux_relabel() const;
  void set_selinux_relabel(bool value);

  // .runtime.MountPropagation propagation = 5;
  void clear_propagation();
  static const int kPropagationFieldNumber = 5;
  ::runtime::MountPropagation propagation() const;
  void set_propagation(::runtime::MountPropagation value);

  // @@protoc_insertion_point(class_scope:runtime.Mount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_path_;
  ::google::protobuf::internal::ArenaStringPtr host_path_;
  bool readonly_;
  bool selinux_relabel_;
  int propagation_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsMountImpl();
};
// -------------------------------------------------------------------

class NamespaceOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.NamespaceOption) */ {
 public:
  NamespaceOption();
  virtual ~NamespaceOption();

  NamespaceOption(const NamespaceOption& from);

  inline NamespaceOption& operator=(const NamespaceOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NamespaceOption(NamespaceOption&& from) noexcept
    : NamespaceOption() {
    *this = ::std::move(from);
  }

  inline NamespaceOption& operator=(NamespaceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NamespaceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamespaceOption* internal_default_instance() {
    return reinterpret_cast<const NamespaceOption*>(
               &_NamespaceOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(NamespaceOption* other);
  friend void swap(NamespaceOption& a, NamespaceOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamespaceOption* New() const PROTOBUF_FINAL { return New(NULL); }

  NamespaceOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NamespaceOption& from);
  void MergeFrom(const NamespaceOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NamespaceOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool host_network = 1;
  void clear_host_network();
  static const int kHostNetworkFieldNumber = 1;
  bool host_network() const;
  void set_host_network(bool value);

  // bool host_pid = 2;
  void clear_host_pid();
  static const int kHostPidFieldNumber = 2;
  bool host_pid() const;
  void set_host_pid(bool value);

  // bool host_ipc = 3;
  void clear_host_ipc();
  static const int kHostIpcFieldNumber = 3;
  bool host_ipc() const;
  void set_host_ipc(bool value);

  // @@protoc_insertion_point(class_scope:runtime.NamespaceOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool host_network_;
  bool host_pid_;
  bool host_ipc_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsNamespaceOptionImpl();
};
// -------------------------------------------------------------------

class Int64Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Int64Value) */ {
 public:
  Int64Value();
  virtual ~Int64Value();

  Int64Value(const Int64Value& from);

  inline Int64Value& operator=(const Int64Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64Value(Int64Value&& from) noexcept
    : Int64Value() {
    *this = ::std::move(from);
  }

  inline Int64Value& operator=(Int64Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64Value* internal_default_instance() {
    return reinterpret_cast<const Int64Value*>(
               &_Int64Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Int64Value* other);
  friend void swap(Int64Value& a, Int64Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Int64Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Int64Value& from);
  void MergeFrom(const Int64Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Int64Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.Int64Value)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsInt64ValueImpl();
};
// -------------------------------------------------------------------

class LinuxSandboxSecurityContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxSandboxSecurityContext) */ {
 public:
  LinuxSandboxSecurityContext();
  virtual ~LinuxSandboxSecurityContext();

  LinuxSandboxSecurityContext(const LinuxSandboxSecurityContext& from);

  inline LinuxSandboxSecurityContext& operator=(const LinuxSandboxSecurityContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxSandboxSecurityContext(LinuxSandboxSecurityContext&& from) noexcept
    : LinuxSandboxSecurityContext() {
    *this = ::std::move(from);
  }

  inline LinuxSandboxSecurityContext& operator=(LinuxSandboxSecurityContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxSandboxSecurityContext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxSandboxSecurityContext* internal_default_instance() {
    return reinterpret_cast<const LinuxSandboxSecurityContext*>(
               &_LinuxSandboxSecurityContext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LinuxSandboxSecurityContext* other);
  friend void swap(LinuxSandboxSecurityContext& a, LinuxSandboxSecurityContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxSandboxSecurityContext* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxSandboxSecurityContext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxSandboxSecurityContext& from);
  void MergeFrom(const LinuxSandboxSecurityContext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxSandboxSecurityContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 supplemental_groups = 5;
  int supplemental_groups_size() const;
  void clear_supplemental_groups();
  static const int kSupplementalGroupsFieldNumber = 5;
  ::google::protobuf::int64 supplemental_groups(int index) const;
  void set_supplemental_groups(int index, ::google::protobuf::int64 value);
  void add_supplemental_groups(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      supplemental_groups() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_supplemental_groups();

  // string seccomp_profile_path = 7;
  void clear_seccomp_profile_path();
  static const int kSeccompProfilePathFieldNumber = 7;
  const ::std::string& seccomp_profile_path() const;
  void set_seccomp_profile_path(const ::std::string& value);
  #if LANG_CXX11
  void set_seccomp_profile_path(::std::string&& value);
  #endif
  void set_seccomp_profile_path(const char* value);
  void set_seccomp_profile_path(const char* value, size_t size);
  ::std::string* mutable_seccomp_profile_path();
  ::std::string* release_seccomp_profile_path();
  void set_allocated_seccomp_profile_path(::std::string* seccomp_profile_path);

  // .runtime.NamespaceOption namespace_options = 1;
  bool has_namespace_options() const;
  void clear_namespace_options();
  static const int kNamespaceOptionsFieldNumber = 1;
  const ::runtime::NamespaceOption& namespace_options() const;
  ::runtime::NamespaceOption* release_namespace_options();
  ::runtime::NamespaceOption* mutable_namespace_options();
  void set_allocated_namespace_options(::runtime::NamespaceOption* namespace_options);

  // .runtime.SELinuxOption selinux_options = 2;
  bool has_selinux_options() const;
  void clear_selinux_options();
  static const int kSelinuxOptionsFieldNumber = 2;
  const ::runtime::SELinuxOption& selinux_options() const;
  ::runtime::SELinuxOption* release_selinux_options();
  ::runtime::SELinuxOption* mutable_selinux_options();
  void set_allocated_selinux_options(::runtime::SELinuxOption* selinux_options);

  // .runtime.Int64Value run_as_user = 3;
  bool has_run_as_user() const;
  void clear_run_as_user();
  static const int kRunAsUserFieldNumber = 3;
  const ::runtime::Int64Value& run_as_user() const;
  ::runtime::Int64Value* release_run_as_user();
  ::runtime::Int64Value* mutable_run_as_user();
  void set_allocated_run_as_user(::runtime::Int64Value* run_as_user);

  // bool readonly_rootfs = 4;
  void clear_readonly_rootfs();
  static const int kReadonlyRootfsFieldNumber = 4;
  bool readonly_rootfs() const;
  void set_readonly_rootfs(bool value);

  // bool privileged = 6;
  void clear_privileged();
  static const int kPrivilegedFieldNumber = 6;
  bool privileged() const;
  void set_privileged(bool value);

  // @@protoc_insertion_point(class_scope:runtime.LinuxSandboxSecurityContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > supplemental_groups_;
  mutable int _supplemental_groups_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr seccomp_profile_path_;
  ::runtime::NamespaceOption* namespace_options_;
  ::runtime::SELinuxOption* selinux_options_;
  ::runtime::Int64Value* run_as_user_;
  bool readonly_rootfs_;
  bool privileged_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxSandboxSecurityContextImpl();
};
// -------------------------------------------------------------------

class LinuxPodSandboxConfig_SysctlsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LinuxPodSandboxConfig_SysctlsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<LinuxPodSandboxConfig_SysctlsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  LinuxPodSandboxConfig_SysctlsEntry_DoNotUse();
  LinuxPodSandboxConfig_SysctlsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LinuxPodSandboxConfig_SysctlsEntry_DoNotUse& other);
  static const LinuxPodSandboxConfig_SysctlsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LinuxPodSandboxConfig_SysctlsEntry_DoNotUse*>(&_LinuxPodSandboxConfig_SysctlsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LinuxPodSandboxConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxPodSandboxConfig) */ {
 public:
  LinuxPodSandboxConfig();
  virtual ~LinuxPodSandboxConfig();

  LinuxPodSandboxConfig(const LinuxPodSandboxConfig& from);

  inline LinuxPodSandboxConfig& operator=(const LinuxPodSandboxConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxPodSandboxConfig(LinuxPodSandboxConfig&& from) noexcept
    : LinuxPodSandboxConfig() {
    *this = ::std::move(from);
  }

  inline LinuxPodSandboxConfig& operator=(LinuxPodSandboxConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxPodSandboxConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxPodSandboxConfig* internal_default_instance() {
    return reinterpret_cast<const LinuxPodSandboxConfig*>(
               &_LinuxPodSandboxConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(LinuxPodSandboxConfig* other);
  friend void swap(LinuxPodSandboxConfig& a, LinuxPodSandboxConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxPodSandboxConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxPodSandboxConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxPodSandboxConfig& from);
  void MergeFrom(const LinuxPodSandboxConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxPodSandboxConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> sysctls = 3;
  int sysctls_size() const;
  void clear_sysctls();
  static const int kSysctlsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      sysctls() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_sysctls();

  // string cgroup_parent = 1;
  void clear_cgroup_parent();
  static const int kCgroupParentFieldNumber = 1;
  const ::std::string& cgroup_parent() const;
  void set_cgroup_parent(const ::std::string& value);
  #if LANG_CXX11
  void set_cgroup_parent(::std::string&& value);
  #endif
  void set_cgroup_parent(const char* value);
  void set_cgroup_parent(const char* value, size_t size);
  ::std::string* mutable_cgroup_parent();
  ::std::string* release_cgroup_parent();
  void set_allocated_cgroup_parent(::std::string* cgroup_parent);

  // .runtime.LinuxSandboxSecurityContext security_context = 2;
  bool has_security_context() const;
  void clear_security_context();
  static const int kSecurityContextFieldNumber = 2;
  const ::runtime::LinuxSandboxSecurityContext& security_context() const;
  ::runtime::LinuxSandboxSecurityContext* release_security_context();
  ::runtime::LinuxSandboxSecurityContext* mutable_security_context();
  void set_allocated_security_context(::runtime::LinuxSandboxSecurityContext* security_context);

  // @@protoc_insertion_point(class_scope:runtime.LinuxPodSandboxConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LinuxPodSandboxConfig_SysctlsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > sysctls_;
  ::google::protobuf::internal::ArenaStringPtr cgroup_parent_;
  ::runtime::LinuxSandboxSecurityContext* security_context_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxPodSandboxConfigImpl();
};
// -------------------------------------------------------------------

class PodSandboxMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxMetadata) */ {
 public:
  PodSandboxMetadata();
  virtual ~PodSandboxMetadata();

  PodSandboxMetadata(const PodSandboxMetadata& from);

  inline PodSandboxMetadata& operator=(const PodSandboxMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxMetadata(PodSandboxMetadata&& from) noexcept
    : PodSandboxMetadata() {
    *this = ::std::move(from);
  }

  inline PodSandboxMetadata& operator=(PodSandboxMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxMetadata* internal_default_instance() {
    return reinterpret_cast<const PodSandboxMetadata*>(
               &_PodSandboxMetadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PodSandboxMetadata* other);
  friend void swap(PodSandboxMetadata& a, PodSandboxMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxMetadata* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxMetadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxMetadata& from);
  void MergeFrom(const PodSandboxMetadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // string namespace = 3;
  void clear_namespace_();
  static const int kNamespaceFieldNumber = 3;
  const ::std::string& namespace_() const;
  void set_namespace_(const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_(::std::string&& value);
  #endif
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  ::std::string* mutable_namespace_();
  ::std::string* release_namespace_();
  void set_allocated_namespace_(::std::string* namespace_);

  // uint32 attempt = 4;
  void clear_attempt();
  static const int kAttemptFieldNumber = 4;
  ::google::protobuf::uint32 attempt() const;
  void set_attempt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr namespace__;
  ::google::protobuf::uint32 attempt_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxMetadataImpl();
};
// -------------------------------------------------------------------

class PodSandboxConfig_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxConfig_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxConfig_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxConfig_LabelsEntry_DoNotUse();
  PodSandboxConfig_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxConfig_LabelsEntry_DoNotUse& other);
  static const PodSandboxConfig_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxConfig_LabelsEntry_DoNotUse*>(&_PodSandboxConfig_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxConfig_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxConfig_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxConfig_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxConfig_AnnotationsEntry_DoNotUse();
  PodSandboxConfig_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxConfig_AnnotationsEntry_DoNotUse& other);
  static const PodSandboxConfig_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxConfig_AnnotationsEntry_DoNotUse*>(&_PodSandboxConfig_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxConfig) */ {
 public:
  PodSandboxConfig();
  virtual ~PodSandboxConfig();

  PodSandboxConfig(const PodSandboxConfig& from);

  inline PodSandboxConfig& operator=(const PodSandboxConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxConfig(PodSandboxConfig&& from) noexcept
    : PodSandboxConfig() {
    *this = ::std::move(from);
  }

  inline PodSandboxConfig& operator=(PodSandboxConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxConfig* internal_default_instance() {
    return reinterpret_cast<const PodSandboxConfig*>(
               &_PodSandboxConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(PodSandboxConfig* other);
  friend void swap(PodSandboxConfig& a, PodSandboxConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxConfig& from);
  void MergeFrom(const PodSandboxConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .runtime.PortMapping port_mappings = 5;
  int port_mappings_size() const;
  void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 5;
  const ::runtime::PortMapping& port_mappings(int index) const;
  ::runtime::PortMapping* mutable_port_mappings(int index);
  ::runtime::PortMapping* add_port_mappings();
  ::google::protobuf::RepeatedPtrField< ::runtime::PortMapping >*
      mutable_port_mappings();
  const ::google::protobuf::RepeatedPtrField< ::runtime::PortMapping >&
      port_mappings() const;

  // map<string, string> labels = 6;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 7;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string hostname = 2;
  void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // string log_directory = 3;
  void clear_log_directory();
  static const int kLogDirectoryFieldNumber = 3;
  const ::std::string& log_directory() const;
  void set_log_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_log_directory(::std::string&& value);
  #endif
  void set_log_directory(const char* value);
  void set_log_directory(const char* value, size_t size);
  ::std::string* mutable_log_directory();
  ::std::string* release_log_directory();
  void set_allocated_log_directory(::std::string* log_directory);

  // .runtime.PodSandboxMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::runtime::PodSandboxMetadata& metadata() const;
  ::runtime::PodSandboxMetadata* release_metadata();
  ::runtime::PodSandboxMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::PodSandboxMetadata* metadata);

  // .runtime.DNSConfig dns_config = 4;
  bool has_dns_config() const;
  void clear_dns_config();
  static const int kDnsConfigFieldNumber = 4;
  const ::runtime::DNSConfig& dns_config() const;
  ::runtime::DNSConfig* release_dns_config();
  ::runtime::DNSConfig* mutable_dns_config();
  void set_allocated_dns_config(::runtime::DNSConfig* dns_config);

  // .runtime.LinuxPodSandboxConfig linux = 8;
  bool has_linux() const;
  void clear_linux();
  static const int kLinuxFieldNumber = 8;
  const ::runtime::LinuxPodSandboxConfig& linux() const;
  ::runtime::LinuxPodSandboxConfig* release_linux();
  ::runtime::LinuxPodSandboxConfig* mutable_linux();
  void set_allocated_linux(::runtime::LinuxPodSandboxConfig* linux);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::PortMapping > port_mappings_;
  ::google::protobuf::internal::MapField<
      PodSandboxConfig_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      PodSandboxConfig_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr log_directory_;
  ::runtime::PodSandboxMetadata* metadata_;
  ::runtime::DNSConfig* dns_config_;
  ::runtime::LinuxPodSandboxConfig* linux_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxConfigImpl();
};
// -------------------------------------------------------------------

class RunPodSandboxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RunPodSandboxRequest) */ {
 public:
  RunPodSandboxRequest();
  virtual ~RunPodSandboxRequest();

  RunPodSandboxRequest(const RunPodSandboxRequest& from);

  inline RunPodSandboxRequest& operator=(const RunPodSandboxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunPodSandboxRequest(RunPodSandboxRequest&& from) noexcept
    : RunPodSandboxRequest() {
    *this = ::std::move(from);
  }

  inline RunPodSandboxRequest& operator=(RunPodSandboxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunPodSandboxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunPodSandboxRequest* internal_default_instance() {
    return reinterpret_cast<const RunPodSandboxRequest*>(
               &_RunPodSandboxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RunPodSandboxRequest* other);
  friend void swap(RunPodSandboxRequest& a, RunPodSandboxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunPodSandboxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RunPodSandboxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RunPodSandboxRequest& from);
  void MergeFrom(const RunPodSandboxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RunPodSandboxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.PodSandboxConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::runtime::PodSandboxConfig& config() const;
  ::runtime::PodSandboxConfig* release_config();
  ::runtime::PodSandboxConfig* mutable_config();
  void set_allocated_config(::runtime::PodSandboxConfig* config);

  // @@protoc_insertion_point(class_scope:runtime.RunPodSandboxRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::PodSandboxConfig* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRunPodSandboxRequestImpl();
};
// -------------------------------------------------------------------

class RunPodSandboxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RunPodSandboxResponse) */ {
 public:
  RunPodSandboxResponse();
  virtual ~RunPodSandboxResponse();

  RunPodSandboxResponse(const RunPodSandboxResponse& from);

  inline RunPodSandboxResponse& operator=(const RunPodSandboxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunPodSandboxResponse(RunPodSandboxResponse&& from) noexcept
    : RunPodSandboxResponse() {
    *this = ::std::move(from);
  }

  inline RunPodSandboxResponse& operator=(RunPodSandboxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunPodSandboxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunPodSandboxResponse* internal_default_instance() {
    return reinterpret_cast<const RunPodSandboxResponse*>(
               &_RunPodSandboxResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RunPodSandboxResponse* other);
  friend void swap(RunPodSandboxResponse& a, RunPodSandboxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunPodSandboxResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RunPodSandboxResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RunPodSandboxResponse& from);
  void MergeFrom(const RunPodSandboxResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RunPodSandboxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // @@protoc_insertion_point(class_scope:runtime.RunPodSandboxResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRunPodSandboxResponseImpl();
};
// -------------------------------------------------------------------

class StopPodSandboxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StopPodSandboxRequest) */ {
 public:
  StopPodSandboxRequest();
  virtual ~StopPodSandboxRequest();

  StopPodSandboxRequest(const StopPodSandboxRequest& from);

  inline StopPodSandboxRequest& operator=(const StopPodSandboxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopPodSandboxRequest(StopPodSandboxRequest&& from) noexcept
    : StopPodSandboxRequest() {
    *this = ::std::move(from);
  }

  inline StopPodSandboxRequest& operator=(StopPodSandboxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopPodSandboxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopPodSandboxRequest* internal_default_instance() {
    return reinterpret_cast<const StopPodSandboxRequest*>(
               &_StopPodSandboxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(StopPodSandboxRequest* other);
  friend void swap(StopPodSandboxRequest& a, StopPodSandboxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopPodSandboxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StopPodSandboxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopPodSandboxRequest& from);
  void MergeFrom(const StopPodSandboxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopPodSandboxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // @@protoc_insertion_point(class_scope:runtime.StopPodSandboxRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStopPodSandboxRequestImpl();
};
// -------------------------------------------------------------------

class StopPodSandboxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StopPodSandboxResponse) */ {
 public:
  StopPodSandboxResponse();
  virtual ~StopPodSandboxResponse();

  StopPodSandboxResponse(const StopPodSandboxResponse& from);

  inline StopPodSandboxResponse& operator=(const StopPodSandboxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopPodSandboxResponse(StopPodSandboxResponse&& from) noexcept
    : StopPodSandboxResponse() {
    *this = ::std::move(from);
  }

  inline StopPodSandboxResponse& operator=(StopPodSandboxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopPodSandboxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopPodSandboxResponse* internal_default_instance() {
    return reinterpret_cast<const StopPodSandboxResponse*>(
               &_StopPodSandboxResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(StopPodSandboxResponse* other);
  friend void swap(StopPodSandboxResponse& a, StopPodSandboxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopPodSandboxResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StopPodSandboxResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopPodSandboxResponse& from);
  void MergeFrom(const StopPodSandboxResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopPodSandboxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.StopPodSandboxResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStopPodSandboxResponseImpl();
};
// -------------------------------------------------------------------

class RemovePodSandboxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemovePodSandboxRequest) */ {
 public:
  RemovePodSandboxRequest();
  virtual ~RemovePodSandboxRequest();

  RemovePodSandboxRequest(const RemovePodSandboxRequest& from);

  inline RemovePodSandboxRequest& operator=(const RemovePodSandboxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemovePodSandboxRequest(RemovePodSandboxRequest&& from) noexcept
    : RemovePodSandboxRequest() {
    *this = ::std::move(from);
  }

  inline RemovePodSandboxRequest& operator=(RemovePodSandboxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemovePodSandboxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemovePodSandboxRequest* internal_default_instance() {
    return reinterpret_cast<const RemovePodSandboxRequest*>(
               &_RemovePodSandboxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(RemovePodSandboxRequest* other);
  friend void swap(RemovePodSandboxRequest& a, RemovePodSandboxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemovePodSandboxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RemovePodSandboxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemovePodSandboxRequest& from);
  void MergeFrom(const RemovePodSandboxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemovePodSandboxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // @@protoc_insertion_point(class_scope:runtime.RemovePodSandboxRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemovePodSandboxRequestImpl();
};
// -------------------------------------------------------------------

class RemovePodSandboxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemovePodSandboxResponse) */ {
 public:
  RemovePodSandboxResponse();
  virtual ~RemovePodSandboxResponse();

  RemovePodSandboxResponse(const RemovePodSandboxResponse& from);

  inline RemovePodSandboxResponse& operator=(const RemovePodSandboxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemovePodSandboxResponse(RemovePodSandboxResponse&& from) noexcept
    : RemovePodSandboxResponse() {
    *this = ::std::move(from);
  }

  inline RemovePodSandboxResponse& operator=(RemovePodSandboxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemovePodSandboxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemovePodSandboxResponse* internal_default_instance() {
    return reinterpret_cast<const RemovePodSandboxResponse*>(
               &_RemovePodSandboxResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RemovePodSandboxResponse* other);
  friend void swap(RemovePodSandboxResponse& a, RemovePodSandboxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemovePodSandboxResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RemovePodSandboxResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemovePodSandboxResponse& from);
  void MergeFrom(const RemovePodSandboxResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemovePodSandboxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.RemovePodSandboxResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemovePodSandboxResponseImpl();
};
// -------------------------------------------------------------------

class PodSandboxStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxStatusRequest) */ {
 public:
  PodSandboxStatusRequest();
  virtual ~PodSandboxStatusRequest();

  PodSandboxStatusRequest(const PodSandboxStatusRequest& from);

  inline PodSandboxStatusRequest& operator=(const PodSandboxStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxStatusRequest(PodSandboxStatusRequest&& from) noexcept
    : PodSandboxStatusRequest() {
    *this = ::std::move(from);
  }

  inline PodSandboxStatusRequest& operator=(PodSandboxStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxStatusRequest* internal_default_instance() {
    return reinterpret_cast<const PodSandboxStatusRequest*>(
               &_PodSandboxStatusRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(PodSandboxStatusRequest* other);
  friend void swap(PodSandboxStatusRequest& a, PodSandboxStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxStatusRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxStatusRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxStatusRequest& from);
  void MergeFrom(const PodSandboxStatusRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // bool verbose = 2;
  void clear_verbose();
  static const int kVerboseFieldNumber = 2;
  bool verbose() const;
  void set_verbose(bool value);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxStatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  bool verbose_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxStatusRequestImpl();
};
// -------------------------------------------------------------------

class PodSandboxNetworkStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxNetworkStatus) */ {
 public:
  PodSandboxNetworkStatus();
  virtual ~PodSandboxNetworkStatus();

  PodSandboxNetworkStatus(const PodSandboxNetworkStatus& from);

  inline PodSandboxNetworkStatus& operator=(const PodSandboxNetworkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxNetworkStatus(PodSandboxNetworkStatus&& from) noexcept
    : PodSandboxNetworkStatus() {
    *this = ::std::move(from);
  }

  inline PodSandboxNetworkStatus& operator=(PodSandboxNetworkStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxNetworkStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxNetworkStatus* internal_default_instance() {
    return reinterpret_cast<const PodSandboxNetworkStatus*>(
               &_PodSandboxNetworkStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(PodSandboxNetworkStatus* other);
  friend void swap(PodSandboxNetworkStatus& a, PodSandboxNetworkStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxNetworkStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxNetworkStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxNetworkStatus& from);
  void MergeFrom(const PodSandboxNetworkStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxNetworkStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxNetworkStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxNetworkStatusImpl();
};
// -------------------------------------------------------------------

class Namespace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Namespace) */ {
 public:
  Namespace();
  virtual ~Namespace();

  Namespace(const Namespace& from);

  inline Namespace& operator=(const Namespace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Namespace(Namespace&& from) noexcept
    : Namespace() {
    *this = ::std::move(from);
  }

  inline Namespace& operator=(Namespace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Namespace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Namespace* internal_default_instance() {
    return reinterpret_cast<const Namespace*>(
               &_Namespace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Namespace* other);
  friend void swap(Namespace& a, Namespace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Namespace* New() const PROTOBUF_FINAL { return New(NULL); }

  Namespace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Namespace& from);
  void MergeFrom(const Namespace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Namespace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.NamespaceOption options = 2;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::runtime::NamespaceOption& options() const;
  ::runtime::NamespaceOption* release_options();
  ::runtime::NamespaceOption* mutable_options();
  void set_allocated_options(::runtime::NamespaceOption* options);

  // @@protoc_insertion_point(class_scope:runtime.Namespace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::NamespaceOption* options_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsNamespaceImpl();
};
// -------------------------------------------------------------------

class LinuxPodSandboxStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxPodSandboxStatus) */ {
 public:
  LinuxPodSandboxStatus();
  virtual ~LinuxPodSandboxStatus();

  LinuxPodSandboxStatus(const LinuxPodSandboxStatus& from);

  inline LinuxPodSandboxStatus& operator=(const LinuxPodSandboxStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxPodSandboxStatus(LinuxPodSandboxStatus&& from) noexcept
    : LinuxPodSandboxStatus() {
    *this = ::std::move(from);
  }

  inline LinuxPodSandboxStatus& operator=(LinuxPodSandboxStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxPodSandboxStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxPodSandboxStatus* internal_default_instance() {
    return reinterpret_cast<const LinuxPodSandboxStatus*>(
               &_LinuxPodSandboxStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(LinuxPodSandboxStatus* other);
  friend void swap(LinuxPodSandboxStatus& a, LinuxPodSandboxStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxPodSandboxStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxPodSandboxStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxPodSandboxStatus& from);
  void MergeFrom(const LinuxPodSandboxStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxPodSandboxStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.Namespace namespaces = 1;
  bool has_namespaces() const;
  void clear_namespaces();
  static const int kNamespacesFieldNumber = 1;
  const ::runtime::Namespace& namespaces() const;
  ::runtime::Namespace* release_namespaces();
  ::runtime::Namespace* mutable_namespaces();
  void set_allocated_namespaces(::runtime::Namespace* namespaces);

  // @@protoc_insertion_point(class_scope:runtime.LinuxPodSandboxStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::Namespace* namespaces_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxPodSandboxStatusImpl();
};
// -------------------------------------------------------------------

class PodSandboxStatus_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxStatus_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxStatus_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxStatus_LabelsEntry_DoNotUse();
  PodSandboxStatus_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxStatus_LabelsEntry_DoNotUse& other);
  static const PodSandboxStatus_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxStatus_LabelsEntry_DoNotUse*>(&_PodSandboxStatus_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxStatus_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxStatus_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxStatus_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxStatus_AnnotationsEntry_DoNotUse();
  PodSandboxStatus_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxStatus_AnnotationsEntry_DoNotUse& other);
  static const PodSandboxStatus_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxStatus_AnnotationsEntry_DoNotUse*>(&_PodSandboxStatus_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxStatus) */ {
 public:
  PodSandboxStatus();
  virtual ~PodSandboxStatus();

  PodSandboxStatus(const PodSandboxStatus& from);

  inline PodSandboxStatus& operator=(const PodSandboxStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxStatus(PodSandboxStatus&& from) noexcept
    : PodSandboxStatus() {
    *this = ::std::move(from);
  }

  inline PodSandboxStatus& operator=(PodSandboxStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxStatus* internal_default_instance() {
    return reinterpret_cast<const PodSandboxStatus*>(
               &_PodSandboxStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(PodSandboxStatus* other);
  friend void swap(PodSandboxStatus& a, PodSandboxStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxStatus& from);
  void MergeFrom(const PodSandboxStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 7;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 8;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 8;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .runtime.PodSandboxMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::runtime::PodSandboxMetadata& metadata() const;
  ::runtime::PodSandboxMetadata* release_metadata();
  ::runtime::PodSandboxMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::PodSandboxMetadata* metadata);

  // .runtime.PodSandboxNetworkStatus network = 5;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 5;
  const ::runtime::PodSandboxNetworkStatus& network() const;
  ::runtime::PodSandboxNetworkStatus* release_network();
  ::runtime::PodSandboxNetworkStatus* mutable_network();
  void set_allocated_network(::runtime::PodSandboxNetworkStatus* network);

  // .runtime.LinuxPodSandboxStatus linux = 6;
  bool has_linux() const;
  void clear_linux();
  static const int kLinuxFieldNumber = 6;
  const ::runtime::LinuxPodSandboxStatus& linux() const;
  ::runtime::LinuxPodSandboxStatus* release_linux();
  ::runtime::LinuxPodSandboxStatus* mutable_linux();
  void set_allocated_linux(::runtime::LinuxPodSandboxStatus* linux);

  // int64 created_at = 4;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 4;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // .runtime.PodSandboxState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::runtime::PodSandboxState state() const;
  void set_state(::runtime::PodSandboxState value);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PodSandboxStatus_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      PodSandboxStatus_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::runtime::PodSandboxMetadata* metadata_;
  ::runtime::PodSandboxNetworkStatus* network_;
  ::runtime::LinuxPodSandboxStatus* linux_;
  ::google::protobuf::int64 created_at_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxStatusImpl();
};
// -------------------------------------------------------------------

class PodSandboxStatusResponse_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxStatusResponse_InfoEntry_DoNotUse();
  PodSandboxStatusResponse_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxStatusResponse_InfoEntry_DoNotUse& other);
  static const PodSandboxStatusResponse_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxStatusResponse_InfoEntry_DoNotUse*>(&_PodSandboxStatusResponse_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxStatusResponse) */ {
 public:
  PodSandboxStatusResponse();
  virtual ~PodSandboxStatusResponse();

  PodSandboxStatusResponse(const PodSandboxStatusResponse& from);

  inline PodSandboxStatusResponse& operator=(const PodSandboxStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxStatusResponse(PodSandboxStatusResponse&& from) noexcept
    : PodSandboxStatusResponse() {
    *this = ::std::move(from);
  }

  inline PodSandboxStatusResponse& operator=(PodSandboxStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxStatusResponse* internal_default_instance() {
    return reinterpret_cast<const PodSandboxStatusResponse*>(
               &_PodSandboxStatusResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(PodSandboxStatusResponse* other);
  friend void swap(PodSandboxStatusResponse& a, PodSandboxStatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxStatusResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxStatusResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxStatusResponse& from);
  void MergeFrom(const PodSandboxStatusResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 2;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // .runtime.PodSandboxStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::runtime::PodSandboxStatus& status() const;
  ::runtime::PodSandboxStatus* release_status();
  ::runtime::PodSandboxStatus* mutable_status();
  void set_allocated_status(::runtime::PodSandboxStatus* status);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxStatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PodSandboxStatusResponse_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::runtime::PodSandboxStatus* status_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxStatusResponseImpl();
};
// -------------------------------------------------------------------

class PodSandboxStateValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxStateValue) */ {
 public:
  PodSandboxStateValue();
  virtual ~PodSandboxStateValue();

  PodSandboxStateValue(const PodSandboxStateValue& from);

  inline PodSandboxStateValue& operator=(const PodSandboxStateValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxStateValue(PodSandboxStateValue&& from) noexcept
    : PodSandboxStateValue() {
    *this = ::std::move(from);
  }

  inline PodSandboxStateValue& operator=(PodSandboxStateValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxStateValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxStateValue* internal_default_instance() {
    return reinterpret_cast<const PodSandboxStateValue*>(
               &_PodSandboxStateValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(PodSandboxStateValue* other);
  friend void swap(PodSandboxStateValue& a, PodSandboxStateValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxStateValue* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxStateValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxStateValue& from);
  void MergeFrom(const PodSandboxStateValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxStateValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.PodSandboxState state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::runtime::PodSandboxState state() const;
  void set_state(::runtime::PodSandboxState value);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxStateValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxStateValueImpl();
};
// -------------------------------------------------------------------

class PodSandboxFilter_LabelSelectorEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandboxFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandboxFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandboxFilter_LabelSelectorEntry_DoNotUse();
  PodSandboxFilter_LabelSelectorEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandboxFilter_LabelSelectorEntry_DoNotUse& other);
  static const PodSandboxFilter_LabelSelectorEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandboxFilter_LabelSelectorEntry_DoNotUse*>(&_PodSandboxFilter_LabelSelectorEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandboxFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandboxFilter) */ {
 public:
  PodSandboxFilter();
  virtual ~PodSandboxFilter();

  PodSandboxFilter(const PodSandboxFilter& from);

  inline PodSandboxFilter& operator=(const PodSandboxFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandboxFilter(PodSandboxFilter&& from) noexcept
    : PodSandboxFilter() {
    *this = ::std::move(from);
  }

  inline PodSandboxFilter& operator=(PodSandboxFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandboxFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandboxFilter* internal_default_instance() {
    return reinterpret_cast<const PodSandboxFilter*>(
               &_PodSandboxFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(PodSandboxFilter* other);
  friend void swap(PodSandboxFilter& a, PodSandboxFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandboxFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandboxFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandboxFilter& from);
  void MergeFrom(const PodSandboxFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandboxFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> label_selector = 3;
  int label_selector_size() const;
  void clear_label_selector();
  static const int kLabelSelectorFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      label_selector() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_label_selector();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .runtime.PodSandboxStateValue state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::runtime::PodSandboxStateValue& state() const;
  ::runtime::PodSandboxStateValue* release_state();
  ::runtime::PodSandboxStateValue* mutable_state();
  void set_allocated_state(::runtime::PodSandboxStateValue* state);

  // @@protoc_insertion_point(class_scope:runtime.PodSandboxFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PodSandboxFilter_LabelSelectorEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > label_selector_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::runtime::PodSandboxStateValue* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxFilterImpl();
};
// -------------------------------------------------------------------

class ListPodSandboxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListPodSandboxRequest) */ {
 public:
  ListPodSandboxRequest();
  virtual ~ListPodSandboxRequest();

  ListPodSandboxRequest(const ListPodSandboxRequest& from);

  inline ListPodSandboxRequest& operator=(const ListPodSandboxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListPodSandboxRequest(ListPodSandboxRequest&& from) noexcept
    : ListPodSandboxRequest() {
    *this = ::std::move(from);
  }

  inline ListPodSandboxRequest& operator=(ListPodSandboxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListPodSandboxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPodSandboxRequest* internal_default_instance() {
    return reinterpret_cast<const ListPodSandboxRequest*>(
               &_ListPodSandboxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(ListPodSandboxRequest* other);
  friend void swap(ListPodSandboxRequest& a, ListPodSandboxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListPodSandboxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListPodSandboxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListPodSandboxRequest& from);
  void MergeFrom(const ListPodSandboxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListPodSandboxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.PodSandboxFilter filter = 1;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::runtime::PodSandboxFilter& filter() const;
  ::runtime::PodSandboxFilter* release_filter();
  ::runtime::PodSandboxFilter* mutable_filter();
  void set_allocated_filter(::runtime::PodSandboxFilter* filter);

  // @@protoc_insertion_point(class_scope:runtime.ListPodSandboxRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::PodSandboxFilter* filter_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListPodSandboxRequestImpl();
};
// -------------------------------------------------------------------

class PodSandbox_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandbox_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandbox_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandbox_LabelsEntry_DoNotUse();
  PodSandbox_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandbox_LabelsEntry_DoNotUse& other);
  static const PodSandbox_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandbox_LabelsEntry_DoNotUse*>(&_PodSandbox_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandbox_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PodSandbox_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PodSandbox_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  PodSandbox_AnnotationsEntry_DoNotUse();
  PodSandbox_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PodSandbox_AnnotationsEntry_DoNotUse& other);
  static const PodSandbox_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PodSandbox_AnnotationsEntry_DoNotUse*>(&_PodSandbox_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PodSandbox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PodSandbox) */ {
 public:
  PodSandbox();
  virtual ~PodSandbox();

  PodSandbox(const PodSandbox& from);

  inline PodSandbox& operator=(const PodSandbox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PodSandbox(PodSandbox&& from) noexcept
    : PodSandbox() {
    *this = ::std::move(from);
  }

  inline PodSandbox& operator=(PodSandbox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSandbox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PodSandbox* internal_default_instance() {
    return reinterpret_cast<const PodSandbox*>(
               &_PodSandbox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(PodSandbox* other);
  friend void swap(PodSandbox& a, PodSandbox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PodSandbox* New() const PROTOBUF_FINAL { return New(NULL); }

  PodSandbox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PodSandbox& from);
  void MergeFrom(const PodSandbox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PodSandbox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 5;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 6;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .runtime.PodSandboxMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::runtime::PodSandboxMetadata& metadata() const;
  ::runtime::PodSandboxMetadata* release_metadata();
  ::runtime::PodSandboxMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::PodSandboxMetadata* metadata);

  // int64 created_at = 4;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 4;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // .runtime.PodSandboxState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::runtime::PodSandboxState state() const;
  void set_state(::runtime::PodSandboxState value);

  // @@protoc_insertion_point(class_scope:runtime.PodSandbox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      PodSandbox_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      PodSandbox_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::runtime::PodSandboxMetadata* metadata_;
  ::google::protobuf::int64 created_at_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPodSandboxImpl();
};
// -------------------------------------------------------------------

class ListPodSandboxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListPodSandboxResponse) */ {
 public:
  ListPodSandboxResponse();
  virtual ~ListPodSandboxResponse();

  ListPodSandboxResponse(const ListPodSandboxResponse& from);

  inline ListPodSandboxResponse& operator=(const ListPodSandboxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListPodSandboxResponse(ListPodSandboxResponse&& from) noexcept
    : ListPodSandboxResponse() {
    *this = ::std::move(from);
  }

  inline ListPodSandboxResponse& operator=(ListPodSandboxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListPodSandboxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPodSandboxResponse* internal_default_instance() {
    return reinterpret_cast<const ListPodSandboxResponse*>(
               &_ListPodSandboxResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(ListPodSandboxResponse* other);
  friend void swap(ListPodSandboxResponse& a, ListPodSandboxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListPodSandboxResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ListPodSandboxResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListPodSandboxResponse& from);
  void MergeFrom(const ListPodSandboxResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListPodSandboxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.PodSandbox items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::runtime::PodSandbox& items(int index) const;
  ::runtime::PodSandbox* mutable_items(int index);
  ::runtime::PodSandbox* add_items();
  ::google::protobuf::RepeatedPtrField< ::runtime::PodSandbox >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::runtime::PodSandbox >&
      items() const;

  // @@protoc_insertion_point(class_scope:runtime.ListPodSandboxResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::PodSandbox > items_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListPodSandboxResponseImpl();
};
// -------------------------------------------------------------------

class ImageSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageSpec) */ {
 public:
  ImageSpec();
  virtual ~ImageSpec();

  ImageSpec(const ImageSpec& from);

  inline ImageSpec& operator=(const ImageSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageSpec(ImageSpec&& from) noexcept
    : ImageSpec() {
    *this = ::std::move(from);
  }

  inline ImageSpec& operator=(ImageSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageSpec* internal_default_instance() {
    return reinterpret_cast<const ImageSpec*>(
               &_ImageSpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ImageSpec* other);
  friend void swap(ImageSpec& a, ImageSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageSpec& from);
  void MergeFrom(const ImageSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string image = 1;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // @@protoc_insertion_point(class_scope:runtime.ImageSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageSpecImpl();
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:runtime.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsKeyValueImpl();
};
// -------------------------------------------------------------------

class LinuxContainerResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxContainerResources) */ {
 public:
  LinuxContainerResources();
  virtual ~LinuxContainerResources();

  LinuxContainerResources(const LinuxContainerResources& from);

  inline LinuxContainerResources& operator=(const LinuxContainerResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxContainerResources(LinuxContainerResources&& from) noexcept
    : LinuxContainerResources() {
    *this = ::std::move(from);
  }

  inline LinuxContainerResources& operator=(LinuxContainerResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxContainerResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxContainerResources* internal_default_instance() {
    return reinterpret_cast<const LinuxContainerResources*>(
               &_LinuxContainerResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(LinuxContainerResources* other);
  friend void swap(LinuxContainerResources& a, LinuxContainerResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxContainerResources* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxContainerResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxContainerResources& from);
  void MergeFrom(const LinuxContainerResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxContainerResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cpuset_cpus = 6;
  void clear_cpuset_cpus();
  static const int kCpusetCpusFieldNumber = 6;
  const ::std::string& cpuset_cpus() const;
  void set_cpuset_cpus(const ::std::string& value);
  #if LANG_CXX11
  void set_cpuset_cpus(::std::string&& value);
  #endif
  void set_cpuset_cpus(const char* value);
  void set_cpuset_cpus(const char* value, size_t size);
  ::std::string* mutable_cpuset_cpus();
  ::std::string* release_cpuset_cpus();
  void set_allocated_cpuset_cpus(::std::string* cpuset_cpus);

  // string cpuset_mems = 7;
  void clear_cpuset_mems();
  static const int kCpusetMemsFieldNumber = 7;
  const ::std::string& cpuset_mems() const;
  void set_cpuset_mems(const ::std::string& value);
  #if LANG_CXX11
  void set_cpuset_mems(::std::string&& value);
  #endif
  void set_cpuset_mems(const char* value);
  void set_cpuset_mems(const char* value, size_t size);
  ::std::string* mutable_cpuset_mems();
  ::std::string* release_cpuset_mems();
  void set_allocated_cpuset_mems(::std::string* cpuset_mems);

  // int64 cpu_period = 1;
  void clear_cpu_period();
  static const int kCpuPeriodFieldNumber = 1;
  ::google::protobuf::int64 cpu_period() const;
  void set_cpu_period(::google::protobuf::int64 value);

  // int64 cpu_quota = 2;
  void clear_cpu_quota();
  static const int kCpuQuotaFieldNumber = 2;
  ::google::protobuf::int64 cpu_quota() const;
  void set_cpu_quota(::google::protobuf::int64 value);

  // int64 cpu_shares = 3;
  void clear_cpu_shares();
  static const int kCpuSharesFieldNumber = 3;
  ::google::protobuf::int64 cpu_shares() const;
  void set_cpu_shares(::google::protobuf::int64 value);

  // int64 memory_limit_in_bytes = 4;
  void clear_memory_limit_in_bytes();
  static const int kMemoryLimitInBytesFieldNumber = 4;
  ::google::protobuf::int64 memory_limit_in_bytes() const;
  void set_memory_limit_in_bytes(::google::protobuf::int64 value);

  // int64 oom_score_adj = 5;
  void clear_oom_score_adj();
  static const int kOomScoreAdjFieldNumber = 5;
  ::google::protobuf::int64 oom_score_adj() const;
  void set_oom_score_adj(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.LinuxContainerResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cpuset_cpus_;
  ::google::protobuf::internal::ArenaStringPtr cpuset_mems_;
  ::google::protobuf::int64 cpu_period_;
  ::google::protobuf::int64 cpu_quota_;
  ::google::protobuf::int64 cpu_shares_;
  ::google::protobuf::int64 memory_limit_in_bytes_;
  ::google::protobuf::int64 oom_score_adj_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxContainerResourcesImpl();
};
// -------------------------------------------------------------------

class SELinuxOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.SELinuxOption) */ {
 public:
  SELinuxOption();
  virtual ~SELinuxOption();

  SELinuxOption(const SELinuxOption& from);

  inline SELinuxOption& operator=(const SELinuxOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SELinuxOption(SELinuxOption&& from) noexcept
    : SELinuxOption() {
    *this = ::std::move(from);
  }

  inline SELinuxOption& operator=(SELinuxOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SELinuxOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SELinuxOption* internal_default_instance() {
    return reinterpret_cast<const SELinuxOption*>(
               &_SELinuxOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(SELinuxOption* other);
  friend void swap(SELinuxOption& a, SELinuxOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SELinuxOption* New() const PROTOBUF_FINAL { return New(NULL); }

  SELinuxOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SELinuxOption& from);
  void MergeFrom(const SELinuxOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SELinuxOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // string role = 2;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string level = 4;
  void clear_level();
  static const int kLevelFieldNumber = 4;
  const ::std::string& level() const;
  void set_level(const ::std::string& value);
  #if LANG_CXX11
  void set_level(::std::string&& value);
  #endif
  void set_level(const char* value);
  void set_level(const char* value, size_t size);
  ::std::string* mutable_level();
  ::std::string* release_level();
  void set_allocated_level(::std::string* level);

  // @@protoc_insertion_point(class_scope:runtime.SELinuxOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr level_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsSELinuxOptionImpl();
};
// -------------------------------------------------------------------

class Capability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Capability) */ {
 public:
  Capability();
  virtual ~Capability();

  Capability(const Capability& from);

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capability(Capability&& from) noexcept
    : Capability() {
    *this = ::std::move(from);
  }

  inline Capability& operator=(Capability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Capability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capability* internal_default_instance() {
    return reinterpret_cast<const Capability*>(
               &_Capability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Capability* other);
  friend void swap(Capability& a, Capability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capability* New() const PROTOBUF_FINAL { return New(NULL); }

  Capability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Capability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string add_capabilities = 1;
  int add_capabilities_size() const;
  void clear_add_capabilities();
  static const int kAddCapabilitiesFieldNumber = 1;
  const ::std::string& add_capabilities(int index) const;
  ::std::string* mutable_add_capabilities(int index);
  void set_add_capabilities(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_add_capabilities(int index, ::std::string&& value);
  #endif
  void set_add_capabilities(int index, const char* value);
  void set_add_capabilities(int index, const char* value, size_t size);
  ::std::string* add_add_capabilities();
  void add_add_capabilities(const ::std::string& value);
  #if LANG_CXX11
  void add_add_capabilities(::std::string&& value);
  #endif
  void add_add_capabilities(const char* value);
  void add_add_capabilities(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& add_capabilities() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_add_capabilities();

  // repeated string drop_capabilities = 2;
  int drop_capabilities_size() const;
  void clear_drop_capabilities();
  static const int kDropCapabilitiesFieldNumber = 2;
  const ::std::string& drop_capabilities(int index) const;
  ::std::string* mutable_drop_capabilities(int index);
  void set_drop_capabilities(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_drop_capabilities(int index, ::std::string&& value);
  #endif
  void set_drop_capabilities(int index, const char* value);
  void set_drop_capabilities(int index, const char* value, size_t size);
  ::std::string* add_drop_capabilities();
  void add_drop_capabilities(const ::std::string& value);
  #if LANG_CXX11
  void add_drop_capabilities(::std::string&& value);
  #endif
  void add_drop_capabilities(const char* value);
  void add_drop_capabilities(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& drop_capabilities() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_drop_capabilities();

  // @@protoc_insertion_point(class_scope:runtime.Capability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> add_capabilities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> drop_capabilities_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsCapabilityImpl();
};
// -------------------------------------------------------------------

class LinuxContainerSecurityContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxContainerSecurityContext) */ {
 public:
  LinuxContainerSecurityContext();
  virtual ~LinuxContainerSecurityContext();

  LinuxContainerSecurityContext(const LinuxContainerSecurityContext& from);

  inline LinuxContainerSecurityContext& operator=(const LinuxContainerSecurityContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxContainerSecurityContext(LinuxContainerSecurityContext&& from) noexcept
    : LinuxContainerSecurityContext() {
    *this = ::std::move(from);
  }

  inline LinuxContainerSecurityContext& operator=(LinuxContainerSecurityContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxContainerSecurityContext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxContainerSecurityContext* internal_default_instance() {
    return reinterpret_cast<const LinuxContainerSecurityContext*>(
               &_LinuxContainerSecurityContext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(LinuxContainerSecurityContext* other);
  friend void swap(LinuxContainerSecurityContext& a, LinuxContainerSecurityContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxContainerSecurityContext* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxContainerSecurityContext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxContainerSecurityContext& from);
  void MergeFrom(const LinuxContainerSecurityContext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxContainerSecurityContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 supplemental_groups = 8;
  int supplemental_groups_size() const;
  void clear_supplemental_groups();
  static const int kSupplementalGroupsFieldNumber = 8;
  ::google::protobuf::int64 supplemental_groups(int index) const;
  void set_supplemental_groups(int index, ::google::protobuf::int64 value);
  void add_supplemental_groups(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      supplemental_groups() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_supplemental_groups();

  // string run_as_username = 6;
  void clear_run_as_username();
  static const int kRunAsUsernameFieldNumber = 6;
  const ::std::string& run_as_username() const;
  void set_run_as_username(const ::std::string& value);
  #if LANG_CXX11
  void set_run_as_username(::std::string&& value);
  #endif
  void set_run_as_username(const char* value);
  void set_run_as_username(const char* value, size_t size);
  ::std::string* mutable_run_as_username();
  ::std::string* release_run_as_username();
  void set_allocated_run_as_username(::std::string* run_as_username);

  // string apparmor_profile = 9;
  void clear_apparmor_profile();
  static const int kApparmorProfileFieldNumber = 9;
  const ::std::string& apparmor_profile() const;
  void set_apparmor_profile(const ::std::string& value);
  #if LANG_CXX11
  void set_apparmor_profile(::std::string&& value);
  #endif
  void set_apparmor_profile(const char* value);
  void set_apparmor_profile(const char* value, size_t size);
  ::std::string* mutable_apparmor_profile();
  ::std::string* release_apparmor_profile();
  void set_allocated_apparmor_profile(::std::string* apparmor_profile);

  // string seccomp_profile_path = 10;
  void clear_seccomp_profile_path();
  static const int kSeccompProfilePathFieldNumber = 10;
  const ::std::string& seccomp_profile_path() const;
  void set_seccomp_profile_path(const ::std::string& value);
  #if LANG_CXX11
  void set_seccomp_profile_path(::std::string&& value);
  #endif
  void set_seccomp_profile_path(const char* value);
  void set_seccomp_profile_path(const char* value, size_t size);
  ::std::string* mutable_seccomp_profile_path();
  ::std::string* release_seccomp_profile_path();
  void set_allocated_seccomp_profile_path(::std::string* seccomp_profile_path);

  // .runtime.Capability capabilities = 1;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 1;
  const ::runtime::Capability& capabilities() const;
  ::runtime::Capability* release_capabilities();
  ::runtime::Capability* mutable_capabilities();
  void set_allocated_capabilities(::runtime::Capability* capabilities);

  // .runtime.NamespaceOption namespace_options = 3;
  bool has_namespace_options() const;
  void clear_namespace_options();
  static const int kNamespaceOptionsFieldNumber = 3;
  const ::runtime::NamespaceOption& namespace_options() const;
  ::runtime::NamespaceOption* release_namespace_options();
  ::runtime::NamespaceOption* mutable_namespace_options();
  void set_allocated_namespace_options(::runtime::NamespaceOption* namespace_options);

  // .runtime.SELinuxOption selinux_options = 4;
  bool has_selinux_options() const;
  void clear_selinux_options();
  static const int kSelinuxOptionsFieldNumber = 4;
  const ::runtime::SELinuxOption& selinux_options() const;
  ::runtime::SELinuxOption* release_selinux_options();
  ::runtime::SELinuxOption* mutable_selinux_options();
  void set_allocated_selinux_options(::runtime::SELinuxOption* selinux_options);

  // .runtime.Int64Value run_as_user = 5;
  bool has_run_as_user() const;
  void clear_run_as_user();
  static const int kRunAsUserFieldNumber = 5;
  const ::runtime::Int64Value& run_as_user() const;
  ::runtime::Int64Value* release_run_as_user();
  ::runtime::Int64Value* mutable_run_as_user();
  void set_allocated_run_as_user(::runtime::Int64Value* run_as_user);

  // bool privileged = 2;
  void clear_privileged();
  static const int kPrivilegedFieldNumber = 2;
  bool privileged() const;
  void set_privileged(bool value);

  // bool readonly_rootfs = 7;
  void clear_readonly_rootfs();
  static const int kReadonlyRootfsFieldNumber = 7;
  bool readonly_rootfs() const;
  void set_readonly_rootfs(bool value);

  // bool no_new_privs = 11;
  void clear_no_new_privs();
  static const int kNoNewPrivsFieldNumber = 11;
  bool no_new_privs() const;
  void set_no_new_privs(bool value);

  // @@protoc_insertion_point(class_scope:runtime.LinuxContainerSecurityContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > supplemental_groups_;
  mutable int _supplemental_groups_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr run_as_username_;
  ::google::protobuf::internal::ArenaStringPtr apparmor_profile_;
  ::google::protobuf::internal::ArenaStringPtr seccomp_profile_path_;
  ::runtime::Capability* capabilities_;
  ::runtime::NamespaceOption* namespace_options_;
  ::runtime::SELinuxOption* selinux_options_;
  ::runtime::Int64Value* run_as_user_;
  bool privileged_;
  bool readonly_rootfs_;
  bool no_new_privs_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxContainerSecurityContextImpl();
};
// -------------------------------------------------------------------

class LinuxContainerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.LinuxContainerConfig) */ {
 public:
  LinuxContainerConfig();
  virtual ~LinuxContainerConfig();

  LinuxContainerConfig(const LinuxContainerConfig& from);

  inline LinuxContainerConfig& operator=(const LinuxContainerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinuxContainerConfig(LinuxContainerConfig&& from) noexcept
    : LinuxContainerConfig() {
    *this = ::std::move(from);
  }

  inline LinuxContainerConfig& operator=(LinuxContainerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxContainerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinuxContainerConfig* internal_default_instance() {
    return reinterpret_cast<const LinuxContainerConfig*>(
               &_LinuxContainerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(LinuxContainerConfig* other);
  friend void swap(LinuxContainerConfig& a, LinuxContainerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinuxContainerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  LinuxContainerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinuxContainerConfig& from);
  void MergeFrom(const LinuxContainerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinuxContainerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.LinuxContainerResources resources = 1;
  bool has_resources() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 1;
  const ::runtime::LinuxContainerResources& resources() const;
  ::runtime::LinuxContainerResources* release_resources();
  ::runtime::LinuxContainerResources* mutable_resources();
  void set_allocated_resources(::runtime::LinuxContainerResources* resources);

  // .runtime.LinuxContainerSecurityContext security_context = 2;
  bool has_security_context() const;
  void clear_security_context();
  static const int kSecurityContextFieldNumber = 2;
  const ::runtime::LinuxContainerSecurityContext& security_context() const;
  ::runtime::LinuxContainerSecurityContext* release_security_context();
  ::runtime::LinuxContainerSecurityContext* mutable_security_context();
  void set_allocated_security_context(::runtime::LinuxContainerSecurityContext* security_context);

  // @@protoc_insertion_point(class_scope:runtime.LinuxContainerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::LinuxContainerResources* resources_;
  ::runtime::LinuxContainerSecurityContext* security_context_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsLinuxContainerConfigImpl();
};
// -------------------------------------------------------------------

class ContainerMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerMetadata) */ {
 public:
  ContainerMetadata();
  virtual ~ContainerMetadata();

  ContainerMetadata(const ContainerMetadata& from);

  inline ContainerMetadata& operator=(const ContainerMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerMetadata(ContainerMetadata&& from) noexcept
    : ContainerMetadata() {
    *this = ::std::move(from);
  }

  inline ContainerMetadata& operator=(ContainerMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerMetadata* internal_default_instance() {
    return reinterpret_cast<const ContainerMetadata*>(
               &_ContainerMetadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ContainerMetadata* other);
  friend void swap(ContainerMetadata& a, ContainerMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerMetadata* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerMetadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerMetadata& from);
  void MergeFrom(const ContainerMetadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 attempt = 2;
  void clear_attempt();
  static const int kAttemptFieldNumber = 2;
  ::google::protobuf::uint32 attempt() const;
  void set_attempt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:runtime.ContainerMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 attempt_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerMetadataImpl();
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Device) */ {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(Device&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(Device* other);
  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const PROTOBUF_FINAL { return New(NULL); }

  Device* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Device* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_path = 1;
  void clear_container_path();
  static const int kContainerPathFieldNumber = 1;
  const ::std::string& container_path() const;
  void set_container_path(const ::std::string& value);
  #if LANG_CXX11
  void set_container_path(::std::string&& value);
  #endif
  void set_container_path(const char* value);
  void set_container_path(const char* value, size_t size);
  ::std::string* mutable_container_path();
  ::std::string* release_container_path();
  void set_allocated_container_path(::std::string* container_path);

  // string host_path = 2;
  void clear_host_path();
  static const int kHostPathFieldNumber = 2;
  const ::std::string& host_path() const;
  void set_host_path(const ::std::string& value);
  #if LANG_CXX11
  void set_host_path(::std::string&& value);
  #endif
  void set_host_path(const char* value);
  void set_host_path(const char* value, size_t size);
  ::std::string* mutable_host_path();
  ::std::string* release_host_path();
  void set_allocated_host_path(::std::string* host_path);

  // string permissions = 3;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 3;
  const ::std::string& permissions() const;
  void set_permissions(const ::std::string& value);
  #if LANG_CXX11
  void set_permissions(::std::string&& value);
  #endif
  void set_permissions(const char* value);
  void set_permissions(const char* value, size_t size);
  ::std::string* mutable_permissions();
  ::std::string* release_permissions();
  void set_allocated_permissions(::std::string* permissions);

  // @@protoc_insertion_point(class_scope:runtime.Device)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_path_;
  ::google::protobuf::internal::ArenaStringPtr host_path_;
  ::google::protobuf::internal::ArenaStringPtr permissions_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsDeviceImpl();
};
// -------------------------------------------------------------------

class ContainerConfig_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerConfig_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerConfig_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerConfig_LabelsEntry_DoNotUse();
  ContainerConfig_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerConfig_LabelsEntry_DoNotUse& other);
  static const ContainerConfig_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerConfig_LabelsEntry_DoNotUse*>(&_ContainerConfig_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerConfig_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerConfig_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerConfig_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerConfig_AnnotationsEntry_DoNotUse();
  ContainerConfig_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerConfig_AnnotationsEntry_DoNotUse& other);
  static const ContainerConfig_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerConfig_AnnotationsEntry_DoNotUse*>(&_ContainerConfig_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerConfig) */ {
 public:
  ContainerConfig();
  virtual ~ContainerConfig();

  ContainerConfig(const ContainerConfig& from);

  inline ContainerConfig& operator=(const ContainerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerConfig(ContainerConfig&& from) noexcept
    : ContainerConfig() {
    *this = ::std::move(from);
  }

  inline ContainerConfig& operator=(ContainerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerConfig* internal_default_instance() {
    return reinterpret_cast<const ContainerConfig*>(
               &_ContainerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(ContainerConfig* other);
  friend void swap(ContainerConfig& a, ContainerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerConfig& from);
  void MergeFrom(const ContainerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated string command = 3;
  int command_size() const;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  const ::std::string& command(int index) const;
  ::std::string* mutable_command(int index);
  void set_command(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_command(int index, ::std::string&& value);
  #endif
  void set_command(int index, const char* value);
  void set_command(int index, const char* value, size_t size);
  ::std::string* add_command();
  void add_command(const ::std::string& value);
  #if LANG_CXX11
  void add_command(::std::string&& value);
  #endif
  void add_command(const char* value);
  void add_command(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& command() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_command();

  // repeated string args = 4;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 4;
  const ::std::string& args(int index) const;
  ::std::string* mutable_args(int index);
  void set_args(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_args(int index, ::std::string&& value);
  #endif
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  ::std::string* add_args();
  void add_args(const ::std::string& value);
  #if LANG_CXX11
  void add_args(::std::string&& value);
  #endif
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // repeated .runtime.KeyValue envs = 6;
  int envs_size() const;
  void clear_envs();
  static const int kEnvsFieldNumber = 6;
  const ::runtime::KeyValue& envs(int index) const;
  ::runtime::KeyValue* mutable_envs(int index);
  ::runtime::KeyValue* add_envs();
  ::google::protobuf::RepeatedPtrField< ::runtime::KeyValue >*
      mutable_envs();
  const ::google::protobuf::RepeatedPtrField< ::runtime::KeyValue >&
      envs() const;

  // repeated .runtime.Mount mounts = 7;
  int mounts_size() const;
  void clear_mounts();
  static const int kMountsFieldNumber = 7;
  const ::runtime::Mount& mounts(int index) const;
  ::runtime::Mount* mutable_mounts(int index);
  ::runtime::Mount* add_mounts();
  ::google::protobuf::RepeatedPtrField< ::runtime::Mount >*
      mutable_mounts();
  const ::google::protobuf::RepeatedPtrField< ::runtime::Mount >&
      mounts() const;

  // repeated .runtime.Device devices = 8;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 8;
  const ::runtime::Device& devices(int index) const;
  ::runtime::Device* mutable_devices(int index);
  ::runtime::Device* add_devices();
  ::google::protobuf::RepeatedPtrField< ::runtime::Device >*
      mutable_devices();
  const ::google::protobuf::RepeatedPtrField< ::runtime::Device >&
      devices() const;

  // map<string, string> labels = 9;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 9;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 10;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 10;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string working_dir = 5;
  void clear_working_dir();
  static const int kWorkingDirFieldNumber = 5;
  const ::std::string& working_dir() const;
  void set_working_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_working_dir(::std::string&& value);
  #endif
  void set_working_dir(const char* value);
  void set_working_dir(const char* value, size_t size);
  ::std::string* mutable_working_dir();
  ::std::string* release_working_dir();
  void set_allocated_working_dir(::std::string* working_dir);

  // string log_path = 11;
  void clear_log_path();
  static const int kLogPathFieldNumber = 11;
  const ::std::string& log_path() const;
  void set_log_path(const ::std::string& value);
  #if LANG_CXX11
  void set_log_path(::std::string&& value);
  #endif
  void set_log_path(const char* value);
  void set_log_path(const char* value, size_t size);
  ::std::string* mutable_log_path();
  ::std::string* release_log_path();
  void set_allocated_log_path(::std::string* log_path);

  // .runtime.ContainerMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::runtime::ContainerMetadata& metadata() const;
  ::runtime::ContainerMetadata* release_metadata();
  ::runtime::ContainerMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::ContainerMetadata* metadata);

  // .runtime.ImageSpec image = 2;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // .runtime.LinuxContainerConfig linux = 15;
  bool has_linux() const;
  void clear_linux();
  static const int kLinuxFieldNumber = 15;
  const ::runtime::LinuxContainerConfig& linux() const;
  ::runtime::LinuxContainerConfig* release_linux();
  ::runtime::LinuxContainerConfig* mutable_linux();
  void set_allocated_linux(::runtime::LinuxContainerConfig* linux);

  // bool stdin = 12;
  void clear_stdin();
  static const int kStdinFieldNumber = 12;
  bool stdin() const;
  void set_stdin(bool value);

  // bool stdin_once = 13;
  void clear_stdin_once();
  static const int kStdinOnceFieldNumber = 13;
  bool stdin_once() const;
  void set_stdin_once(bool value);

  // bool tty = 14;
  void clear_tty();
  static const int kTtyFieldNumber = 14;
  bool tty() const;
  void set_tty(bool value);

  // @@protoc_insertion_point(class_scope:runtime.ContainerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> command_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::RepeatedPtrField< ::runtime::KeyValue > envs_;
  ::google::protobuf::RepeatedPtrField< ::runtime::Mount > mounts_;
  ::google::protobuf::RepeatedPtrField< ::runtime::Device > devices_;
  ::google::protobuf::internal::MapField<
      ContainerConfig_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      ContainerConfig_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr working_dir_;
  ::google::protobuf::internal::ArenaStringPtr log_path_;
  ::runtime::ContainerMetadata* metadata_;
  ::runtime::ImageSpec* image_;
  ::runtime::LinuxContainerConfig* linux_;
  bool stdin_;
  bool stdin_once_;
  bool tty_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerConfigImpl();
};
// -------------------------------------------------------------------

class CreateContainerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.CreateContainerRequest) */ {
 public:
  CreateContainerRequest();
  virtual ~CreateContainerRequest();

  CreateContainerRequest(const CreateContainerRequest& from);

  inline CreateContainerRequest& operator=(const CreateContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateContainerRequest(CreateContainerRequest&& from) noexcept
    : CreateContainerRequest() {
    *this = ::std::move(from);
  }

  inline CreateContainerRequest& operator=(CreateContainerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateContainerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateContainerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateContainerRequest*>(
               &_CreateContainerRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(CreateContainerRequest* other);
  friend void swap(CreateContainerRequest& a, CreateContainerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateContainerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateContainerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateContainerRequest& from);
  void MergeFrom(const CreateContainerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateContainerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // .runtime.ContainerConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::runtime::ContainerConfig& config() const;
  ::runtime::ContainerConfig* release_config();
  ::runtime::ContainerConfig* mutable_config();
  void set_allocated_config(::runtime::ContainerConfig* config);

  // .runtime.PodSandboxConfig sandbox_config = 3;
  bool has_sandbox_config() const;
  void clear_sandbox_config();
  static const int kSandboxConfigFieldNumber = 3;
  const ::runtime::PodSandboxConfig& sandbox_config() const;
  ::runtime::PodSandboxConfig* release_sandbox_config();
  ::runtime::PodSandboxConfig* mutable_sandbox_config();
  void set_allocated_sandbox_config(::runtime::PodSandboxConfig* sandbox_config);

  // @@protoc_insertion_point(class_scope:runtime.CreateContainerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  ::runtime::ContainerConfig* config_;
  ::runtime::PodSandboxConfig* sandbox_config_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsCreateContainerRequestImpl();
};
// -------------------------------------------------------------------

class CreateContainerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.CreateContainerResponse) */ {
 public:
  CreateContainerResponse();
  virtual ~CreateContainerResponse();

  CreateContainerResponse(const CreateContainerResponse& from);

  inline CreateContainerResponse& operator=(const CreateContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateContainerResponse(CreateContainerResponse&& from) noexcept
    : CreateContainerResponse() {
    *this = ::std::move(from);
  }

  inline CreateContainerResponse& operator=(CreateContainerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateContainerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateContainerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateContainerResponse*>(
               &_CreateContainerResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(CreateContainerResponse* other);
  friend void swap(CreateContainerResponse& a, CreateContainerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateContainerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateContainerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateContainerResponse& from);
  void MergeFrom(const CreateContainerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateContainerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:runtime.CreateContainerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsCreateContainerResponseImpl();
};
// -------------------------------------------------------------------

class StartContainerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StartContainerRequest) */ {
 public:
  StartContainerRequest();
  virtual ~StartContainerRequest();

  StartContainerRequest(const StartContainerRequest& from);

  inline StartContainerRequest& operator=(const StartContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartContainerRequest(StartContainerRequest&& from) noexcept
    : StartContainerRequest() {
    *this = ::std::move(from);
  }

  inline StartContainerRequest& operator=(StartContainerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartContainerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartContainerRequest* internal_default_instance() {
    return reinterpret_cast<const StartContainerRequest*>(
               &_StartContainerRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(StartContainerRequest* other);
  friend void swap(StartContainerRequest& a, StartContainerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartContainerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StartContainerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartContainerRequest& from);
  void MergeFrom(const StartContainerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartContainerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:runtime.StartContainerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStartContainerRequestImpl();
};
// -------------------------------------------------------------------

class StartContainerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StartContainerResponse) */ {
 public:
  StartContainerResponse();
  virtual ~StartContainerResponse();

  StartContainerResponse(const StartContainerResponse& from);

  inline StartContainerResponse& operator=(const StartContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartContainerResponse(StartContainerResponse&& from) noexcept
    : StartContainerResponse() {
    *this = ::std::move(from);
  }

  inline StartContainerResponse& operator=(StartContainerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartContainerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartContainerResponse* internal_default_instance() {
    return reinterpret_cast<const StartContainerResponse*>(
               &_StartContainerResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(StartContainerResponse* other);
  friend void swap(StartContainerResponse& a, StartContainerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartContainerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StartContainerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartContainerResponse& from);
  void MergeFrom(const StartContainerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartContainerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.StartContainerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStartContainerResponseImpl();
};
// -------------------------------------------------------------------

class StopContainerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StopContainerRequest) */ {
 public:
  StopContainerRequest();
  virtual ~StopContainerRequest();

  StopContainerRequest(const StopContainerRequest& from);

  inline StopContainerRequest& operator=(const StopContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopContainerRequest(StopContainerRequest&& from) noexcept
    : StopContainerRequest() {
    *this = ::std::move(from);
  }

  inline StopContainerRequest& operator=(StopContainerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopContainerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopContainerRequest* internal_default_instance() {
    return reinterpret_cast<const StopContainerRequest*>(
               &_StopContainerRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(StopContainerRequest* other);
  friend void swap(StopContainerRequest& a, StopContainerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopContainerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StopContainerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopContainerRequest& from);
  void MergeFrom(const StopContainerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopContainerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // int64 timeout = 2;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  ::google::protobuf::int64 timeout() const;
  void set_timeout(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.StopContainerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  ::google::protobuf::int64 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStopContainerRequestImpl();
};
// -------------------------------------------------------------------

class StopContainerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StopContainerResponse) */ {
 public:
  StopContainerResponse();
  virtual ~StopContainerResponse();

  StopContainerResponse(const StopContainerResponse& from);

  inline StopContainerResponse& operator=(const StopContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopContainerResponse(StopContainerResponse&& from) noexcept
    : StopContainerResponse() {
    *this = ::std::move(from);
  }

  inline StopContainerResponse& operator=(StopContainerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopContainerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopContainerResponse* internal_default_instance() {
    return reinterpret_cast<const StopContainerResponse*>(
               &_StopContainerResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(StopContainerResponse* other);
  friend void swap(StopContainerResponse& a, StopContainerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopContainerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StopContainerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopContainerResponse& from);
  void MergeFrom(const StopContainerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopContainerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.StopContainerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStopContainerResponseImpl();
};
// -------------------------------------------------------------------

class RemoveContainerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemoveContainerRequest) */ {
 public:
  RemoveContainerRequest();
  virtual ~RemoveContainerRequest();

  RemoveContainerRequest(const RemoveContainerRequest& from);

  inline RemoveContainerRequest& operator=(const RemoveContainerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveContainerRequest(RemoveContainerRequest&& from) noexcept
    : RemoveContainerRequest() {
    *this = ::std::move(from);
  }

  inline RemoveContainerRequest& operator=(RemoveContainerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveContainerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveContainerRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveContainerRequest*>(
               &_RemoveContainerRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(RemoveContainerRequest* other);
  friend void swap(RemoveContainerRequest& a, RemoveContainerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveContainerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveContainerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveContainerRequest& from);
  void MergeFrom(const RemoveContainerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveContainerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:runtime.RemoveContainerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemoveContainerRequestImpl();
};
// -------------------------------------------------------------------

class RemoveContainerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemoveContainerResponse) */ {
 public:
  RemoveContainerResponse();
  virtual ~RemoveContainerResponse();

  RemoveContainerResponse(const RemoveContainerResponse& from);

  inline RemoveContainerResponse& operator=(const RemoveContainerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveContainerResponse(RemoveContainerResponse&& from) noexcept
    : RemoveContainerResponse() {
    *this = ::std::move(from);
  }

  inline RemoveContainerResponse& operator=(RemoveContainerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveContainerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveContainerResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveContainerResponse*>(
               &_RemoveContainerResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(RemoveContainerResponse* other);
  friend void swap(RemoveContainerResponse& a, RemoveContainerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveContainerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveContainerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveContainerResponse& from);
  void MergeFrom(const RemoveContainerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveContainerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.RemoveContainerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemoveContainerResponseImpl();
};
// -------------------------------------------------------------------

class ContainerStateValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStateValue) */ {
 public:
  ContainerStateValue();
  virtual ~ContainerStateValue();

  ContainerStateValue(const ContainerStateValue& from);

  inline ContainerStateValue& operator=(const ContainerStateValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStateValue(ContainerStateValue&& from) noexcept
    : ContainerStateValue() {
    *this = ::std::move(from);
  }

  inline ContainerStateValue& operator=(ContainerStateValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStateValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStateValue* internal_default_instance() {
    return reinterpret_cast<const ContainerStateValue*>(
               &_ContainerStateValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(ContainerStateValue* other);
  friend void swap(ContainerStateValue& a, ContainerStateValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStateValue* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStateValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStateValue& from);
  void MergeFrom(const ContainerStateValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStateValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ContainerState state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::runtime::ContainerState state() const;
  void set_state(::runtime::ContainerState value);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStateValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStateValueImpl();
};
// -------------------------------------------------------------------

class ContainerFilter_LabelSelectorEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerFilter_LabelSelectorEntry_DoNotUse();
  ContainerFilter_LabelSelectorEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerFilter_LabelSelectorEntry_DoNotUse& other);
  static const ContainerFilter_LabelSelectorEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerFilter_LabelSelectorEntry_DoNotUse*>(&_ContainerFilter_LabelSelectorEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerFilter) */ {
 public:
  ContainerFilter();
  virtual ~ContainerFilter();

  ContainerFilter(const ContainerFilter& from);

  inline ContainerFilter& operator=(const ContainerFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerFilter(ContainerFilter&& from) noexcept
    : ContainerFilter() {
    *this = ::std::move(from);
  }

  inline ContainerFilter& operator=(ContainerFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerFilter* internal_default_instance() {
    return reinterpret_cast<const ContainerFilter*>(
               &_ContainerFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(ContainerFilter* other);
  friend void swap(ContainerFilter& a, ContainerFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerFilter& from);
  void MergeFrom(const ContainerFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> label_selector = 4;
  int label_selector_size() const;
  void clear_label_selector();
  static const int kLabelSelectorFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      label_selector() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_label_selector();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string pod_sandbox_id = 3;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 3;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // .runtime.ContainerStateValue state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::runtime::ContainerStateValue& state() const;
  ::runtime::ContainerStateValue* release_state();
  ::runtime::ContainerStateValue* mutable_state();
  void set_allocated_state(::runtime::ContainerStateValue* state);

  // @@protoc_insertion_point(class_scope:runtime.ContainerFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ContainerFilter_LabelSelectorEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > label_selector_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  ::runtime::ContainerStateValue* state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerFilterImpl();
};
// -------------------------------------------------------------------

class ListContainersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListContainersRequest) */ {
 public:
  ListContainersRequest();
  virtual ~ListContainersRequest();

  ListContainersRequest(const ListContainersRequest& from);

  inline ListContainersRequest& operator=(const ListContainersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListContainersRequest(ListContainersRequest&& from) noexcept
    : ListContainersRequest() {
    *this = ::std::move(from);
  }

  inline ListContainersRequest& operator=(ListContainersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListContainersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListContainersRequest* internal_default_instance() {
    return reinterpret_cast<const ListContainersRequest*>(
               &_ListContainersRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(ListContainersRequest* other);
  friend void swap(ListContainersRequest& a, ListContainersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListContainersRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListContainersRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListContainersRequest& from);
  void MergeFrom(const ListContainersRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListContainersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ContainerFilter filter = 1;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::runtime::ContainerFilter& filter() const;
  ::runtime::ContainerFilter* release_filter();
  ::runtime::ContainerFilter* mutable_filter();
  void set_allocated_filter(::runtime::ContainerFilter* filter);

  // @@protoc_insertion_point(class_scope:runtime.ListContainersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ContainerFilter* filter_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListContainersRequestImpl();
};
// -------------------------------------------------------------------

class Container_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Container_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Container_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Container_LabelsEntry_DoNotUse();
  Container_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Container_LabelsEntry_DoNotUse& other);
  static const Container_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Container_LabelsEntry_DoNotUse*>(&_Container_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Container_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Container_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Container_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Container_AnnotationsEntry_DoNotUse();
  Container_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Container_AnnotationsEntry_DoNotUse& other);
  static const Container_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Container_AnnotationsEntry_DoNotUse*>(&_Container_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const PROTOBUF_FINAL { return New(NULL); }

  Container* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 8;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 8;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 9;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 9;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string pod_sandbox_id = 2;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 2;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // string image_ref = 5;
  void clear_image_ref();
  static const int kImageRefFieldNumber = 5;
  const ::std::string& image_ref() const;
  void set_image_ref(const ::std::string& value);
  #if LANG_CXX11
  void set_image_ref(::std::string&& value);
  #endif
  void set_image_ref(const char* value);
  void set_image_ref(const char* value, size_t size);
  ::std::string* mutable_image_ref();
  ::std::string* release_image_ref();
  void set_allocated_image_ref(::std::string* image_ref);

  // .runtime.ContainerMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::runtime::ContainerMetadata& metadata() const;
  ::runtime::ContainerMetadata* release_metadata();
  ::runtime::ContainerMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::ContainerMetadata* metadata);

  // .runtime.ImageSpec image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // int64 created_at = 7;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 7;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // .runtime.ContainerState state = 6;
  void clear_state();
  static const int kStateFieldNumber = 6;
  ::runtime::ContainerState state() const;
  void set_state(::runtime::ContainerState value);

  // @@protoc_insertion_point(class_scope:runtime.Container)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Container_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      Container_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  ::google::protobuf::internal::ArenaStringPtr image_ref_;
  ::runtime::ContainerMetadata* metadata_;
  ::runtime::ImageSpec* image_;
  ::google::protobuf::int64 created_at_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerImpl();
};
// -------------------------------------------------------------------

class ListContainersResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListContainersResponse) */ {
 public:
  ListContainersResponse();
  virtual ~ListContainersResponse();

  ListContainersResponse(const ListContainersResponse& from);

  inline ListContainersResponse& operator=(const ListContainersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListContainersResponse(ListContainersResponse&& from) noexcept
    : ListContainersResponse() {
    *this = ::std::move(from);
  }

  inline ListContainersResponse& operator=(ListContainersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListContainersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListContainersResponse* internal_default_instance() {
    return reinterpret_cast<const ListContainersResponse*>(
               &_ListContainersResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(ListContainersResponse* other);
  friend void swap(ListContainersResponse& a, ListContainersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListContainersResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ListContainersResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListContainersResponse& from);
  void MergeFrom(const ListContainersResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListContainersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.Container containers = 1;
  int containers_size() const;
  void clear_containers();
  static const int kContainersFieldNumber = 1;
  const ::runtime::Container& containers(int index) const;
  ::runtime::Container* mutable_containers(int index);
  ::runtime::Container* add_containers();
  ::google::protobuf::RepeatedPtrField< ::runtime::Container >*
      mutable_containers();
  const ::google::protobuf::RepeatedPtrField< ::runtime::Container >&
      containers() const;

  // @@protoc_insertion_point(class_scope:runtime.ListContainersResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::Container > containers_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListContainersResponseImpl();
};
// -------------------------------------------------------------------

class ContainerStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatusRequest) */ {
 public:
  ContainerStatusRequest();
  virtual ~ContainerStatusRequest();

  ContainerStatusRequest(const ContainerStatusRequest& from);

  inline ContainerStatusRequest& operator=(const ContainerStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatusRequest(ContainerStatusRequest&& from) noexcept
    : ContainerStatusRequest() {
    *this = ::std::move(from);
  }

  inline ContainerStatusRequest& operator=(ContainerStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ContainerStatusRequest*>(
               &_ContainerStatusRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(ContainerStatusRequest* other);
  friend void swap(ContainerStatusRequest& a, ContainerStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatusRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatusRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatusRequest& from);
  void MergeFrom(const ContainerStatusRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // bool verbose = 2;
  void clear_verbose();
  static const int kVerboseFieldNumber = 2;
  bool verbose() const;
  void set_verbose(bool value);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  bool verbose_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatusRequestImpl();
};
// -------------------------------------------------------------------

class ContainerStatus_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerStatus_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerStatus_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerStatus_LabelsEntry_DoNotUse();
  ContainerStatus_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerStatus_LabelsEntry_DoNotUse& other);
  static const ContainerStatus_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerStatus_LabelsEntry_DoNotUse*>(&_ContainerStatus_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerStatus_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerStatus_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerStatus_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerStatus_AnnotationsEntry_DoNotUse();
  ContainerStatus_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerStatus_AnnotationsEntry_DoNotUse& other);
  static const ContainerStatus_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerStatus_AnnotationsEntry_DoNotUse*>(&_ContainerStatus_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatus) */ {
 public:
  ContainerStatus();
  virtual ~ContainerStatus();

  ContainerStatus(const ContainerStatus& from);

  inline ContainerStatus& operator=(const ContainerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatus(ContainerStatus&& from) noexcept
    : ContainerStatus() {
    *this = ::std::move(from);
  }

  inline ContainerStatus& operator=(ContainerStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatus* internal_default_instance() {
    return reinterpret_cast<const ContainerStatus*>(
               &_ContainerStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(ContainerStatus* other);
  friend void swap(ContainerStatus& a, ContainerStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatus& from);
  void MergeFrom(const ContainerStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 12;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 12;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 13;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 13;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // repeated .runtime.Mount mounts = 14;
  int mounts_size() const;
  void clear_mounts();
  static const int kMountsFieldNumber = 14;
  const ::runtime::Mount& mounts(int index) const;
  ::runtime::Mount* mutable_mounts(int index);
  ::runtime::Mount* add_mounts();
  ::google::protobuf::RepeatedPtrField< ::runtime::Mount >*
      mutable_mounts();
  const ::google::protobuf::RepeatedPtrField< ::runtime::Mount >&
      mounts() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string image_ref = 9;
  void clear_image_ref();
  static const int kImageRefFieldNumber = 9;
  const ::std::string& image_ref() const;
  void set_image_ref(const ::std::string& value);
  #if LANG_CXX11
  void set_image_ref(::std::string&& value);
  #endif
  void set_image_ref(const char* value);
  void set_image_ref(const char* value, size_t size);
  ::std::string* mutable_image_ref();
  ::std::string* release_image_ref();
  void set_allocated_image_ref(::std::string* image_ref);

  // string reason = 10;
  void clear_reason();
  static const int kReasonFieldNumber = 10;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // string message = 11;
  void clear_message();
  static const int kMessageFieldNumber = 11;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // string log_path = 15;
  void clear_log_path();
  static const int kLogPathFieldNumber = 15;
  const ::std::string& log_path() const;
  void set_log_path(const ::std::string& value);
  #if LANG_CXX11
  void set_log_path(::std::string&& value);
  #endif
  void set_log_path(const char* value);
  void set_log_path(const char* value, size_t size);
  ::std::string* mutable_log_path();
  ::std::string* release_log_path();
  void set_allocated_log_path(::std::string* log_path);

  // .runtime.ContainerMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::runtime::ContainerMetadata& metadata() const;
  ::runtime::ContainerMetadata* release_metadata();
  ::runtime::ContainerMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::ContainerMetadata* metadata);

  // .runtime.ImageSpec image = 8;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 8;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // int64 created_at = 4;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 4;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // int64 started_at = 5;
  void clear_started_at();
  static const int kStartedAtFieldNumber = 5;
  ::google::protobuf::int64 started_at() const;
  void set_started_at(::google::protobuf::int64 value);

  // .runtime.ContainerState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::runtime::ContainerState state() const;
  void set_state(::runtime::ContainerState value);

  // int32 exit_code = 7;
  void clear_exit_code();
  static const int kExitCodeFieldNumber = 7;
  ::google::protobuf::int32 exit_code() const;
  void set_exit_code(::google::protobuf::int32 value);

  // int64 finished_at = 6;
  void clear_finished_at();
  static const int kFinishedAtFieldNumber = 6;
  ::google::protobuf::int64 finished_at() const;
  void set_finished_at(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ContainerStatus_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      ContainerStatus_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::RepeatedPtrField< ::runtime::Mount > mounts_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr image_ref_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr log_path_;
  ::runtime::ContainerMetadata* metadata_;
  ::runtime::ImageSpec* image_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 started_at_;
  int state_;
  ::google::protobuf::int32 exit_code_;
  ::google::protobuf::int64 finished_at_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatusImpl();
};
// -------------------------------------------------------------------

class ContainerStatusResponse_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerStatusResponse_InfoEntry_DoNotUse();
  ContainerStatusResponse_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerStatusResponse_InfoEntry_DoNotUse& other);
  static const ContainerStatusResponse_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerStatusResponse_InfoEntry_DoNotUse*>(&_ContainerStatusResponse_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatusResponse) */ {
 public:
  ContainerStatusResponse();
  virtual ~ContainerStatusResponse();

  ContainerStatusResponse(const ContainerStatusResponse& from);

  inline ContainerStatusResponse& operator=(const ContainerStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatusResponse(ContainerStatusResponse&& from) noexcept
    : ContainerStatusResponse() {
    *this = ::std::move(from);
  }

  inline ContainerStatusResponse& operator=(ContainerStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ContainerStatusResponse*>(
               &_ContainerStatusResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(ContainerStatusResponse* other);
  friend void swap(ContainerStatusResponse& a, ContainerStatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatusResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatusResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatusResponse& from);
  void MergeFrom(const ContainerStatusResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 2;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // .runtime.ContainerStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::runtime::ContainerStatus& status() const;
  ::runtime::ContainerStatus* release_status();
  ::runtime::ContainerStatus* mutable_status();
  void set_allocated_status(::runtime::ContainerStatus* status);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ContainerStatusResponse_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::runtime::ContainerStatus* status_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatusResponseImpl();
};
// -------------------------------------------------------------------

class UpdateContainerResourcesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.UpdateContainerResourcesRequest) */ {
 public:
  UpdateContainerResourcesRequest();
  virtual ~UpdateContainerResourcesRequest();

  UpdateContainerResourcesRequest(const UpdateContainerResourcesRequest& from);

  inline UpdateContainerResourcesRequest& operator=(const UpdateContainerResourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateContainerResourcesRequest(UpdateContainerResourcesRequest&& from) noexcept
    : UpdateContainerResourcesRequest() {
    *this = ::std::move(from);
  }

  inline UpdateContainerResourcesRequest& operator=(UpdateContainerResourcesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateContainerResourcesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateContainerResourcesRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerResourcesRequest*>(
               &_UpdateContainerResourcesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(UpdateContainerResourcesRequest* other);
  friend void swap(UpdateContainerResourcesRequest& a, UpdateContainerResourcesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateContainerResourcesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateContainerResourcesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateContainerResourcesRequest& from);
  void MergeFrom(const UpdateContainerResourcesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateContainerResourcesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // .runtime.LinuxContainerResources linux = 2;
  bool has_linux() const;
  void clear_linux();
  static const int kLinuxFieldNumber = 2;
  const ::runtime::LinuxContainerResources& linux() const;
  ::runtime::LinuxContainerResources* release_linux();
  ::runtime::LinuxContainerResources* mutable_linux();
  void set_allocated_linux(::runtime::LinuxContainerResources* linux);

  // @@protoc_insertion_point(class_scope:runtime.UpdateContainerResourcesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  ::runtime::LinuxContainerResources* linux_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsUpdateContainerResourcesRequestImpl();
};
// -------------------------------------------------------------------

class UpdateContainerResourcesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.UpdateContainerResourcesResponse) */ {
 public:
  UpdateContainerResourcesResponse();
  virtual ~UpdateContainerResourcesResponse();

  UpdateContainerResourcesResponse(const UpdateContainerResourcesResponse& from);

  inline UpdateContainerResourcesResponse& operator=(const UpdateContainerResourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateContainerResourcesResponse(UpdateContainerResourcesResponse&& from) noexcept
    : UpdateContainerResourcesResponse() {
    *this = ::std::move(from);
  }

  inline UpdateContainerResourcesResponse& operator=(UpdateContainerResourcesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateContainerResourcesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateContainerResourcesResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateContainerResourcesResponse*>(
               &_UpdateContainerResourcesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(UpdateContainerResourcesResponse* other);
  friend void swap(UpdateContainerResourcesResponse& a, UpdateContainerResourcesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateContainerResourcesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateContainerResourcesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateContainerResourcesResponse& from);
  void MergeFrom(const UpdateContainerResourcesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateContainerResourcesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.UpdateContainerResourcesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsUpdateContainerResourcesResponseImpl();
};
// -------------------------------------------------------------------

class ExecSyncRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ExecSyncRequest) */ {
 public:
  ExecSyncRequest();
  virtual ~ExecSyncRequest();

  ExecSyncRequest(const ExecSyncRequest& from);

  inline ExecSyncRequest& operator=(const ExecSyncRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecSyncRequest(ExecSyncRequest&& from) noexcept
    : ExecSyncRequest() {
    *this = ::std::move(from);
  }

  inline ExecSyncRequest& operator=(ExecSyncRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecSyncRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecSyncRequest* internal_default_instance() {
    return reinterpret_cast<const ExecSyncRequest*>(
               &_ExecSyncRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void Swap(ExecSyncRequest* other);
  friend void swap(ExecSyncRequest& a, ExecSyncRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecSyncRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecSyncRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecSyncRequest& from);
  void MergeFrom(const ExecSyncRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecSyncRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string cmd = 2;
  int cmd_size() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  const ::std::string& cmd(int index) const;
  ::std::string* mutable_cmd(int index);
  void set_cmd(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_cmd(int index, ::std::string&& value);
  #endif
  void set_cmd(int index, const char* value);
  void set_cmd(int index, const char* value, size_t size);
  ::std::string* add_cmd();
  void add_cmd(const ::std::string& value);
  #if LANG_CXX11
  void add_cmd(::std::string&& value);
  #endif
  void add_cmd(const char* value);
  void add_cmd(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // int64 timeout = 3;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  ::google::protobuf::int64 timeout() const;
  void set_timeout(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.ExecSyncRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  ::google::protobuf::int64 timeout_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsExecSyncRequestImpl();
};
// -------------------------------------------------------------------

class ExecSyncResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ExecSyncResponse) */ {
 public:
  ExecSyncResponse();
  virtual ~ExecSyncResponse();

  ExecSyncResponse(const ExecSyncResponse& from);

  inline ExecSyncResponse& operator=(const ExecSyncResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecSyncResponse(ExecSyncResponse&& from) noexcept
    : ExecSyncResponse() {
    *this = ::std::move(from);
  }

  inline ExecSyncResponse& operator=(ExecSyncResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecSyncResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecSyncResponse* internal_default_instance() {
    return reinterpret_cast<const ExecSyncResponse*>(
               &_ExecSyncResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(ExecSyncResponse* other);
  friend void swap(ExecSyncResponse& a, ExecSyncResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecSyncResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecSyncResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecSyncResponse& from);
  void MergeFrom(const ExecSyncResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecSyncResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes stdout = 1;
  void clear_stdout();
  static const int kStdoutFieldNumber = 1;
  const ::std::string& stdout() const;
  void set_stdout(const ::std::string& value);
  #if LANG_CXX11
  void set_stdout(::std::string&& value);
  #endif
  void set_stdout(const char* value);
  void set_stdout(const void* value, size_t size);
  ::std::string* mutable_stdout();
  ::std::string* release_stdout();
  void set_allocated_stdout(::std::string* stdout);

  // bytes stderr = 2;
  void clear_stderr();
  static const int kStderrFieldNumber = 2;
  const ::std::string& stderr() const;
  void set_stderr(const ::std::string& value);
  #if LANG_CXX11
  void set_stderr(::std::string&& value);
  #endif
  void set_stderr(const char* value);
  void set_stderr(const void* value, size_t size);
  ::std::string* mutable_stderr();
  ::std::string* release_stderr();
  void set_allocated_stderr(::std::string* stderr);

  // int32 exit_code = 3;
  void clear_exit_code();
  static const int kExitCodeFieldNumber = 3;
  ::google::protobuf::int32 exit_code() const;
  void set_exit_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:runtime.ExecSyncResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stdout_;
  ::google::protobuf::internal::ArenaStringPtr stderr_;
  ::google::protobuf::int32 exit_code_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsExecSyncResponseImpl();
};
// -------------------------------------------------------------------

class ExecRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ExecRequest) */ {
 public:
  ExecRequest();
  virtual ~ExecRequest();

  ExecRequest(const ExecRequest& from);

  inline ExecRequest& operator=(const ExecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecRequest(ExecRequest&& from) noexcept
    : ExecRequest() {
    *this = ::std::move(from);
  }

  inline ExecRequest& operator=(ExecRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecRequest* internal_default_instance() {
    return reinterpret_cast<const ExecRequest*>(
               &_ExecRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(ExecRequest* other);
  friend void swap(ExecRequest& a, ExecRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecRequest& from);
  void MergeFrom(const ExecRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string cmd = 2;
  int cmd_size() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  const ::std::string& cmd(int index) const;
  ::std::string* mutable_cmd(int index);
  void set_cmd(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_cmd(int index, ::std::string&& value);
  #endif
  void set_cmd(int index, const char* value);
  void set_cmd(int index, const char* value, size_t size);
  ::std::string* add_cmd();
  void add_cmd(const ::std::string& value);
  #if LANG_CXX11
  void add_cmd(::std::string&& value);
  #endif
  void add_cmd(const char* value);
  void add_cmd(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // bool tty = 3;
  void clear_tty();
  static const int kTtyFieldNumber = 3;
  bool tty() const;
  void set_tty(bool value);

  // bool stdin = 4;
  void clear_stdin();
  static const int kStdinFieldNumber = 4;
  bool stdin() const;
  void set_stdin(bool value);

  // bool stdout = 5;
  void clear_stdout();
  static const int kStdoutFieldNumber = 5;
  bool stdout() const;
  void set_stdout(bool value);

  // bool stderr = 6;
  void clear_stderr();
  static const int kStderrFieldNumber = 6;
  bool stderr() const;
  void set_stderr(bool value);

  // @@protoc_insertion_point(class_scope:runtime.ExecRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  bool tty_;
  bool stdin_;
  bool stdout_;
  bool stderr_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsExecRequestImpl();
};
// -------------------------------------------------------------------

class ExecResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ExecResponse) */ {
 public:
  ExecResponse();
  virtual ~ExecResponse();

  ExecResponse(const ExecResponse& from);

  inline ExecResponse& operator=(const ExecResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecResponse(ExecResponse&& from) noexcept
    : ExecResponse() {
    *this = ::std::move(from);
  }

  inline ExecResponse& operator=(ExecResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecResponse* internal_default_instance() {
    return reinterpret_cast<const ExecResponse*>(
               &_ExecResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(ExecResponse* other);
  friend void swap(ExecResponse& a, ExecResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecResponse& from);
  void MergeFrom(const ExecResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:runtime.ExecResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsExecResponseImpl();
};
// -------------------------------------------------------------------

class AttachRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.AttachRequest) */ {
 public:
  AttachRequest();
  virtual ~AttachRequest();

  AttachRequest(const AttachRequest& from);

  inline AttachRequest& operator=(const AttachRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttachRequest(AttachRequest&& from) noexcept
    : AttachRequest() {
    *this = ::std::move(from);
  }

  inline AttachRequest& operator=(AttachRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttachRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttachRequest* internal_default_instance() {
    return reinterpret_cast<const AttachRequest*>(
               &_AttachRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void Swap(AttachRequest* other);
  friend void swap(AttachRequest& a, AttachRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttachRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AttachRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttachRequest& from);
  void MergeFrom(const AttachRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // bool stdin = 2;
  void clear_stdin();
  static const int kStdinFieldNumber = 2;
  bool stdin() const;
  void set_stdin(bool value);

  // bool tty = 3;
  void clear_tty();
  static const int kTtyFieldNumber = 3;
  bool tty() const;
  void set_tty(bool value);

  // bool stdout = 4;
  void clear_stdout();
  static const int kStdoutFieldNumber = 4;
  bool stdout() const;
  void set_stdout(bool value);

  // bool stderr = 5;
  void clear_stderr();
  static const int kStderrFieldNumber = 5;
  bool stderr() const;
  void set_stderr(bool value);

  // @@protoc_insertion_point(class_scope:runtime.AttachRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  bool stdin_;
  bool tty_;
  bool stdout_;
  bool stderr_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsAttachRequestImpl();
};
// -------------------------------------------------------------------

class AttachResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.AttachResponse) */ {
 public:
  AttachResponse();
  virtual ~AttachResponse();

  AttachResponse(const AttachResponse& from);

  inline AttachResponse& operator=(const AttachResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttachResponse(AttachResponse&& from) noexcept
    : AttachResponse() {
    *this = ::std::move(from);
  }

  inline AttachResponse& operator=(AttachResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttachResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttachResponse* internal_default_instance() {
    return reinterpret_cast<const AttachResponse*>(
               &_AttachResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void Swap(AttachResponse* other);
  friend void swap(AttachResponse& a, AttachResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttachResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AttachResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttachResponse& from);
  void MergeFrom(const AttachResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:runtime.AttachResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsAttachResponseImpl();
};
// -------------------------------------------------------------------

class PortForwardRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PortForwardRequest) */ {
 public:
  PortForwardRequest();
  virtual ~PortForwardRequest();

  PortForwardRequest(const PortForwardRequest& from);

  inline PortForwardRequest& operator=(const PortForwardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortForwardRequest(PortForwardRequest&& from) noexcept
    : PortForwardRequest() {
    *this = ::std::move(from);
  }

  inline PortForwardRequest& operator=(PortForwardRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortForwardRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortForwardRequest* internal_default_instance() {
    return reinterpret_cast<const PortForwardRequest*>(
               &_PortForwardRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void Swap(PortForwardRequest* other);
  friend void swap(PortForwardRequest& a, PortForwardRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortForwardRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PortForwardRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PortForwardRequest& from);
  void MergeFrom(const PortForwardRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PortForwardRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 port = 2;
  int port_size() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port(int index) const;
  void set_port(int index, ::google::protobuf::int32 value);
  void add_port(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      port() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_port();

  // string pod_sandbox_id = 1;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 1;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // @@protoc_insertion_point(class_scope:runtime.PortForwardRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > port_;
  mutable int _port_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPortForwardRequestImpl();
};
// -------------------------------------------------------------------

class PortForwardResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PortForwardResponse) */ {
 public:
  PortForwardResponse();
  virtual ~PortForwardResponse();

  PortForwardResponse(const PortForwardResponse& from);

  inline PortForwardResponse& operator=(const PortForwardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortForwardResponse(PortForwardResponse&& from) noexcept
    : PortForwardResponse() {
    *this = ::std::move(from);
  }

  inline PortForwardResponse& operator=(PortForwardResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortForwardResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortForwardResponse* internal_default_instance() {
    return reinterpret_cast<const PortForwardResponse*>(
               &_PortForwardResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void Swap(PortForwardResponse* other);
  friend void swap(PortForwardResponse& a, PortForwardResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortForwardResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PortForwardResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PortForwardResponse& from);
  void MergeFrom(const PortForwardResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PortForwardResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:runtime.PortForwardResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPortForwardResponseImpl();
};
// -------------------------------------------------------------------

class ImageFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageFilter) */ {
 public:
  ImageFilter();
  virtual ~ImageFilter();

  ImageFilter(const ImageFilter& from);

  inline ImageFilter& operator=(const ImageFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFilter(ImageFilter&& from) noexcept
    : ImageFilter() {
    *this = ::std::move(from);
  }

  inline ImageFilter& operator=(ImageFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFilter* internal_default_instance() {
    return reinterpret_cast<const ImageFilter*>(
               &_ImageFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void Swap(ImageFilter* other);
  friend void swap(ImageFilter& a, ImageFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFilter& from);
  void MergeFrom(const ImageFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ImageSpec image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // @@protoc_insertion_point(class_scope:runtime.ImageFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ImageSpec* image_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageFilterImpl();
};
// -------------------------------------------------------------------

class ListImagesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListImagesRequest) */ {
 public:
  ListImagesRequest();
  virtual ~ListImagesRequest();

  ListImagesRequest(const ListImagesRequest& from);

  inline ListImagesRequest& operator=(const ListImagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListImagesRequest(ListImagesRequest&& from) noexcept
    : ListImagesRequest() {
    *this = ::std::move(from);
  }

  inline ListImagesRequest& operator=(ListImagesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListImagesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListImagesRequest* internal_default_instance() {
    return reinterpret_cast<const ListImagesRequest*>(
               &_ListImagesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void Swap(ListImagesRequest* other);
  friend void swap(ListImagesRequest& a, ListImagesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListImagesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListImagesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListImagesRequest& from);
  void MergeFrom(const ListImagesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListImagesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ImageFilter filter = 1;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::runtime::ImageFilter& filter() const;
  ::runtime::ImageFilter* release_filter();
  ::runtime::ImageFilter* mutable_filter();
  void set_allocated_filter(::runtime::ImageFilter* filter);

  // @@protoc_insertion_point(class_scope:runtime.ListImagesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ImageFilter* filter_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListImagesRequestImpl();
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string repo_tags = 2;
  int repo_tags_size() const;
  void clear_repo_tags();
  static const int kRepoTagsFieldNumber = 2;
  const ::std::string& repo_tags(int index) const;
  ::std::string* mutable_repo_tags(int index);
  void set_repo_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_repo_tags(int index, ::std::string&& value);
  #endif
  void set_repo_tags(int index, const char* value);
  void set_repo_tags(int index, const char* value, size_t size);
  ::std::string* add_repo_tags();
  void add_repo_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_repo_tags(::std::string&& value);
  #endif
  void add_repo_tags(const char* value);
  void add_repo_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& repo_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_repo_tags();

  // repeated string repo_digests = 3;
  int repo_digests_size() const;
  void clear_repo_digests();
  static const int kRepoDigestsFieldNumber = 3;
  const ::std::string& repo_digests(int index) const;
  ::std::string* mutable_repo_digests(int index);
  void set_repo_digests(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_repo_digests(int index, ::std::string&& value);
  #endif
  void set_repo_digests(int index, const char* value);
  void set_repo_digests(int index, const char* value, size_t size);
  ::std::string* add_repo_digests();
  void add_repo_digests(const ::std::string& value);
  #if LANG_CXX11
  void add_repo_digests(::std::string&& value);
  #endif
  void add_repo_digests(const char* value);
  void add_repo_digests(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& repo_digests() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_repo_digests();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string username = 6;
  void clear_username();
  static const int kUsernameFieldNumber = 6;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .runtime.Int64Value uid = 5;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 5;
  const ::runtime::Int64Value& uid() const;
  ::runtime::Int64Value* release_uid();
  ::runtime::Int64Value* mutable_uid();
  void set_allocated_uid(::runtime::Int64Value* uid);

  // uint64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:runtime.Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> repo_tags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> repo_digests_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::runtime::Int64Value* uid_;
  ::google::protobuf::uint64 size_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageImpl();
};
// -------------------------------------------------------------------

class ListImagesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListImagesResponse) */ {
 public:
  ListImagesResponse();
  virtual ~ListImagesResponse();

  ListImagesResponse(const ListImagesResponse& from);

  inline ListImagesResponse& operator=(const ListImagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListImagesResponse(ListImagesResponse&& from) noexcept
    : ListImagesResponse() {
    *this = ::std::move(from);
  }

  inline ListImagesResponse& operator=(ListImagesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListImagesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListImagesResponse* internal_default_instance() {
    return reinterpret_cast<const ListImagesResponse*>(
               &_ListImagesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void Swap(ListImagesResponse* other);
  friend void swap(ListImagesResponse& a, ListImagesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListImagesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ListImagesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListImagesResponse& from);
  void MergeFrom(const ListImagesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListImagesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.Image images = 1;
  int images_size() const;
  void clear_images();
  static const int kImagesFieldNumber = 1;
  const ::runtime::Image& images(int index) const;
  ::runtime::Image* mutable_images(int index);
  ::runtime::Image* add_images();
  ::google::protobuf::RepeatedPtrField< ::runtime::Image >*
      mutable_images();
  const ::google::protobuf::RepeatedPtrField< ::runtime::Image >&
      images() const;

  // @@protoc_insertion_point(class_scope:runtime.ListImagesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::Image > images_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListImagesResponseImpl();
};
// -------------------------------------------------------------------

class ImageStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageStatusRequest) */ {
 public:
  ImageStatusRequest();
  virtual ~ImageStatusRequest();

  ImageStatusRequest(const ImageStatusRequest& from);

  inline ImageStatusRequest& operator=(const ImageStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageStatusRequest(ImageStatusRequest&& from) noexcept
    : ImageStatusRequest() {
    *this = ::std::move(from);
  }

  inline ImageStatusRequest& operator=(ImageStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ImageStatusRequest*>(
               &_ImageStatusRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void Swap(ImageStatusRequest* other);
  friend void swap(ImageStatusRequest& a, ImageStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageStatusRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageStatusRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageStatusRequest& from);
  void MergeFrom(const ImageStatusRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ImageSpec image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // bool verbose = 2;
  void clear_verbose();
  static const int kVerboseFieldNumber = 2;
  bool verbose() const;
  void set_verbose(bool value);

  // @@protoc_insertion_point(class_scope:runtime.ImageStatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ImageSpec* image_;
  bool verbose_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageStatusRequestImpl();
};
// -------------------------------------------------------------------

class ImageStatusResponse_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ImageStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ImageStatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ImageStatusResponse_InfoEntry_DoNotUse();
  ImageStatusResponse_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ImageStatusResponse_InfoEntry_DoNotUse& other);
  static const ImageStatusResponse_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ImageStatusResponse_InfoEntry_DoNotUse*>(&_ImageStatusResponse_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ImageStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageStatusResponse) */ {
 public:
  ImageStatusResponse();
  virtual ~ImageStatusResponse();

  ImageStatusResponse(const ImageStatusResponse& from);

  inline ImageStatusResponse& operator=(const ImageStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageStatusResponse(ImageStatusResponse&& from) noexcept
    : ImageStatusResponse() {
    *this = ::std::move(from);
  }

  inline ImageStatusResponse& operator=(ImageStatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ImageStatusResponse*>(
               &_ImageStatusResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void Swap(ImageStatusResponse* other);
  friend void swap(ImageStatusResponse& a, ImageStatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageStatusResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageStatusResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageStatusResponse& from);
  void MergeFrom(const ImageStatusResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 2;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // .runtime.Image image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::runtime::Image& image() const;
  ::runtime::Image* release_image();
  ::runtime::Image* mutable_image();
  void set_allocated_image(::runtime::Image* image);

  // @@protoc_insertion_point(class_scope:runtime.ImageStatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ImageStatusResponse_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::runtime::Image* image_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageStatusResponseImpl();
};
// -------------------------------------------------------------------

class AuthConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.AuthConfig) */ {
 public:
  AuthConfig();
  virtual ~AuthConfig();

  AuthConfig(const AuthConfig& from);

  inline AuthConfig& operator=(const AuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthConfig(AuthConfig&& from) noexcept
    : AuthConfig() {
    *this = ::std::move(from);
  }

  inline AuthConfig& operator=(AuthConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthConfig* internal_default_instance() {
    return reinterpret_cast<const AuthConfig*>(
               &_AuthConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void Swap(AuthConfig* other);
  friend void swap(AuthConfig& a, AuthConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthConfig& from);
  void MergeFrom(const AuthConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string auth = 3;
  void clear_auth();
  static const int kAuthFieldNumber = 3;
  const ::std::string& auth() const;
  void set_auth(const ::std::string& value);
  #if LANG_CXX11
  void set_auth(::std::string&& value);
  #endif
  void set_auth(const char* value);
  void set_auth(const char* value, size_t size);
  ::std::string* mutable_auth();
  ::std::string* release_auth();
  void set_allocated_auth(::std::string* auth);

  // string server_address = 4;
  void clear_server_address();
  static const int kServerAddressFieldNumber = 4;
  const ::std::string& server_address() const;
  void set_server_address(const ::std::string& value);
  #if LANG_CXX11
  void set_server_address(::std::string&& value);
  #endif
  void set_server_address(const char* value);
  void set_server_address(const char* value, size_t size);
  ::std::string* mutable_server_address();
  ::std::string* release_server_address();
  void set_allocated_server_address(::std::string* server_address);

  // string identity_token = 5;
  void clear_identity_token();
  static const int kIdentityTokenFieldNumber = 5;
  const ::std::string& identity_token() const;
  void set_identity_token(const ::std::string& value);
  #if LANG_CXX11
  void set_identity_token(::std::string&& value);
  #endif
  void set_identity_token(const char* value);
  void set_identity_token(const char* value, size_t size);
  ::std::string* mutable_identity_token();
  ::std::string* release_identity_token();
  void set_allocated_identity_token(::std::string* identity_token);

  // string registry_token = 6;
  void clear_registry_token();
  static const int kRegistryTokenFieldNumber = 6;
  const ::std::string& registry_token() const;
  void set_registry_token(const ::std::string& value);
  #if LANG_CXX11
  void set_registry_token(::std::string&& value);
  #endif
  void set_registry_token(const char* value);
  void set_registry_token(const char* value, size_t size);
  ::std::string* mutable_registry_token();
  ::std::string* release_registry_token();
  void set_allocated_registry_token(::std::string* registry_token);

  // @@protoc_insertion_point(class_scope:runtime.AuthConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr auth_;
  ::google::protobuf::internal::ArenaStringPtr server_address_;
  ::google::protobuf::internal::ArenaStringPtr identity_token_;
  ::google::protobuf::internal::ArenaStringPtr registry_token_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsAuthConfigImpl();
};
// -------------------------------------------------------------------

class PullImageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PullImageRequest) */ {
 public:
  PullImageRequest();
  virtual ~PullImageRequest();

  PullImageRequest(const PullImageRequest& from);

  inline PullImageRequest& operator=(const PullImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullImageRequest(PullImageRequest&& from) noexcept
    : PullImageRequest() {
    *this = ::std::move(from);
  }

  inline PullImageRequest& operator=(PullImageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullImageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullImageRequest* internal_default_instance() {
    return reinterpret_cast<const PullImageRequest*>(
               &_PullImageRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    89;

  void Swap(PullImageRequest* other);
  friend void swap(PullImageRequest& a, PullImageRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullImageRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PullImageRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PullImageRequest& from);
  void MergeFrom(const PullImageRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PullImageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ImageSpec image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // .runtime.AuthConfig auth = 2;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  const ::runtime::AuthConfig& auth() const;
  ::runtime::AuthConfig* release_auth();
  ::runtime::AuthConfig* mutable_auth();
  void set_allocated_auth(::runtime::AuthConfig* auth);

  // .runtime.PodSandboxConfig sandbox_config = 3;
  bool has_sandbox_config() const;
  void clear_sandbox_config();
  static const int kSandboxConfigFieldNumber = 3;
  const ::runtime::PodSandboxConfig& sandbox_config() const;
  ::runtime::PodSandboxConfig* release_sandbox_config();
  ::runtime::PodSandboxConfig* mutable_sandbox_config();
  void set_allocated_sandbox_config(::runtime::PodSandboxConfig* sandbox_config);

  // @@protoc_insertion_point(class_scope:runtime.PullImageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ImageSpec* image_;
  ::runtime::AuthConfig* auth_;
  ::runtime::PodSandboxConfig* sandbox_config_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPullImageRequestImpl();
};
// -------------------------------------------------------------------

class PullImageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.PullImageResponse) */ {
 public:
  PullImageResponse();
  virtual ~PullImageResponse();

  PullImageResponse(const PullImageResponse& from);

  inline PullImageResponse& operator=(const PullImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PullImageResponse(PullImageResponse&& from) noexcept
    : PullImageResponse() {
    *this = ::std::move(from);
  }

  inline PullImageResponse& operator=(PullImageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullImageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullImageResponse* internal_default_instance() {
    return reinterpret_cast<const PullImageResponse*>(
               &_PullImageResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void Swap(PullImageResponse* other);
  friend void swap(PullImageResponse& a, PullImageResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PullImageResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PullImageResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PullImageResponse& from);
  void MergeFrom(const PullImageResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PullImageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string image_ref = 1;
  void clear_image_ref();
  static const int kImageRefFieldNumber = 1;
  const ::std::string& image_ref() const;
  void set_image_ref(const ::std::string& value);
  #if LANG_CXX11
  void set_image_ref(::std::string&& value);
  #endif
  void set_image_ref(const char* value);
  void set_image_ref(const char* value, size_t size);
  ::std::string* mutable_image_ref();
  ::std::string* release_image_ref();
  void set_allocated_image_ref(::std::string* image_ref);

  // @@protoc_insertion_point(class_scope:runtime.PullImageResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr image_ref_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsPullImageResponseImpl();
};
// -------------------------------------------------------------------

class RemoveImageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemoveImageRequest) */ {
 public:
  RemoveImageRequest();
  virtual ~RemoveImageRequest();

  RemoveImageRequest(const RemoveImageRequest& from);

  inline RemoveImageRequest& operator=(const RemoveImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveImageRequest(RemoveImageRequest&& from) noexcept
    : RemoveImageRequest() {
    *this = ::std::move(from);
  }

  inline RemoveImageRequest& operator=(RemoveImageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveImageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveImageRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveImageRequest*>(
               &_RemoveImageRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void Swap(RemoveImageRequest* other);
  friend void swap(RemoveImageRequest& a, RemoveImageRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveImageRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveImageRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveImageRequest& from);
  void MergeFrom(const RemoveImageRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveImageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ImageSpec image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::runtime::ImageSpec& image() const;
  ::runtime::ImageSpec* release_image();
  ::runtime::ImageSpec* mutable_image();
  void set_allocated_image(::runtime::ImageSpec* image);

  // @@protoc_insertion_point(class_scope:runtime.RemoveImageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ImageSpec* image_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemoveImageRequestImpl();
};
// -------------------------------------------------------------------

class RemoveImageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RemoveImageResponse) */ {
 public:
  RemoveImageResponse();
  virtual ~RemoveImageResponse();

  RemoveImageResponse(const RemoveImageResponse& from);

  inline RemoveImageResponse& operator=(const RemoveImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveImageResponse(RemoveImageResponse&& from) noexcept
    : RemoveImageResponse() {
    *this = ::std::move(from);
  }

  inline RemoveImageResponse& operator=(RemoveImageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveImageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveImageResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveImageResponse*>(
               &_RemoveImageResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    92;

  void Swap(RemoveImageResponse* other);
  friend void swap(RemoveImageResponse& a, RemoveImageResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveImageResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveImageResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveImageResponse& from);
  void MergeFrom(const RemoveImageResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveImageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.RemoveImageResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRemoveImageResponseImpl();
};
// -------------------------------------------------------------------

class NetworkConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.NetworkConfig) */ {
 public:
  NetworkConfig();
  virtual ~NetworkConfig();

  NetworkConfig(const NetworkConfig& from);

  inline NetworkConfig& operator=(const NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkConfig(NetworkConfig&& from) noexcept
    : NetworkConfig() {
    *this = ::std::move(from);
  }

  inline NetworkConfig& operator=(NetworkConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkConfig* internal_default_instance() {
    return reinterpret_cast<const NetworkConfig*>(
               &_NetworkConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void Swap(NetworkConfig* other);
  friend void swap(NetworkConfig& a, NetworkConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkConfig& from);
  void MergeFrom(const NetworkConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pod_cidr = 1;
  void clear_pod_cidr();
  static const int kPodCidrFieldNumber = 1;
  const ::std::string& pod_cidr() const;
  void set_pod_cidr(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_cidr(::std::string&& value);
  #endif
  void set_pod_cidr(const char* value);
  void set_pod_cidr(const char* value, size_t size);
  ::std::string* mutable_pod_cidr();
  ::std::string* release_pod_cidr();
  void set_allocated_pod_cidr(::std::string* pod_cidr);

  // @@protoc_insertion_point(class_scope:runtime.NetworkConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pod_cidr_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsNetworkConfigImpl();
};
// -------------------------------------------------------------------

class RuntimeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RuntimeConfig) */ {
 public:
  RuntimeConfig();
  virtual ~RuntimeConfig();

  RuntimeConfig(const RuntimeConfig& from);

  inline RuntimeConfig& operator=(const RuntimeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeConfig(RuntimeConfig&& from) noexcept
    : RuntimeConfig() {
    *this = ::std::move(from);
  }

  inline RuntimeConfig& operator=(RuntimeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeConfig* internal_default_instance() {
    return reinterpret_cast<const RuntimeConfig*>(
               &_RuntimeConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    94;

  void Swap(RuntimeConfig* other);
  friend void swap(RuntimeConfig& a, RuntimeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeConfig& from);
  void MergeFrom(const RuntimeConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.NetworkConfig network_config = 1;
  bool has_network_config() const;
  void clear_network_config();
  static const int kNetworkConfigFieldNumber = 1;
  const ::runtime::NetworkConfig& network_config() const;
  ::runtime::NetworkConfig* release_network_config();
  ::runtime::NetworkConfig* mutable_network_config();
  void set_allocated_network_config(::runtime::NetworkConfig* network_config);

  // @@protoc_insertion_point(class_scope:runtime.RuntimeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::NetworkConfig* network_config_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRuntimeConfigImpl();
};
// -------------------------------------------------------------------

class UpdateRuntimeConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.UpdateRuntimeConfigRequest) */ {
 public:
  UpdateRuntimeConfigRequest();
  virtual ~UpdateRuntimeConfigRequest();

  UpdateRuntimeConfigRequest(const UpdateRuntimeConfigRequest& from);

  inline UpdateRuntimeConfigRequest& operator=(const UpdateRuntimeConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRuntimeConfigRequest(UpdateRuntimeConfigRequest&& from) noexcept
    : UpdateRuntimeConfigRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRuntimeConfigRequest& operator=(UpdateRuntimeConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRuntimeConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRuntimeConfigRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRuntimeConfigRequest*>(
               &_UpdateRuntimeConfigRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    95;

  void Swap(UpdateRuntimeConfigRequest* other);
  friend void swap(UpdateRuntimeConfigRequest& a, UpdateRuntimeConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRuntimeConfigRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateRuntimeConfigRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateRuntimeConfigRequest& from);
  void MergeFrom(const UpdateRuntimeConfigRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateRuntimeConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.RuntimeConfig runtime_config = 1;
  bool has_runtime_config() const;
  void clear_runtime_config();
  static const int kRuntimeConfigFieldNumber = 1;
  const ::runtime::RuntimeConfig& runtime_config() const;
  ::runtime::RuntimeConfig* release_runtime_config();
  ::runtime::RuntimeConfig* mutable_runtime_config();
  void set_allocated_runtime_config(::runtime::RuntimeConfig* runtime_config);

  // @@protoc_insertion_point(class_scope:runtime.UpdateRuntimeConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::RuntimeConfig* runtime_config_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsUpdateRuntimeConfigRequestImpl();
};
// -------------------------------------------------------------------

class UpdateRuntimeConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.UpdateRuntimeConfigResponse) */ {
 public:
  UpdateRuntimeConfigResponse();
  virtual ~UpdateRuntimeConfigResponse();

  UpdateRuntimeConfigResponse(const UpdateRuntimeConfigResponse& from);

  inline UpdateRuntimeConfigResponse& operator=(const UpdateRuntimeConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRuntimeConfigResponse(UpdateRuntimeConfigResponse&& from) noexcept
    : UpdateRuntimeConfigResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRuntimeConfigResponse& operator=(UpdateRuntimeConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRuntimeConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRuntimeConfigResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRuntimeConfigResponse*>(
               &_UpdateRuntimeConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    96;

  void Swap(UpdateRuntimeConfigResponse* other);
  friend void swap(UpdateRuntimeConfigResponse& a, UpdateRuntimeConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRuntimeConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateRuntimeConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateRuntimeConfigResponse& from);
  void MergeFrom(const UpdateRuntimeConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateRuntimeConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.UpdateRuntimeConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsUpdateRuntimeConfigResponseImpl();
};
// -------------------------------------------------------------------

class RuntimeCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RuntimeCondition) */ {
 public:
  RuntimeCondition();
  virtual ~RuntimeCondition();

  RuntimeCondition(const RuntimeCondition& from);

  inline RuntimeCondition& operator=(const RuntimeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeCondition(RuntimeCondition&& from) noexcept
    : RuntimeCondition() {
    *this = ::std::move(from);
  }

  inline RuntimeCondition& operator=(RuntimeCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeCondition* internal_default_instance() {
    return reinterpret_cast<const RuntimeCondition*>(
               &_RuntimeCondition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    97;

  void Swap(RuntimeCondition* other);
  friend void swap(RuntimeCondition& a, RuntimeCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeCondition* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeCondition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeCondition& from);
  void MergeFrom(const RuntimeCondition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string reason = 3;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // string message = 4;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:runtime.RuntimeCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool status_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRuntimeConditionImpl();
};
// -------------------------------------------------------------------

class RuntimeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.RuntimeStatus) */ {
 public:
  RuntimeStatus();
  virtual ~RuntimeStatus();

  RuntimeStatus(const RuntimeStatus& from);

  inline RuntimeStatus& operator=(const RuntimeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeStatus(RuntimeStatus&& from) noexcept
    : RuntimeStatus() {
    *this = ::std::move(from);
  }

  inline RuntimeStatus& operator=(RuntimeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeStatus* internal_default_instance() {
    return reinterpret_cast<const RuntimeStatus*>(
               &_RuntimeStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    98;

  void Swap(RuntimeStatus* other);
  friend void swap(RuntimeStatus& a, RuntimeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeStatus& from);
  void MergeFrom(const RuntimeStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.RuntimeCondition conditions = 1;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 1;
  const ::runtime::RuntimeCondition& conditions(int index) const;
  ::runtime::RuntimeCondition* mutable_conditions(int index);
  ::runtime::RuntimeCondition* add_conditions();
  ::google::protobuf::RepeatedPtrField< ::runtime::RuntimeCondition >*
      mutable_conditions();
  const ::google::protobuf::RepeatedPtrField< ::runtime::RuntimeCondition >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:runtime.RuntimeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::RuntimeCondition > conditions_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsRuntimeStatusImpl();
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StatusRequest) */ {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    99;

  void Swap(StatusRequest* other);
  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool verbose = 1;
  void clear_verbose();
  static const int kVerboseFieldNumber = 1;
  bool verbose() const;
  void set_verbose(bool value);

  // @@protoc_insertion_point(class_scope:runtime.StatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool verbose_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStatusRequestImpl();
};
// -------------------------------------------------------------------

class StatusResponse_InfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StatusResponse_InfoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StatusResponse_InfoEntry_DoNotUse();
  StatusResponse_InfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StatusResponse_InfoEntry_DoNotUse& other);
  static const StatusResponse_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StatusResponse_InfoEntry_DoNotUse*>(&_StatusResponse_InfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    101;

  void Swap(StatusResponse* other);
  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> info = 2;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_info();

  // .runtime.RuntimeStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::runtime::RuntimeStatus& status() const;
  ::runtime::RuntimeStatus* release_status();
  ::runtime::RuntimeStatus* mutable_status();
  void set_allocated_status(::runtime::RuntimeStatus* status);

  // @@protoc_insertion_point(class_scope:runtime.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StatusResponse_InfoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > info_;
  ::runtime::RuntimeStatus* status_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStatusResponseImpl();
};
// -------------------------------------------------------------------

class ImageFsInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageFsInfoRequest) */ {
 public:
  ImageFsInfoRequest();
  virtual ~ImageFsInfoRequest();

  ImageFsInfoRequest(const ImageFsInfoRequest& from);

  inline ImageFsInfoRequest& operator=(const ImageFsInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFsInfoRequest(ImageFsInfoRequest&& from) noexcept
    : ImageFsInfoRequest() {
    *this = ::std::move(from);
  }

  inline ImageFsInfoRequest& operator=(ImageFsInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFsInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFsInfoRequest* internal_default_instance() {
    return reinterpret_cast<const ImageFsInfoRequest*>(
               &_ImageFsInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    102;

  void Swap(ImageFsInfoRequest* other);
  friend void swap(ImageFsInfoRequest& a, ImageFsInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFsInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFsInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFsInfoRequest& from);
  void MergeFrom(const ImageFsInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFsInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:runtime.ImageFsInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageFsInfoRequestImpl();
};
// -------------------------------------------------------------------

class UInt64Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.UInt64Value) */ {
 public:
  UInt64Value();
  virtual ~UInt64Value();

  UInt64Value(const UInt64Value& from);

  inline UInt64Value& operator=(const UInt64Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt64Value(UInt64Value&& from) noexcept
    : UInt64Value() {
    *this = ::std::move(from);
  }

  inline UInt64Value& operator=(UInt64Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt64Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt64Value* internal_default_instance() {
    return reinterpret_cast<const UInt64Value*>(
               &_UInt64Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    103;

  void Swap(UInt64Value* other);
  friend void swap(UInt64Value& a, UInt64Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt64Value* New() const PROTOBUF_FINAL { return New(NULL); }

  UInt64Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UInt64Value& from);
  void MergeFrom(const UInt64Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UInt64Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:runtime.UInt64Value)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsUInt64ValueImpl();
};
// -------------------------------------------------------------------

class StorageIdentifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.StorageIdentifier) */ {
 public:
  StorageIdentifier();
  virtual ~StorageIdentifier();

  StorageIdentifier(const StorageIdentifier& from);

  inline StorageIdentifier& operator=(const StorageIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageIdentifier(StorageIdentifier&& from) noexcept
    : StorageIdentifier() {
    *this = ::std::move(from);
  }

  inline StorageIdentifier& operator=(StorageIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageIdentifier* internal_default_instance() {
    return reinterpret_cast<const StorageIdentifier*>(
               &_StorageIdentifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    104;

  void Swap(StorageIdentifier* other);
  friend void swap(StorageIdentifier& a, StorageIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageIdentifier* New() const PROTOBUF_FINAL { return New(NULL); }

  StorageIdentifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StorageIdentifier& from);
  void MergeFrom(const StorageIdentifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StorageIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:runtime.StorageIdentifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsStorageIdentifierImpl();
};
// -------------------------------------------------------------------

class FilesystemUsage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.FilesystemUsage) */ {
 public:
  FilesystemUsage();
  virtual ~FilesystemUsage();

  FilesystemUsage(const FilesystemUsage& from);

  inline FilesystemUsage& operator=(const FilesystemUsage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilesystemUsage(FilesystemUsage&& from) noexcept
    : FilesystemUsage() {
    *this = ::std::move(from);
  }

  inline FilesystemUsage& operator=(FilesystemUsage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FilesystemUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilesystemUsage* internal_default_instance() {
    return reinterpret_cast<const FilesystemUsage*>(
               &_FilesystemUsage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    105;

  void Swap(FilesystemUsage* other);
  friend void swap(FilesystemUsage& a, FilesystemUsage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilesystemUsage* New() const PROTOBUF_FINAL { return New(NULL); }

  FilesystemUsage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FilesystemUsage& from);
  void MergeFrom(const FilesystemUsage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FilesystemUsage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.StorageIdentifier storage_id = 2;
  bool has_storage_id() const;
  void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  const ::runtime::StorageIdentifier& storage_id() const;
  ::runtime::StorageIdentifier* release_storage_id();
  ::runtime::StorageIdentifier* mutable_storage_id();
  void set_allocated_storage_id(::runtime::StorageIdentifier* storage_id);

  // .runtime.UInt64Value used_bytes = 3;
  bool has_used_bytes() const;
  void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 3;
  const ::runtime::UInt64Value& used_bytes() const;
  ::runtime::UInt64Value* release_used_bytes();
  ::runtime::UInt64Value* mutable_used_bytes();
  void set_allocated_used_bytes(::runtime::UInt64Value* used_bytes);

  // .runtime.UInt64Value inodes_used = 4;
  bool has_inodes_used() const;
  void clear_inodes_used();
  static const int kInodesUsedFieldNumber = 4;
  const ::runtime::UInt64Value& inodes_used() const;
  ::runtime::UInt64Value* release_inodes_used();
  ::runtime::UInt64Value* mutable_inodes_used();
  void set_allocated_inodes_used(::runtime::UInt64Value* inodes_used);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.FilesystemUsage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::StorageIdentifier* storage_id_;
  ::runtime::UInt64Value* used_bytes_;
  ::runtime::UInt64Value* inodes_used_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsFilesystemUsageImpl();
};
// -------------------------------------------------------------------

class ImageFsInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ImageFsInfoResponse) */ {
 public:
  ImageFsInfoResponse();
  virtual ~ImageFsInfoResponse();

  ImageFsInfoResponse(const ImageFsInfoResponse& from);

  inline ImageFsInfoResponse& operator=(const ImageFsInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFsInfoResponse(ImageFsInfoResponse&& from) noexcept
    : ImageFsInfoResponse() {
    *this = ::std::move(from);
  }

  inline ImageFsInfoResponse& operator=(ImageFsInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFsInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFsInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ImageFsInfoResponse*>(
               &_ImageFsInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    106;

  void Swap(ImageFsInfoResponse* other);
  friend void swap(ImageFsInfoResponse& a, ImageFsInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFsInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFsInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFsInfoResponse& from);
  void MergeFrom(const ImageFsInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFsInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.FilesystemUsage image_filesystems = 1;
  int image_filesystems_size() const;
  void clear_image_filesystems();
  static const int kImageFilesystemsFieldNumber = 1;
  const ::runtime::FilesystemUsage& image_filesystems(int index) const;
  ::runtime::FilesystemUsage* mutable_image_filesystems(int index);
  ::runtime::FilesystemUsage* add_image_filesystems();
  ::google::protobuf::RepeatedPtrField< ::runtime::FilesystemUsage >*
      mutable_image_filesystems();
  const ::google::protobuf::RepeatedPtrField< ::runtime::FilesystemUsage >&
      image_filesystems() const;

  // @@protoc_insertion_point(class_scope:runtime.ImageFsInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::FilesystemUsage > image_filesystems_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsImageFsInfoResponseImpl();
};
// -------------------------------------------------------------------

class ContainerStatsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatsRequest) */ {
 public:
  ContainerStatsRequest();
  virtual ~ContainerStatsRequest();

  ContainerStatsRequest(const ContainerStatsRequest& from);

  inline ContainerStatsRequest& operator=(const ContainerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatsRequest(ContainerStatsRequest&& from) noexcept
    : ContainerStatsRequest() {
    *this = ::std::move(from);
  }

  inline ContainerStatsRequest& operator=(ContainerStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const ContainerStatsRequest*>(
               &_ContainerStatsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    107;

  void Swap(ContainerStatsRequest* other);
  friend void swap(ContainerStatsRequest& a, ContainerStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatsRequest& from);
  void MergeFrom(const ContainerStatsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string container_id = 1;
  void clear_container_id();
  static const int kContainerIdFieldNumber = 1;
  const ::std::string& container_id() const;
  void set_container_id(const ::std::string& value);
  #if LANG_CXX11
  void set_container_id(::std::string&& value);
  #endif
  void set_container_id(const char* value);
  void set_container_id(const char* value, size_t size);
  ::std::string* mutable_container_id();
  ::std::string* release_container_id();
  void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr container_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatsRequestImpl();
};
// -------------------------------------------------------------------

class ContainerStatsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatsResponse) */ {
 public:
  ContainerStatsResponse();
  virtual ~ContainerStatsResponse();

  ContainerStatsResponse(const ContainerStatsResponse& from);

  inline ContainerStatsResponse& operator=(const ContainerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatsResponse(ContainerStatsResponse&& from) noexcept
    : ContainerStatsResponse() {
    *this = ::std::move(from);
  }

  inline ContainerStatsResponse& operator=(ContainerStatsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const ContainerStatsResponse*>(
               &_ContainerStatsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    108;

  void Swap(ContainerStatsResponse* other);
  friend void swap(ContainerStatsResponse& a, ContainerStatsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatsResponse& from);
  void MergeFrom(const ContainerStatsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ContainerStats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::runtime::ContainerStats& stats() const;
  ::runtime::ContainerStats* release_stats();
  ::runtime::ContainerStats* mutable_stats();
  void set_allocated_stats(::runtime::ContainerStats* stats);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ContainerStats* stats_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatsResponseImpl();
};
// -------------------------------------------------------------------

class ListContainerStatsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListContainerStatsRequest) */ {
 public:
  ListContainerStatsRequest();
  virtual ~ListContainerStatsRequest();

  ListContainerStatsRequest(const ListContainerStatsRequest& from);

  inline ListContainerStatsRequest& operator=(const ListContainerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListContainerStatsRequest(ListContainerStatsRequest&& from) noexcept
    : ListContainerStatsRequest() {
    *this = ::std::move(from);
  }

  inline ListContainerStatsRequest& operator=(ListContainerStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListContainerStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListContainerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const ListContainerStatsRequest*>(
               &_ListContainerStatsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    109;

  void Swap(ListContainerStatsRequest* other);
  friend void swap(ListContainerStatsRequest& a, ListContainerStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListContainerStatsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ListContainerStatsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListContainerStatsRequest& from);
  void MergeFrom(const ListContainerStatsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListContainerStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ContainerStatsFilter filter = 1;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::runtime::ContainerStatsFilter& filter() const;
  ::runtime::ContainerStatsFilter* release_filter();
  ::runtime::ContainerStatsFilter* mutable_filter();
  void set_allocated_filter(::runtime::ContainerStatsFilter* filter);

  // @@protoc_insertion_point(class_scope:runtime.ListContainerStatsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ContainerStatsFilter* filter_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListContainerStatsRequestImpl();
};
// -------------------------------------------------------------------

class ContainerStatsFilter_LabelSelectorEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerStatsFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerStatsFilter_LabelSelectorEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerStatsFilter_LabelSelectorEntry_DoNotUse();
  ContainerStatsFilter_LabelSelectorEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerStatsFilter_LabelSelectorEntry_DoNotUse& other);
  static const ContainerStatsFilter_LabelSelectorEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerStatsFilter_LabelSelectorEntry_DoNotUse*>(&_ContainerStatsFilter_LabelSelectorEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerStatsFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStatsFilter) */ {
 public:
  ContainerStatsFilter();
  virtual ~ContainerStatsFilter();

  ContainerStatsFilter(const ContainerStatsFilter& from);

  inline ContainerStatsFilter& operator=(const ContainerStatsFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStatsFilter(ContainerStatsFilter&& from) noexcept
    : ContainerStatsFilter() {
    *this = ::std::move(from);
  }

  inline ContainerStatsFilter& operator=(ContainerStatsFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatsFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStatsFilter* internal_default_instance() {
    return reinterpret_cast<const ContainerStatsFilter*>(
               &_ContainerStatsFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    111;

  void Swap(ContainerStatsFilter* other);
  friend void swap(ContainerStatsFilter& a, ContainerStatsFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStatsFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStatsFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStatsFilter& from);
  void MergeFrom(const ContainerStatsFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStatsFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> label_selector = 3;
  int label_selector_size() const;
  void clear_label_selector();
  static const int kLabelSelectorFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      label_selector() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_label_selector();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string pod_sandbox_id = 2;
  void clear_pod_sandbox_id();
  static const int kPodSandboxIdFieldNumber = 2;
  const ::std::string& pod_sandbox_id() const;
  void set_pod_sandbox_id(const ::std::string& value);
  #if LANG_CXX11
  void set_pod_sandbox_id(::std::string&& value);
  #endif
  void set_pod_sandbox_id(const char* value);
  void set_pod_sandbox_id(const char* value, size_t size);
  ::std::string* mutable_pod_sandbox_id();
  ::std::string* release_pod_sandbox_id();
  void set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStatsFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ContainerStatsFilter_LabelSelectorEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > label_selector_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr pod_sandbox_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatsFilterImpl();
};
// -------------------------------------------------------------------

class ListContainerStatsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ListContainerStatsResponse) */ {
 public:
  ListContainerStatsResponse();
  virtual ~ListContainerStatsResponse();

  ListContainerStatsResponse(const ListContainerStatsResponse& from);

  inline ListContainerStatsResponse& operator=(const ListContainerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListContainerStatsResponse(ListContainerStatsResponse&& from) noexcept
    : ListContainerStatsResponse() {
    *this = ::std::move(from);
  }

  inline ListContainerStatsResponse& operator=(ListContainerStatsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListContainerStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListContainerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const ListContainerStatsResponse*>(
               &_ListContainerStatsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    112;

  void Swap(ListContainerStatsResponse* other);
  friend void swap(ListContainerStatsResponse& a, ListContainerStatsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListContainerStatsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ListContainerStatsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListContainerStatsResponse& from);
  void MergeFrom(const ListContainerStatsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListContainerStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .runtime.ContainerStats stats = 1;
  int stats_size() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::runtime::ContainerStats& stats(int index) const;
  ::runtime::ContainerStats* mutable_stats(int index);
  ::runtime::ContainerStats* add_stats();
  ::google::protobuf::RepeatedPtrField< ::runtime::ContainerStats >*
      mutable_stats();
  const ::google::protobuf::RepeatedPtrField< ::runtime::ContainerStats >&
      stats() const;

  // @@protoc_insertion_point(class_scope:runtime.ListContainerStatsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::runtime::ContainerStats > stats_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsListContainerStatsResponseImpl();
};
// -------------------------------------------------------------------

class ContainerAttributes_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerAttributes_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerAttributes_LabelsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerAttributes_LabelsEntry_DoNotUse();
  ContainerAttributes_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerAttributes_LabelsEntry_DoNotUse& other);
  static const ContainerAttributes_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerAttributes_LabelsEntry_DoNotUse*>(&_ContainerAttributes_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerAttributes_AnnotationsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ContainerAttributes_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ContainerAttributes_AnnotationsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ContainerAttributes_AnnotationsEntry_DoNotUse();
  ContainerAttributes_AnnotationsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ContainerAttributes_AnnotationsEntry_DoNotUse& other);
  static const ContainerAttributes_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContainerAttributes_AnnotationsEntry_DoNotUse*>(&_ContainerAttributes_AnnotationsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ContainerAttributes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerAttributes) */ {
 public:
  ContainerAttributes();
  virtual ~ContainerAttributes();

  ContainerAttributes(const ContainerAttributes& from);

  inline ContainerAttributes& operator=(const ContainerAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerAttributes(ContainerAttributes&& from) noexcept
    : ContainerAttributes() {
    *this = ::std::move(from);
  }

  inline ContainerAttributes& operator=(ContainerAttributes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerAttributes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerAttributes* internal_default_instance() {
    return reinterpret_cast<const ContainerAttributes*>(
               &_ContainerAttributes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    115;

  void Swap(ContainerAttributes* other);
  friend void swap(ContainerAttributes& a, ContainerAttributes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerAttributes* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerAttributes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerAttributes& from);
  void MergeFrom(const ContainerAttributes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerAttributes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> labels = 3;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_labels();

  // map<string, string> annotations = 4;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      annotations() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_annotations();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .runtime.ContainerMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::runtime::ContainerMetadata& metadata() const;
  ::runtime::ContainerMetadata* release_metadata();
  ::runtime::ContainerMetadata* mutable_metadata();
  void set_allocated_metadata(::runtime::ContainerMetadata* metadata);

  // @@protoc_insertion_point(class_scope:runtime.ContainerAttributes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ContainerAttributes_LabelsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > labels_;
  ::google::protobuf::internal::MapField<
      ContainerAttributes_AnnotationsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > annotations_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::runtime::ContainerMetadata* metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerAttributesImpl();
};
// -------------------------------------------------------------------

class ContainerStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.ContainerStats) */ {
 public:
  ContainerStats();
  virtual ~ContainerStats();

  ContainerStats(const ContainerStats& from);

  inline ContainerStats& operator=(const ContainerStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContainerStats(ContainerStats&& from) noexcept
    : ContainerStats() {
    *this = ::std::move(from);
  }

  inline ContainerStats& operator=(ContainerStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContainerStats* internal_default_instance() {
    return reinterpret_cast<const ContainerStats*>(
               &_ContainerStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    116;

  void Swap(ContainerStats* other);
  friend void swap(ContainerStats& a, ContainerStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContainerStats* New() const PROTOBUF_FINAL { return New(NULL); }

  ContainerStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContainerStats& from);
  void MergeFrom(const ContainerStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContainerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.ContainerAttributes attributes = 1;
  bool has_attributes() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 1;
  const ::runtime::ContainerAttributes& attributes() const;
  ::runtime::ContainerAttributes* release_attributes();
  ::runtime::ContainerAttributes* mutable_attributes();
  void set_allocated_attributes(::runtime::ContainerAttributes* attributes);

  // .runtime.CpuUsage cpu = 2;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 2;
  const ::runtime::CpuUsage& cpu() const;
  ::runtime::CpuUsage* release_cpu();
  ::runtime::CpuUsage* mutable_cpu();
  void set_allocated_cpu(::runtime::CpuUsage* cpu);

  // .runtime.MemoryUsage memory = 3;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 3;
  const ::runtime::MemoryUsage& memory() const;
  ::runtime::MemoryUsage* release_memory();
  ::runtime::MemoryUsage* mutable_memory();
  void set_allocated_memory(::runtime::MemoryUsage* memory);

  // .runtime.FilesystemUsage writable_layer = 4;
  bool has_writable_layer() const;
  void clear_writable_layer();
  static const int kWritableLayerFieldNumber = 4;
  const ::runtime::FilesystemUsage& writable_layer() const;
  ::runtime::FilesystemUsage* release_writable_layer();
  ::runtime::FilesystemUsage* mutable_writable_layer();
  void set_allocated_writable_layer(::runtime::FilesystemUsage* writable_layer);

  // @@protoc_insertion_point(class_scope:runtime.ContainerStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::ContainerAttributes* attributes_;
  ::runtime::CpuUsage* cpu_;
  ::runtime::MemoryUsage* memory_;
  ::runtime::FilesystemUsage* writable_layer_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsContainerStatsImpl();
};
// -------------------------------------------------------------------

class CpuUsage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.CpuUsage) */ {
 public:
  CpuUsage();
  virtual ~CpuUsage();

  CpuUsage(const CpuUsage& from);

  inline CpuUsage& operator=(const CpuUsage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CpuUsage(CpuUsage&& from) noexcept
    : CpuUsage() {
    *this = ::std::move(from);
  }

  inline CpuUsage& operator=(CpuUsage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CpuUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CpuUsage* internal_default_instance() {
    return reinterpret_cast<const CpuUsage*>(
               &_CpuUsage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    117;

  void Swap(CpuUsage* other);
  friend void swap(CpuUsage& a, CpuUsage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CpuUsage* New() const PROTOBUF_FINAL { return New(NULL); }

  CpuUsage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CpuUsage& from);
  void MergeFrom(const CpuUsage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CpuUsage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.UInt64Value usage_core_nano_seconds = 2;
  bool has_usage_core_nano_seconds() const;
  void clear_usage_core_nano_seconds();
  static const int kUsageCoreNanoSecondsFieldNumber = 2;
  const ::runtime::UInt64Value& usage_core_nano_seconds() const;
  ::runtime::UInt64Value* release_usage_core_nano_seconds();
  ::runtime::UInt64Value* mutable_usage_core_nano_seconds();
  void set_allocated_usage_core_nano_seconds(::runtime::UInt64Value* usage_core_nano_seconds);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.CpuUsage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::UInt64Value* usage_core_nano_seconds_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsCpuUsageImpl();
};
// -------------------------------------------------------------------

class MemoryUsage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:runtime.MemoryUsage) */ {
 public:
  MemoryUsage();
  virtual ~MemoryUsage();

  MemoryUsage(const MemoryUsage& from);

  inline MemoryUsage& operator=(const MemoryUsage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemoryUsage(MemoryUsage&& from) noexcept
    : MemoryUsage() {
    *this = ::std::move(from);
  }

  inline MemoryUsage& operator=(MemoryUsage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoryUsage* internal_default_instance() {
    return reinterpret_cast<const MemoryUsage*>(
               &_MemoryUsage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    118;

  void Swap(MemoryUsage* other);
  friend void swap(MemoryUsage& a, MemoryUsage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoryUsage* New() const PROTOBUF_FINAL { return New(NULL); }

  MemoryUsage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MemoryUsage& from);
  void MergeFrom(const MemoryUsage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MemoryUsage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .runtime.UInt64Value working_set_bytes = 2;
  bool has_working_set_bytes() const;
  void clear_working_set_bytes();
  static const int kWorkingSetBytesFieldNumber = 2;
  const ::runtime::UInt64Value& working_set_bytes() const;
  ::runtime::UInt64Value* release_working_set_bytes();
  ::runtime::UInt64Value* mutable_working_set_bytes();
  void set_allocated_working_set_bytes(::runtime::UInt64Value* working_set_bytes);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:runtime.MemoryUsage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::runtime::UInt64Value* working_set_bytes_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_cri_2dapi_2eproto::TableStruct;
  friend void ::protobuf_cri_2dapi_2eproto::InitDefaultsMemoryUsageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionRequest

// string version = 1;
inline void VersionRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionRequest::version() const {
  // @@protoc_insertion_point(field_get:runtime.VersionRequest.version)
  return version_.GetNoArena();
}
inline void VersionRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.VersionRequest.version)
}
#if LANG_CXX11
inline void VersionRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.VersionRequest.version)
}
#endif
inline void VersionRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.VersionRequest.version)
}
inline void VersionRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.VersionRequest.version)
}
inline ::std::string* VersionRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:runtime.VersionRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionRequest::release_version() {
  // @@protoc_insertion_point(field_release:runtime.VersionRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionRequest::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:runtime.VersionRequest.version)
}

// -------------------------------------------------------------------

// VersionResponse

// string version = 1;
inline void VersionResponse::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionResponse::version() const {
  // @@protoc_insertion_point(field_get:runtime.VersionResponse.version)
  return version_.GetNoArena();
}
inline void VersionResponse::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.VersionResponse.version)
}
#if LANG_CXX11
inline void VersionResponse::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.VersionResponse.version)
}
#endif
inline void VersionResponse::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.VersionResponse.version)
}
inline void VersionResponse::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.VersionResponse.version)
}
inline ::std::string* VersionResponse::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:runtime.VersionResponse.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionResponse::release_version() {
  // @@protoc_insertion_point(field_release:runtime.VersionResponse.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionResponse::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:runtime.VersionResponse.version)
}

// string runtime_name = 2;
inline void VersionResponse::clear_runtime_name() {
  runtime_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionResponse::runtime_name() const {
  // @@protoc_insertion_point(field_get:runtime.VersionResponse.runtime_name)
  return runtime_name_.GetNoArena();
}
inline void VersionResponse::set_runtime_name(const ::std::string& value) {
  
  runtime_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.VersionResponse.runtime_name)
}
#if LANG_CXX11
inline void VersionResponse::set_runtime_name(::std::string&& value) {
  
  runtime_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.VersionResponse.runtime_name)
}
#endif
inline void VersionResponse::set_runtime_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.VersionResponse.runtime_name)
}
inline void VersionResponse::set_runtime_name(const char* value, size_t size) {
  
  runtime_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.VersionResponse.runtime_name)
}
inline ::std::string* VersionResponse::mutable_runtime_name() {
  
  // @@protoc_insertion_point(field_mutable:runtime.VersionResponse.runtime_name)
  return runtime_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionResponse::release_runtime_name() {
  // @@protoc_insertion_point(field_release:runtime.VersionResponse.runtime_name)
  
  return runtime_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionResponse::set_allocated_runtime_name(::std::string* runtime_name) {
  if (runtime_name != NULL) {
    
  } else {
    
  }
  runtime_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_name);
  // @@protoc_insertion_point(field_set_allocated:runtime.VersionResponse.runtime_name)
}

// string runtime_version = 3;
inline void VersionResponse::clear_runtime_version() {
  runtime_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionResponse::runtime_version() const {
  // @@protoc_insertion_point(field_get:runtime.VersionResponse.runtime_version)
  return runtime_version_.GetNoArena();
}
inline void VersionResponse::set_runtime_version(const ::std::string& value) {
  
  runtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.VersionResponse.runtime_version)
}
#if LANG_CXX11
inline void VersionResponse::set_runtime_version(::std::string&& value) {
  
  runtime_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.VersionResponse.runtime_version)
}
#endif
inline void VersionResponse::set_runtime_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.VersionResponse.runtime_version)
}
inline void VersionResponse::set_runtime_version(const char* value, size_t size) {
  
  runtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.VersionResponse.runtime_version)
}
inline ::std::string* VersionResponse::mutable_runtime_version() {
  
  // @@protoc_insertion_point(field_mutable:runtime.VersionResponse.runtime_version)
  return runtime_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionResponse::release_runtime_version() {
  // @@protoc_insertion_point(field_release:runtime.VersionResponse.runtime_version)
  
  return runtime_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionResponse::set_allocated_runtime_version(::std::string* runtime_version) {
  if (runtime_version != NULL) {
    
  } else {
    
  }
  runtime_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_version);
  // @@protoc_insertion_point(field_set_allocated:runtime.VersionResponse.runtime_version)
}

// string runtime_api_version = 4;
inline void VersionResponse::clear_runtime_api_version() {
  runtime_api_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VersionResponse::runtime_api_version() const {
  // @@protoc_insertion_point(field_get:runtime.VersionResponse.runtime_api_version)
  return runtime_api_version_.GetNoArena();
}
inline void VersionResponse::set_runtime_api_version(const ::std::string& value) {
  
  runtime_api_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.VersionResponse.runtime_api_version)
}
#if LANG_CXX11
inline void VersionResponse::set_runtime_api_version(::std::string&& value) {
  
  runtime_api_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.VersionResponse.runtime_api_version)
}
#endif
inline void VersionResponse::set_runtime_api_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_api_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.VersionResponse.runtime_api_version)
}
inline void VersionResponse::set_runtime_api_version(const char* value, size_t size) {
  
  runtime_api_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.VersionResponse.runtime_api_version)
}
inline ::std::string* VersionResponse::mutable_runtime_api_version() {
  
  // @@protoc_insertion_point(field_mutable:runtime.VersionResponse.runtime_api_version)
  return runtime_api_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionResponse::release_runtime_api_version() {
  // @@protoc_insertion_point(field_release:runtime.VersionResponse.runtime_api_version)
  
  return runtime_api_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionResponse::set_allocated_runtime_api_version(::std::string* runtime_api_version) {
  if (runtime_api_version != NULL) {
    
  } else {
    
  }
  runtime_api_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_api_version);
  // @@protoc_insertion_point(field_set_allocated:runtime.VersionResponse.runtime_api_version)
}

// -------------------------------------------------------------------

// DNSConfig

// repeated string servers = 1;
inline int DNSConfig::servers_size() const {
  return servers_.size();
}
inline void DNSConfig::clear_servers() {
  servers_.Clear();
}
inline const ::std::string& DNSConfig::servers(int index) const {
  // @@protoc_insertion_point(field_get:runtime.DNSConfig.servers)
  return servers_.Get(index);
}
inline ::std::string* DNSConfig::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.DNSConfig.servers)
  return servers_.Mutable(index);
}
inline void DNSConfig::set_servers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.servers)
  servers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DNSConfig::set_servers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.servers)
  servers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DNSConfig::set_servers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  servers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.DNSConfig.servers)
}
inline void DNSConfig::set_servers(int index, const char* value, size_t size) {
  servers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.DNSConfig.servers)
}
inline ::std::string* DNSConfig::add_servers() {
  // @@protoc_insertion_point(field_add_mutable:runtime.DNSConfig.servers)
  return servers_.Add();
}
inline void DNSConfig::add_servers(const ::std::string& value) {
  servers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.servers)
}
#if LANG_CXX11
inline void DNSConfig::add_servers(::std::string&& value) {
  servers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.servers)
}
#endif
inline void DNSConfig::add_servers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  servers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.DNSConfig.servers)
}
inline void DNSConfig::add_servers(const char* value, size_t size) {
  servers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.DNSConfig.servers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DNSConfig::servers() const {
  // @@protoc_insertion_point(field_list:runtime.DNSConfig.servers)
  return servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DNSConfig::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:runtime.DNSConfig.servers)
  return &servers_;
}

// repeated string searches = 2;
inline int DNSConfig::searches_size() const {
  return searches_.size();
}
inline void DNSConfig::clear_searches() {
  searches_.Clear();
}
inline const ::std::string& DNSConfig::searches(int index) const {
  // @@protoc_insertion_point(field_get:runtime.DNSConfig.searches)
  return searches_.Get(index);
}
inline ::std::string* DNSConfig::mutable_searches(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.DNSConfig.searches)
  return searches_.Mutable(index);
}
inline void DNSConfig::set_searches(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.searches)
  searches_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DNSConfig::set_searches(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.searches)
  searches_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DNSConfig::set_searches(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  searches_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.DNSConfig.searches)
}
inline void DNSConfig::set_searches(int index, const char* value, size_t size) {
  searches_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.DNSConfig.searches)
}
inline ::std::string* DNSConfig::add_searches() {
  // @@protoc_insertion_point(field_add_mutable:runtime.DNSConfig.searches)
  return searches_.Add();
}
inline void DNSConfig::add_searches(const ::std::string& value) {
  searches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.searches)
}
#if LANG_CXX11
inline void DNSConfig::add_searches(::std::string&& value) {
  searches_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.searches)
}
#endif
inline void DNSConfig::add_searches(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  searches_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.DNSConfig.searches)
}
inline void DNSConfig::add_searches(const char* value, size_t size) {
  searches_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.DNSConfig.searches)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DNSConfig::searches() const {
  // @@protoc_insertion_point(field_list:runtime.DNSConfig.searches)
  return searches_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DNSConfig::mutable_searches() {
  // @@protoc_insertion_point(field_mutable_list:runtime.DNSConfig.searches)
  return &searches_;
}

// repeated string options = 3;
inline int DNSConfig::options_size() const {
  return options_.size();
}
inline void DNSConfig::clear_options() {
  options_.Clear();
}
inline const ::std::string& DNSConfig::options(int index) const {
  // @@protoc_insertion_point(field_get:runtime.DNSConfig.options)
  return options_.Get(index);
}
inline ::std::string* DNSConfig::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.DNSConfig.options)
  return options_.Mutable(index);
}
inline void DNSConfig::set_options(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.options)
  options_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DNSConfig::set_options(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.DNSConfig.options)
  options_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DNSConfig::set_options(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.DNSConfig.options)
}
inline void DNSConfig::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.DNSConfig.options)
}
inline ::std::string* DNSConfig::add_options() {
  // @@protoc_insertion_point(field_add_mutable:runtime.DNSConfig.options)
  return options_.Add();
}
inline void DNSConfig::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.options)
}
#if LANG_CXX11
inline void DNSConfig::add_options(::std::string&& value) {
  options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.DNSConfig.options)
}
#endif
inline void DNSConfig::add_options(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.DNSConfig.options)
}
inline void DNSConfig::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.DNSConfig.options)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DNSConfig::options() const {
  // @@protoc_insertion_point(field_list:runtime.DNSConfig.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DNSConfig::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:runtime.DNSConfig.options)
  return &options_;
}

// -------------------------------------------------------------------

// PortMapping

// .runtime.Protocol protocol = 1;
inline void PortMapping::clear_protocol() {
  protocol_ = 0;
}
inline ::runtime::Protocol PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:runtime.PortMapping.protocol)
  return static_cast< ::runtime::Protocol >(protocol_);
}
inline void PortMapping::set_protocol(::runtime::Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:runtime.PortMapping.protocol)
}

// int32 container_port = 2;
inline void PortMapping::clear_container_port() {
  container_port_ = 0;
}
inline ::google::protobuf::int32 PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:runtime.PortMapping.container_port)
  return container_port_;
}
inline void PortMapping::set_container_port(::google::protobuf::int32 value) {
  
  container_port_ = value;
  // @@protoc_insertion_point(field_set:runtime.PortMapping.container_port)
}

// int32 host_port = 3;
inline void PortMapping::clear_host_port() {
  host_port_ = 0;
}
inline ::google::protobuf::int32 PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:runtime.PortMapping.host_port)
  return host_port_;
}
inline void PortMapping::set_host_port(::google::protobuf::int32 value) {
  
  host_port_ = value;
  // @@protoc_insertion_point(field_set:runtime.PortMapping.host_port)
}

// string host_ip = 4;
inline void PortMapping::clear_host_ip() {
  host_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortMapping::host_ip() const {
  // @@protoc_insertion_point(field_get:runtime.PortMapping.host_ip)
  return host_ip_.GetNoArena();
}
inline void PortMapping::set_host_ip(const ::std::string& value) {
  
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PortMapping.host_ip)
}
#if LANG_CXX11
inline void PortMapping::set_host_ip(::std::string&& value) {
  
  host_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PortMapping.host_ip)
}
#endif
inline void PortMapping::set_host_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PortMapping.host_ip)
}
inline void PortMapping::set_host_ip(const char* value, size_t size) {
  
  host_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PortMapping.host_ip)
}
inline ::std::string* PortMapping::mutable_host_ip() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PortMapping.host_ip)
  return host_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortMapping::release_host_ip() {
  // @@protoc_insertion_point(field_release:runtime.PortMapping.host_ip)
  
  return host_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortMapping::set_allocated_host_ip(::std::string* host_ip) {
  if (host_ip != NULL) {
    
  } else {
    
  }
  host_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_ip);
  // @@protoc_insertion_point(field_set_allocated:runtime.PortMapping.host_ip)
}

// -------------------------------------------------------------------

// Mount

// string container_path = 1;
inline void Mount::clear_container_path() {
  container_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mount::container_path() const {
  // @@protoc_insertion_point(field_get:runtime.Mount.container_path)
  return container_path_.GetNoArena();
}
inline void Mount::set_container_path(const ::std::string& value) {
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Mount.container_path)
}
#if LANG_CXX11
inline void Mount::set_container_path(::std::string&& value) {
  
  container_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Mount.container_path)
}
#endif
inline void Mount::set_container_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Mount.container_path)
}
inline void Mount::set_container_path(const char* value, size_t size) {
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Mount.container_path)
}
inline ::std::string* Mount::mutable_container_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Mount.container_path)
  return container_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mount::release_container_path() {
  // @@protoc_insertion_point(field_release:runtime.Mount.container_path)
  
  return container_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mount::set_allocated_container_path(::std::string* container_path) {
  if (container_path != NULL) {
    
  } else {
    
  }
  container_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.Mount.container_path)
}

// string host_path = 2;
inline void Mount::clear_host_path() {
  host_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mount::host_path() const {
  // @@protoc_insertion_point(field_get:runtime.Mount.host_path)
  return host_path_.GetNoArena();
}
inline void Mount::set_host_path(const ::std::string& value) {
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Mount.host_path)
}
#if LANG_CXX11
inline void Mount::set_host_path(::std::string&& value) {
  
  host_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Mount.host_path)
}
#endif
inline void Mount::set_host_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Mount.host_path)
}
inline void Mount::set_host_path(const char* value, size_t size) {
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Mount.host_path)
}
inline ::std::string* Mount::mutable_host_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Mount.host_path)
  return host_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mount::release_host_path() {
  // @@protoc_insertion_point(field_release:runtime.Mount.host_path)
  
  return host_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mount::set_allocated_host_path(::std::string* host_path) {
  if (host_path != NULL) {
    
  } else {
    
  }
  host_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.Mount.host_path)
}

// bool readonly = 3;
inline void Mount::clear_readonly() {
  readonly_ = false;
}
inline bool Mount::readonly() const {
  // @@protoc_insertion_point(field_get:runtime.Mount.readonly)
  return readonly_;
}
inline void Mount::set_readonly(bool value) {
  
  readonly_ = value;
  // @@protoc_insertion_point(field_set:runtime.Mount.readonly)
}

// bool selinux_relabel = 4;
inline void Mount::clear_selinux_relabel() {
  selinux_relabel_ = false;
}
inline bool Mount::selinux_relabel() const {
  // @@protoc_insertion_point(field_get:runtime.Mount.selinux_relabel)
  return selinux_relabel_;
}
inline void Mount::set_selinux_relabel(bool value) {
  
  selinux_relabel_ = value;
  // @@protoc_insertion_point(field_set:runtime.Mount.selinux_relabel)
}

// .runtime.MountPropagation propagation = 5;
inline void Mount::clear_propagation() {
  propagation_ = 0;
}
inline ::runtime::MountPropagation Mount::propagation() const {
  // @@protoc_insertion_point(field_get:runtime.Mount.propagation)
  return static_cast< ::runtime::MountPropagation >(propagation_);
}
inline void Mount::set_propagation(::runtime::MountPropagation value) {
  
  propagation_ = value;
  // @@protoc_insertion_point(field_set:runtime.Mount.propagation)
}

// -------------------------------------------------------------------

// NamespaceOption

// bool host_network = 1;
inline void NamespaceOption::clear_host_network() {
  host_network_ = false;
}
inline bool NamespaceOption::host_network() const {
  // @@protoc_insertion_point(field_get:runtime.NamespaceOption.host_network)
  return host_network_;
}
inline void NamespaceOption::set_host_network(bool value) {
  
  host_network_ = value;
  // @@protoc_insertion_point(field_set:runtime.NamespaceOption.host_network)
}

// bool host_pid = 2;
inline void NamespaceOption::clear_host_pid() {
  host_pid_ = false;
}
inline bool NamespaceOption::host_pid() const {
  // @@protoc_insertion_point(field_get:runtime.NamespaceOption.host_pid)
  return host_pid_;
}
inline void NamespaceOption::set_host_pid(bool value) {
  
  host_pid_ = value;
  // @@protoc_insertion_point(field_set:runtime.NamespaceOption.host_pid)
}

// bool host_ipc = 3;
inline void NamespaceOption::clear_host_ipc() {
  host_ipc_ = false;
}
inline bool NamespaceOption::host_ipc() const {
  // @@protoc_insertion_point(field_get:runtime.NamespaceOption.host_ipc)
  return host_ipc_;
}
inline void NamespaceOption::set_host_ipc(bool value) {
  
  host_ipc_ = value;
  // @@protoc_insertion_point(field_set:runtime.NamespaceOption.host_ipc)
}

// -------------------------------------------------------------------

// Int64Value

// int64 value = 1;
inline void Int64Value::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Int64Value::value() const {
  // @@protoc_insertion_point(field_get:runtime.Int64Value.value)
  return value_;
}
inline void Int64Value::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:runtime.Int64Value.value)
}

// -------------------------------------------------------------------

// LinuxSandboxSecurityContext

// .runtime.NamespaceOption namespace_options = 1;
inline bool LinuxSandboxSecurityContext::has_namespace_options() const {
  return this != internal_default_instance() && namespace_options_ != NULL;
}
inline void LinuxSandboxSecurityContext::clear_namespace_options() {
  if (GetArenaNoVirtual() == NULL && namespace_options_ != NULL) {
    delete namespace_options_;
  }
  namespace_options_ = NULL;
}
inline const ::runtime::NamespaceOption& LinuxSandboxSecurityContext::namespace_options() const {
  const ::runtime::NamespaceOption* p = namespace_options_;
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.namespace_options)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::NamespaceOption*>(
      &::runtime::_NamespaceOption_default_instance_);
}
inline ::runtime::NamespaceOption* LinuxSandboxSecurityContext::release_namespace_options() {
  // @@protoc_insertion_point(field_release:runtime.LinuxSandboxSecurityContext.namespace_options)
  
  ::runtime::NamespaceOption* temp = namespace_options_;
  namespace_options_ = NULL;
  return temp;
}
inline ::runtime::NamespaceOption* LinuxSandboxSecurityContext::mutable_namespace_options() {
  
  if (namespace_options_ == NULL) {
    namespace_options_ = new ::runtime::NamespaceOption;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxSandboxSecurityContext.namespace_options)
  return namespace_options_;
}
inline void LinuxSandboxSecurityContext::set_allocated_namespace_options(::runtime::NamespaceOption* namespace_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete namespace_options_;
  }
  if (namespace_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      namespace_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, namespace_options, submessage_arena);
    }
    
  } else {
    
  }
  namespace_options_ = namespace_options;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxSandboxSecurityContext.namespace_options)
}

// .runtime.SELinuxOption selinux_options = 2;
inline bool LinuxSandboxSecurityContext::has_selinux_options() const {
  return this != internal_default_instance() && selinux_options_ != NULL;
}
inline void LinuxSandboxSecurityContext::clear_selinux_options() {
  if (GetArenaNoVirtual() == NULL && selinux_options_ != NULL) {
    delete selinux_options_;
  }
  selinux_options_ = NULL;
}
inline const ::runtime::SELinuxOption& LinuxSandboxSecurityContext::selinux_options() const {
  const ::runtime::SELinuxOption* p = selinux_options_;
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.selinux_options)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::SELinuxOption*>(
      &::runtime::_SELinuxOption_default_instance_);
}
inline ::runtime::SELinuxOption* LinuxSandboxSecurityContext::release_selinux_options() {
  // @@protoc_insertion_point(field_release:runtime.LinuxSandboxSecurityContext.selinux_options)
  
  ::runtime::SELinuxOption* temp = selinux_options_;
  selinux_options_ = NULL;
  return temp;
}
inline ::runtime::SELinuxOption* LinuxSandboxSecurityContext::mutable_selinux_options() {
  
  if (selinux_options_ == NULL) {
    selinux_options_ = new ::runtime::SELinuxOption;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxSandboxSecurityContext.selinux_options)
  return selinux_options_;
}
inline void LinuxSandboxSecurityContext::set_allocated_selinux_options(::runtime::SELinuxOption* selinux_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete selinux_options_;
  }
  if (selinux_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selinux_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selinux_options, submessage_arena);
    }
    
  } else {
    
  }
  selinux_options_ = selinux_options;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxSandboxSecurityContext.selinux_options)
}

// .runtime.Int64Value run_as_user = 3;
inline bool LinuxSandboxSecurityContext::has_run_as_user() const {
  return this != internal_default_instance() && run_as_user_ != NULL;
}
inline void LinuxSandboxSecurityContext::clear_run_as_user() {
  if (GetArenaNoVirtual() == NULL && run_as_user_ != NULL) {
    delete run_as_user_;
  }
  run_as_user_ = NULL;
}
inline const ::runtime::Int64Value& LinuxSandboxSecurityContext::run_as_user() const {
  const ::runtime::Int64Value* p = run_as_user_;
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.run_as_user)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Int64Value*>(
      &::runtime::_Int64Value_default_instance_);
}
inline ::runtime::Int64Value* LinuxSandboxSecurityContext::release_run_as_user() {
  // @@protoc_insertion_point(field_release:runtime.LinuxSandboxSecurityContext.run_as_user)
  
  ::runtime::Int64Value* temp = run_as_user_;
  run_as_user_ = NULL;
  return temp;
}
inline ::runtime::Int64Value* LinuxSandboxSecurityContext::mutable_run_as_user() {
  
  if (run_as_user_ == NULL) {
    run_as_user_ = new ::runtime::Int64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxSandboxSecurityContext.run_as_user)
  return run_as_user_;
}
inline void LinuxSandboxSecurityContext::set_allocated_run_as_user(::runtime::Int64Value* run_as_user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_as_user_;
  }
  if (run_as_user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run_as_user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run_as_user, submessage_arena);
    }
    
  } else {
    
  }
  run_as_user_ = run_as_user;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxSandboxSecurityContext.run_as_user)
}

// bool readonly_rootfs = 4;
inline void LinuxSandboxSecurityContext::clear_readonly_rootfs() {
  readonly_rootfs_ = false;
}
inline bool LinuxSandboxSecurityContext::readonly_rootfs() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.readonly_rootfs)
  return readonly_rootfs_;
}
inline void LinuxSandboxSecurityContext::set_readonly_rootfs(bool value) {
  
  readonly_rootfs_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxSandboxSecurityContext.readonly_rootfs)
}

// repeated int64 supplemental_groups = 5;
inline int LinuxSandboxSecurityContext::supplemental_groups_size() const {
  return supplemental_groups_.size();
}
inline void LinuxSandboxSecurityContext::clear_supplemental_groups() {
  supplemental_groups_.Clear();
}
inline ::google::protobuf::int64 LinuxSandboxSecurityContext::supplemental_groups(int index) const {
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.supplemental_groups)
  return supplemental_groups_.Get(index);
}
inline void LinuxSandboxSecurityContext::set_supplemental_groups(int index, ::google::protobuf::int64 value) {
  supplemental_groups_.Set(index, value);
  // @@protoc_insertion_point(field_set:runtime.LinuxSandboxSecurityContext.supplemental_groups)
}
inline void LinuxSandboxSecurityContext::add_supplemental_groups(::google::protobuf::int64 value) {
  supplemental_groups_.Add(value);
  // @@protoc_insertion_point(field_add:runtime.LinuxSandboxSecurityContext.supplemental_groups)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LinuxSandboxSecurityContext::supplemental_groups() const {
  // @@protoc_insertion_point(field_list:runtime.LinuxSandboxSecurityContext.supplemental_groups)
  return supplemental_groups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LinuxSandboxSecurityContext::mutable_supplemental_groups() {
  // @@protoc_insertion_point(field_mutable_list:runtime.LinuxSandboxSecurityContext.supplemental_groups)
  return &supplemental_groups_;
}

// bool privileged = 6;
inline void LinuxSandboxSecurityContext::clear_privileged() {
  privileged_ = false;
}
inline bool LinuxSandboxSecurityContext::privileged() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.privileged)
  return privileged_;
}
inline void LinuxSandboxSecurityContext::set_privileged(bool value) {
  
  privileged_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxSandboxSecurityContext.privileged)
}

// string seccomp_profile_path = 7;
inline void LinuxSandboxSecurityContext::clear_seccomp_profile_path() {
  seccomp_profile_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxSandboxSecurityContext::seccomp_profile_path() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
  return seccomp_profile_path_.GetNoArena();
}
inline void LinuxSandboxSecurityContext::set_seccomp_profile_path(const ::std::string& value) {
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
}
#if LANG_CXX11
inline void LinuxSandboxSecurityContext::set_seccomp_profile_path(::std::string&& value) {
  
  seccomp_profile_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
}
#endif
inline void LinuxSandboxSecurityContext::set_seccomp_profile_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
}
inline void LinuxSandboxSecurityContext::set_seccomp_profile_path(const char* value, size_t size) {
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
}
inline ::std::string* LinuxSandboxSecurityContext::mutable_seccomp_profile_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
  return seccomp_profile_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxSandboxSecurityContext::release_seccomp_profile_path() {
  // @@protoc_insertion_point(field_release:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
  
  return seccomp_profile_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxSandboxSecurityContext::set_allocated_seccomp_profile_path(::std::string* seccomp_profile_path) {
  if (seccomp_profile_path != NULL) {
    
  } else {
    
  }
  seccomp_profile_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seccomp_profile_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxSandboxSecurityContext.seccomp_profile_path)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LinuxPodSandboxConfig

// string cgroup_parent = 1;
inline void LinuxPodSandboxConfig::clear_cgroup_parent() {
  cgroup_parent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxPodSandboxConfig::cgroup_parent() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxPodSandboxConfig.cgroup_parent)
  return cgroup_parent_.GetNoArena();
}
inline void LinuxPodSandboxConfig::set_cgroup_parent(const ::std::string& value) {
  
  cgroup_parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxPodSandboxConfig.cgroup_parent)
}
#if LANG_CXX11
inline void LinuxPodSandboxConfig::set_cgroup_parent(::std::string&& value) {
  
  cgroup_parent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxPodSandboxConfig.cgroup_parent)
}
#endif
inline void LinuxPodSandboxConfig::set_cgroup_parent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cgroup_parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxPodSandboxConfig.cgroup_parent)
}
inline void LinuxPodSandboxConfig::set_cgroup_parent(const char* value, size_t size) {
  
  cgroup_parent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxPodSandboxConfig.cgroup_parent)
}
inline ::std::string* LinuxPodSandboxConfig::mutable_cgroup_parent() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxPodSandboxConfig.cgroup_parent)
  return cgroup_parent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxPodSandboxConfig::release_cgroup_parent() {
  // @@protoc_insertion_point(field_release:runtime.LinuxPodSandboxConfig.cgroup_parent)
  
  return cgroup_parent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxPodSandboxConfig::set_allocated_cgroup_parent(::std::string* cgroup_parent) {
  if (cgroup_parent != NULL) {
    
  } else {
    
  }
  cgroup_parent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cgroup_parent);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxPodSandboxConfig.cgroup_parent)
}

// .runtime.LinuxSandboxSecurityContext security_context = 2;
inline bool LinuxPodSandboxConfig::has_security_context() const {
  return this != internal_default_instance() && security_context_ != NULL;
}
inline void LinuxPodSandboxConfig::clear_security_context() {
  if (GetArenaNoVirtual() == NULL && security_context_ != NULL) {
    delete security_context_;
  }
  security_context_ = NULL;
}
inline const ::runtime::LinuxSandboxSecurityContext& LinuxPodSandboxConfig::security_context() const {
  const ::runtime::LinuxSandboxSecurityContext* p = security_context_;
  // @@protoc_insertion_point(field_get:runtime.LinuxPodSandboxConfig.security_context)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxSandboxSecurityContext*>(
      &::runtime::_LinuxSandboxSecurityContext_default_instance_);
}
inline ::runtime::LinuxSandboxSecurityContext* LinuxPodSandboxConfig::release_security_context() {
  // @@protoc_insertion_point(field_release:runtime.LinuxPodSandboxConfig.security_context)
  
  ::runtime::LinuxSandboxSecurityContext* temp = security_context_;
  security_context_ = NULL;
  return temp;
}
inline ::runtime::LinuxSandboxSecurityContext* LinuxPodSandboxConfig::mutable_security_context() {
  
  if (security_context_ == NULL) {
    security_context_ = new ::runtime::LinuxSandboxSecurityContext;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxPodSandboxConfig.security_context)
  return security_context_;
}
inline void LinuxPodSandboxConfig::set_allocated_security_context(::runtime::LinuxSandboxSecurityContext* security_context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete security_context_;
  }
  if (security_context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      security_context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, security_context, submessage_arena);
    }
    
  } else {
    
  }
  security_context_ = security_context;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxPodSandboxConfig.security_context)
}

// map<string, string> sysctls = 3;
inline int LinuxPodSandboxConfig::sysctls_size() const {
  return sysctls_.size();
}
inline void LinuxPodSandboxConfig::clear_sysctls() {
  sysctls_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
LinuxPodSandboxConfig::sysctls() const {
  // @@protoc_insertion_point(field_map:runtime.LinuxPodSandboxConfig.sysctls)
  return sysctls_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
LinuxPodSandboxConfig::mutable_sysctls() {
  // @@protoc_insertion_point(field_mutable_map:runtime.LinuxPodSandboxConfig.sysctls)
  return sysctls_.MutableMap();
}

// -------------------------------------------------------------------

// PodSandboxMetadata

// string name = 1;
inline void PodSandboxMetadata::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxMetadata::name() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxMetadata.name)
  return name_.GetNoArena();
}
inline void PodSandboxMetadata::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxMetadata.name)
}
#if LANG_CXX11
inline void PodSandboxMetadata::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxMetadata.name)
}
#endif
inline void PodSandboxMetadata::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxMetadata.name)
}
inline void PodSandboxMetadata::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxMetadata.name)
}
inline ::std::string* PodSandboxMetadata::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxMetadata.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxMetadata::release_name() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxMetadata.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxMetadata::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxMetadata.name)
}

// string uid = 2;
inline void PodSandboxMetadata::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxMetadata::uid() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxMetadata.uid)
  return uid_.GetNoArena();
}
inline void PodSandboxMetadata::set_uid(const ::std::string& value) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxMetadata.uid)
}
#if LANG_CXX11
inline void PodSandboxMetadata::set_uid(::std::string&& value) {
  
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxMetadata.uid)
}
#endif
inline void PodSandboxMetadata::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxMetadata.uid)
}
inline void PodSandboxMetadata::set_uid(const char* value, size_t size) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxMetadata.uid)
}
inline ::std::string* PodSandboxMetadata::mutable_uid() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxMetadata.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxMetadata::release_uid() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxMetadata.uid)
  
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxMetadata::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    
  } else {
    
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxMetadata.uid)
}

// string namespace = 3;
inline void PodSandboxMetadata::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxMetadata::namespace_() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxMetadata.namespace)
  return namespace__.GetNoArena();
}
inline void PodSandboxMetadata::set_namespace_(const ::std::string& value) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxMetadata.namespace)
}
#if LANG_CXX11
inline void PodSandboxMetadata::set_namespace_(::std::string&& value) {
  
  namespace__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxMetadata.namespace)
}
#endif
inline void PodSandboxMetadata::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxMetadata.namespace)
}
inline void PodSandboxMetadata::set_namespace_(const char* value, size_t size) {
  
  namespace__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxMetadata.namespace)
}
inline ::std::string* PodSandboxMetadata::mutable_namespace_() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxMetadata.namespace)
  return namespace__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxMetadata::release_namespace_() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxMetadata.namespace)
  
  return namespace__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxMetadata::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace_ != NULL) {
    
  } else {
    
  }
  namespace__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxMetadata.namespace)
}

// uint32 attempt = 4;
inline void PodSandboxMetadata::clear_attempt() {
  attempt_ = 0u;
}
inline ::google::protobuf::uint32 PodSandboxMetadata::attempt() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxMetadata.attempt)
  return attempt_;
}
inline void PodSandboxMetadata::set_attempt(::google::protobuf::uint32 value) {
  
  attempt_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandboxMetadata.attempt)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PodSandboxConfig

// .runtime.PodSandboxMetadata metadata = 1;
inline bool PodSandboxConfig::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void PodSandboxConfig::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::PodSandboxMetadata& PodSandboxConfig::metadata() const {
  const ::runtime::PodSandboxMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxMetadata*>(
      &::runtime::_PodSandboxMetadata_default_instance_);
}
inline ::runtime::PodSandboxMetadata* PodSandboxConfig::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxConfig.metadata)
  
  ::runtime::PodSandboxMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxMetadata* PodSandboxConfig::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::PodSandboxMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.metadata)
  return metadata_;
}
inline void PodSandboxConfig::set_allocated_metadata(::runtime::PodSandboxMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxConfig.metadata)
}

// string hostname = 2;
inline void PodSandboxConfig::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxConfig::hostname() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.hostname)
  return hostname_.GetNoArena();
}
inline void PodSandboxConfig::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxConfig.hostname)
}
#if LANG_CXX11
inline void PodSandboxConfig::set_hostname(::std::string&& value) {
  
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxConfig.hostname)
}
#endif
inline void PodSandboxConfig::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxConfig.hostname)
}
inline void PodSandboxConfig::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxConfig.hostname)
}
inline ::std::string* PodSandboxConfig::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxConfig::release_hostname() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxConfig.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxConfig::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxConfig.hostname)
}

// string log_directory = 3;
inline void PodSandboxConfig::clear_log_directory() {
  log_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxConfig::log_directory() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.log_directory)
  return log_directory_.GetNoArena();
}
inline void PodSandboxConfig::set_log_directory(const ::std::string& value) {
  
  log_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxConfig.log_directory)
}
#if LANG_CXX11
inline void PodSandboxConfig::set_log_directory(::std::string&& value) {
  
  log_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxConfig.log_directory)
}
#endif
inline void PodSandboxConfig::set_log_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxConfig.log_directory)
}
inline void PodSandboxConfig::set_log_directory(const char* value, size_t size) {
  
  log_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxConfig.log_directory)
}
inline ::std::string* PodSandboxConfig::mutable_log_directory() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.log_directory)
  return log_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxConfig::release_log_directory() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxConfig.log_directory)
  
  return log_directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxConfig::set_allocated_log_directory(::std::string* log_directory) {
  if (log_directory != NULL) {
    
  } else {
    
  }
  log_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_directory);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxConfig.log_directory)
}

// .runtime.DNSConfig dns_config = 4;
inline bool PodSandboxConfig::has_dns_config() const {
  return this != internal_default_instance() && dns_config_ != NULL;
}
inline void PodSandboxConfig::clear_dns_config() {
  if (GetArenaNoVirtual() == NULL && dns_config_ != NULL) {
    delete dns_config_;
  }
  dns_config_ = NULL;
}
inline const ::runtime::DNSConfig& PodSandboxConfig::dns_config() const {
  const ::runtime::DNSConfig* p = dns_config_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.dns_config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::DNSConfig*>(
      &::runtime::_DNSConfig_default_instance_);
}
inline ::runtime::DNSConfig* PodSandboxConfig::release_dns_config() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxConfig.dns_config)
  
  ::runtime::DNSConfig* temp = dns_config_;
  dns_config_ = NULL;
  return temp;
}
inline ::runtime::DNSConfig* PodSandboxConfig::mutable_dns_config() {
  
  if (dns_config_ == NULL) {
    dns_config_ = new ::runtime::DNSConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.dns_config)
  return dns_config_;
}
inline void PodSandboxConfig::set_allocated_dns_config(::runtime::DNSConfig* dns_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dns_config_;
  }
  if (dns_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dns_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dns_config, submessage_arena);
    }
    
  } else {
    
  }
  dns_config_ = dns_config;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxConfig.dns_config)
}

// repeated .runtime.PortMapping port_mappings = 5;
inline int PodSandboxConfig::port_mappings_size() const {
  return port_mappings_.size();
}
inline void PodSandboxConfig::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::runtime::PortMapping& PodSandboxConfig::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.port_mappings)
  return port_mappings_.Get(index);
}
inline ::runtime::PortMapping* PodSandboxConfig::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::runtime::PortMapping* PodSandboxConfig::add_port_mappings() {
  // @@protoc_insertion_point(field_add:runtime.PodSandboxConfig.port_mappings)
  return port_mappings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::PortMapping >*
PodSandboxConfig::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:runtime.PodSandboxConfig.port_mappings)
  return &port_mappings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::PortMapping >&
PodSandboxConfig::port_mappings() const {
  // @@protoc_insertion_point(field_list:runtime.PodSandboxConfig.port_mappings)
  return port_mappings_;
}

// map<string, string> labels = 6;
inline int PodSandboxConfig::labels_size() const {
  return labels_.size();
}
inline void PodSandboxConfig::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxConfig::labels() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxConfig.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxConfig::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxConfig.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 7;
inline int PodSandboxConfig::annotations_size() const {
  return annotations_.size();
}
inline void PodSandboxConfig::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxConfig::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxConfig.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxConfig::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxConfig.annotations)
  return annotations_.MutableMap();
}

// .runtime.LinuxPodSandboxConfig linux = 8;
inline bool PodSandboxConfig::has_linux() const {
  return this != internal_default_instance() && linux_ != NULL;
}
inline void PodSandboxConfig::clear_linux() {
  if (GetArenaNoVirtual() == NULL && linux_ != NULL) {
    delete linux_;
  }
  linux_ = NULL;
}
inline const ::runtime::LinuxPodSandboxConfig& PodSandboxConfig::linux() const {
  const ::runtime::LinuxPodSandboxConfig* p = linux_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxConfig.linux)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxPodSandboxConfig*>(
      &::runtime::_LinuxPodSandboxConfig_default_instance_);
}
inline ::runtime::LinuxPodSandboxConfig* PodSandboxConfig::release_linux() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxConfig.linux)
  
  ::runtime::LinuxPodSandboxConfig* temp = linux_;
  linux_ = NULL;
  return temp;
}
inline ::runtime::LinuxPodSandboxConfig* PodSandboxConfig::mutable_linux() {
  
  if (linux_ == NULL) {
    linux_ = new ::runtime::LinuxPodSandboxConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxConfig.linux)
  return linux_;
}
inline void PodSandboxConfig::set_allocated_linux(::runtime::LinuxPodSandboxConfig* linux) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linux_;
  }
  if (linux) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linux = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linux, submessage_arena);
    }
    
  } else {
    
  }
  linux_ = linux;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxConfig.linux)
}

// -------------------------------------------------------------------

// RunPodSandboxRequest

// .runtime.PodSandboxConfig config = 1;
inline bool RunPodSandboxRequest::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void RunPodSandboxRequest::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::runtime::PodSandboxConfig& RunPodSandboxRequest::config() const {
  const ::runtime::PodSandboxConfig* p = config_;
  // @@protoc_insertion_point(field_get:runtime.RunPodSandboxRequest.config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxConfig*>(
      &::runtime::_PodSandboxConfig_default_instance_);
}
inline ::runtime::PodSandboxConfig* RunPodSandboxRequest::release_config() {
  // @@protoc_insertion_point(field_release:runtime.RunPodSandboxRequest.config)
  
  ::runtime::PodSandboxConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxConfig* RunPodSandboxRequest::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::runtime::PodSandboxConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.RunPodSandboxRequest.config)
  return config_;
}
inline void RunPodSandboxRequest::set_allocated_config(::runtime::PodSandboxConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:runtime.RunPodSandboxRequest.config)
}

// -------------------------------------------------------------------

// RunPodSandboxResponse

// string pod_sandbox_id = 1;
inline void RunPodSandboxResponse::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunPodSandboxResponse::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.RunPodSandboxResponse.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void RunPodSandboxResponse::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RunPodSandboxResponse.pod_sandbox_id)
}
#if LANG_CXX11
inline void RunPodSandboxResponse::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RunPodSandboxResponse.pod_sandbox_id)
}
#endif
inline void RunPodSandboxResponse::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RunPodSandboxResponse.pod_sandbox_id)
}
inline void RunPodSandboxResponse::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RunPodSandboxResponse.pod_sandbox_id)
}
inline ::std::string* RunPodSandboxResponse::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RunPodSandboxResponse.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunPodSandboxResponse::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.RunPodSandboxResponse.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunPodSandboxResponse::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.RunPodSandboxResponse.pod_sandbox_id)
}

// -------------------------------------------------------------------

// StopPodSandboxRequest

// string pod_sandbox_id = 1;
inline void StopPodSandboxRequest::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StopPodSandboxRequest::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.StopPodSandboxRequest.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void StopPodSandboxRequest::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.StopPodSandboxRequest.pod_sandbox_id)
}
#if LANG_CXX11
inline void StopPodSandboxRequest::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.StopPodSandboxRequest.pod_sandbox_id)
}
#endif
inline void StopPodSandboxRequest::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.StopPodSandboxRequest.pod_sandbox_id)
}
inline void StopPodSandboxRequest::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.StopPodSandboxRequest.pod_sandbox_id)
}
inline ::std::string* StopPodSandboxRequest::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.StopPodSandboxRequest.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopPodSandboxRequest::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.StopPodSandboxRequest.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopPodSandboxRequest::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.StopPodSandboxRequest.pod_sandbox_id)
}

// -------------------------------------------------------------------

// StopPodSandboxResponse

// -------------------------------------------------------------------

// RemovePodSandboxRequest

// string pod_sandbox_id = 1;
inline void RemovePodSandboxRequest::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RemovePodSandboxRequest::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.RemovePodSandboxRequest.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void RemovePodSandboxRequest::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RemovePodSandboxRequest.pod_sandbox_id)
}
#if LANG_CXX11
inline void RemovePodSandboxRequest::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RemovePodSandboxRequest.pod_sandbox_id)
}
#endif
inline void RemovePodSandboxRequest::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RemovePodSandboxRequest.pod_sandbox_id)
}
inline void RemovePodSandboxRequest::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RemovePodSandboxRequest.pod_sandbox_id)
}
inline ::std::string* RemovePodSandboxRequest::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RemovePodSandboxRequest.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemovePodSandboxRequest::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.RemovePodSandboxRequest.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemovePodSandboxRequest::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.RemovePodSandboxRequest.pod_sandbox_id)
}

// -------------------------------------------------------------------

// RemovePodSandboxResponse

// -------------------------------------------------------------------

// PodSandboxStatusRequest

// string pod_sandbox_id = 1;
inline void PodSandboxStatusRequest::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxStatusRequest::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatusRequest.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void PodSandboxStatusRequest::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStatusRequest.pod_sandbox_id)
}
#if LANG_CXX11
inline void PodSandboxStatusRequest::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxStatusRequest.pod_sandbox_id)
}
#endif
inline void PodSandboxStatusRequest::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxStatusRequest.pod_sandbox_id)
}
inline void PodSandboxStatusRequest::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxStatusRequest.pod_sandbox_id)
}
inline ::std::string* PodSandboxStatusRequest::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatusRequest.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxStatusRequest::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatusRequest.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxStatusRequest::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatusRequest.pod_sandbox_id)
}

// bool verbose = 2;
inline void PodSandboxStatusRequest::clear_verbose() {
  verbose_ = false;
}
inline bool PodSandboxStatusRequest::verbose() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatusRequest.verbose)
  return verbose_;
}
inline void PodSandboxStatusRequest::set_verbose(bool value) {
  
  verbose_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStatusRequest.verbose)
}

// -------------------------------------------------------------------

// PodSandboxNetworkStatus

// string ip = 1;
inline void PodSandboxNetworkStatus::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxNetworkStatus::ip() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxNetworkStatus.ip)
  return ip_.GetNoArena();
}
inline void PodSandboxNetworkStatus::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxNetworkStatus.ip)
}
#if LANG_CXX11
inline void PodSandboxNetworkStatus::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxNetworkStatus.ip)
}
#endif
inline void PodSandboxNetworkStatus::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxNetworkStatus.ip)
}
inline void PodSandboxNetworkStatus::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxNetworkStatus.ip)
}
inline ::std::string* PodSandboxNetworkStatus::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxNetworkStatus.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxNetworkStatus::release_ip() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxNetworkStatus.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxNetworkStatus::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxNetworkStatus.ip)
}

// -------------------------------------------------------------------

// Namespace

// .runtime.NamespaceOption options = 2;
inline bool Namespace::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void Namespace::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::runtime::NamespaceOption& Namespace::options() const {
  const ::runtime::NamespaceOption* p = options_;
  // @@protoc_insertion_point(field_get:runtime.Namespace.options)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::NamespaceOption*>(
      &::runtime::_NamespaceOption_default_instance_);
}
inline ::runtime::NamespaceOption* Namespace::release_options() {
  // @@protoc_insertion_point(field_release:runtime.Namespace.options)
  
  ::runtime::NamespaceOption* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::runtime::NamespaceOption* Namespace::mutable_options() {
  
  if (options_ == NULL) {
    options_ = new ::runtime::NamespaceOption;
  }
  // @@protoc_insertion_point(field_mutable:runtime.Namespace.options)
  return options_;
}
inline void Namespace::set_allocated_options(::runtime::NamespaceOption* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:runtime.Namespace.options)
}

// -------------------------------------------------------------------

// LinuxPodSandboxStatus

// .runtime.Namespace namespaces = 1;
inline bool LinuxPodSandboxStatus::has_namespaces() const {
  return this != internal_default_instance() && namespaces_ != NULL;
}
inline void LinuxPodSandboxStatus::clear_namespaces() {
  if (GetArenaNoVirtual() == NULL && namespaces_ != NULL) {
    delete namespaces_;
  }
  namespaces_ = NULL;
}
inline const ::runtime::Namespace& LinuxPodSandboxStatus::namespaces() const {
  const ::runtime::Namespace* p = namespaces_;
  // @@protoc_insertion_point(field_get:runtime.LinuxPodSandboxStatus.namespaces)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Namespace*>(
      &::runtime::_Namespace_default_instance_);
}
inline ::runtime::Namespace* LinuxPodSandboxStatus::release_namespaces() {
  // @@protoc_insertion_point(field_release:runtime.LinuxPodSandboxStatus.namespaces)
  
  ::runtime::Namespace* temp = namespaces_;
  namespaces_ = NULL;
  return temp;
}
inline ::runtime::Namespace* LinuxPodSandboxStatus::mutable_namespaces() {
  
  if (namespaces_ == NULL) {
    namespaces_ = new ::runtime::Namespace;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxPodSandboxStatus.namespaces)
  return namespaces_;
}
inline void LinuxPodSandboxStatus::set_allocated_namespaces(::runtime::Namespace* namespaces) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete namespaces_;
  }
  if (namespaces) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      namespaces = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, namespaces, submessage_arena);
    }
    
  } else {
    
  }
  namespaces_ = namespaces;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxPodSandboxStatus.namespaces)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PodSandboxStatus

// string id = 1;
inline void PodSandboxStatus::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxStatus::id() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.id)
  return id_.GetNoArena();
}
inline void PodSandboxStatus::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStatus.id)
}
#if LANG_CXX11
inline void PodSandboxStatus::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxStatus.id)
}
#endif
inline void PodSandboxStatus::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxStatus.id)
}
inline void PodSandboxStatus::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxStatus.id)
}
inline ::std::string* PodSandboxStatus::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatus.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxStatus::release_id() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatus.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxStatus::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatus.id)
}

// .runtime.PodSandboxMetadata metadata = 2;
inline bool PodSandboxStatus::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void PodSandboxStatus::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::PodSandboxMetadata& PodSandboxStatus::metadata() const {
  const ::runtime::PodSandboxMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxMetadata*>(
      &::runtime::_PodSandboxMetadata_default_instance_);
}
inline ::runtime::PodSandboxMetadata* PodSandboxStatus::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatus.metadata)
  
  ::runtime::PodSandboxMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxMetadata* PodSandboxStatus::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::PodSandboxMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatus.metadata)
  return metadata_;
}
inline void PodSandboxStatus::set_allocated_metadata(::runtime::PodSandboxMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatus.metadata)
}

// .runtime.PodSandboxState state = 3;
inline void PodSandboxStatus::clear_state() {
  state_ = 0;
}
inline ::runtime::PodSandboxState PodSandboxStatus::state() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.state)
  return static_cast< ::runtime::PodSandboxState >(state_);
}
inline void PodSandboxStatus::set_state(::runtime::PodSandboxState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStatus.state)
}

// int64 created_at = 4;
inline void PodSandboxStatus::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PodSandboxStatus::created_at() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.created_at)
  return created_at_;
}
inline void PodSandboxStatus::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStatus.created_at)
}

// .runtime.PodSandboxNetworkStatus network = 5;
inline bool PodSandboxStatus::has_network() const {
  return this != internal_default_instance() && network_ != NULL;
}
inline void PodSandboxStatus::clear_network() {
  if (GetArenaNoVirtual() == NULL && network_ != NULL) {
    delete network_;
  }
  network_ = NULL;
}
inline const ::runtime::PodSandboxNetworkStatus& PodSandboxStatus::network() const {
  const ::runtime::PodSandboxNetworkStatus* p = network_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.network)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxNetworkStatus*>(
      &::runtime::_PodSandboxNetworkStatus_default_instance_);
}
inline ::runtime::PodSandboxNetworkStatus* PodSandboxStatus::release_network() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatus.network)
  
  ::runtime::PodSandboxNetworkStatus* temp = network_;
  network_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxNetworkStatus* PodSandboxStatus::mutable_network() {
  
  if (network_ == NULL) {
    network_ = new ::runtime::PodSandboxNetworkStatus;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatus.network)
  return network_;
}
inline void PodSandboxStatus::set_allocated_network(::runtime::PodSandboxNetworkStatus* network) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete network_;
  }
  if (network) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      network = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, network, submessage_arena);
    }
    
  } else {
    
  }
  network_ = network;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatus.network)
}

// .runtime.LinuxPodSandboxStatus linux = 6;
inline bool PodSandboxStatus::has_linux() const {
  return this != internal_default_instance() && linux_ != NULL;
}
inline void PodSandboxStatus::clear_linux() {
  if (GetArenaNoVirtual() == NULL && linux_ != NULL) {
    delete linux_;
  }
  linux_ = NULL;
}
inline const ::runtime::LinuxPodSandboxStatus& PodSandboxStatus::linux() const {
  const ::runtime::LinuxPodSandboxStatus* p = linux_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatus.linux)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxPodSandboxStatus*>(
      &::runtime::_LinuxPodSandboxStatus_default_instance_);
}
inline ::runtime::LinuxPodSandboxStatus* PodSandboxStatus::release_linux() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatus.linux)
  
  ::runtime::LinuxPodSandboxStatus* temp = linux_;
  linux_ = NULL;
  return temp;
}
inline ::runtime::LinuxPodSandboxStatus* PodSandboxStatus::mutable_linux() {
  
  if (linux_ == NULL) {
    linux_ = new ::runtime::LinuxPodSandboxStatus;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatus.linux)
  return linux_;
}
inline void PodSandboxStatus::set_allocated_linux(::runtime::LinuxPodSandboxStatus* linux) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linux_;
  }
  if (linux) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linux = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linux, submessage_arena);
    }
    
  } else {
    
  }
  linux_ = linux;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatus.linux)
}

// map<string, string> labels = 7;
inline int PodSandboxStatus::labels_size() const {
  return labels_.size();
}
inline void PodSandboxStatus::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxStatus::labels() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxStatus.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxStatus::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxStatus.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 8;
inline int PodSandboxStatus::annotations_size() const {
  return annotations_.size();
}
inline void PodSandboxStatus::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxStatus::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxStatus.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxStatus::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxStatus.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PodSandboxStatusResponse

// .runtime.PodSandboxStatus status = 1;
inline bool PodSandboxStatusResponse::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void PodSandboxStatusResponse::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::runtime::PodSandboxStatus& PodSandboxStatusResponse::status() const {
  const ::runtime::PodSandboxStatus* p = status_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStatusResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxStatus*>(
      &::runtime::_PodSandboxStatus_default_instance_);
}
inline ::runtime::PodSandboxStatus* PodSandboxStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxStatusResponse.status)
  
  ::runtime::PodSandboxStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxStatus* PodSandboxStatusResponse::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::runtime::PodSandboxStatus;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxStatusResponse.status)
  return status_;
}
inline void PodSandboxStatusResponse::set_allocated_status(::runtime::PodSandboxStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxStatusResponse.status)
}

// map<string, string> info = 2;
inline int PodSandboxStatusResponse::info_size() const {
  return info_.size();
}
inline void PodSandboxStatusResponse::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxStatusResponse::info() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxStatusResponse.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxStatusResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxStatusResponse.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// PodSandboxStateValue

// .runtime.PodSandboxState state = 1;
inline void PodSandboxStateValue::clear_state() {
  state_ = 0;
}
inline ::runtime::PodSandboxState PodSandboxStateValue::state() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxStateValue.state)
  return static_cast< ::runtime::PodSandboxState >(state_);
}
inline void PodSandboxStateValue::set_state(::runtime::PodSandboxState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandboxStateValue.state)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PodSandboxFilter

// string id = 1;
inline void PodSandboxFilter::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandboxFilter::id() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandboxFilter.id)
  return id_.GetNoArena();
}
inline void PodSandboxFilter::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandboxFilter.id)
}
#if LANG_CXX11
inline void PodSandboxFilter::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandboxFilter.id)
}
#endif
inline void PodSandboxFilter::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandboxFilter.id)
}
inline void PodSandboxFilter::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandboxFilter.id)
}
inline ::std::string* PodSandboxFilter::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxFilter.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandboxFilter::release_id() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxFilter.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandboxFilter::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxFilter.id)
}

// .runtime.PodSandboxStateValue state = 2;
inline bool PodSandboxFilter::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void PodSandboxFilter::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::runtime::PodSandboxStateValue& PodSandboxFilter::state() const {
  const ::runtime::PodSandboxStateValue* p = state_;
  // @@protoc_insertion_point(field_get:runtime.PodSandboxFilter.state)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxStateValue*>(
      &::runtime::_PodSandboxStateValue_default_instance_);
}
inline ::runtime::PodSandboxStateValue* PodSandboxFilter::release_state() {
  // @@protoc_insertion_point(field_release:runtime.PodSandboxFilter.state)
  
  ::runtime::PodSandboxStateValue* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxStateValue* PodSandboxFilter::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::runtime::PodSandboxStateValue;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandboxFilter.state)
  return state_;
}
inline void PodSandboxFilter::set_allocated_state(::runtime::PodSandboxStateValue* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandboxFilter.state)
}

// map<string, string> label_selector = 3;
inline int PodSandboxFilter::label_selector_size() const {
  return label_selector_.size();
}
inline void PodSandboxFilter::clear_label_selector() {
  label_selector_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandboxFilter::label_selector() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandboxFilter.label_selector)
  return label_selector_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandboxFilter::mutable_label_selector() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandboxFilter.label_selector)
  return label_selector_.MutableMap();
}

// -------------------------------------------------------------------

// ListPodSandboxRequest

// .runtime.PodSandboxFilter filter = 1;
inline bool ListPodSandboxRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void ListPodSandboxRequest::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::runtime::PodSandboxFilter& ListPodSandboxRequest::filter() const {
  const ::runtime::PodSandboxFilter* p = filter_;
  // @@protoc_insertion_point(field_get:runtime.ListPodSandboxRequest.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxFilter*>(
      &::runtime::_PodSandboxFilter_default_instance_);
}
inline ::runtime::PodSandboxFilter* ListPodSandboxRequest::release_filter() {
  // @@protoc_insertion_point(field_release:runtime.ListPodSandboxRequest.filter)
  
  ::runtime::PodSandboxFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxFilter* ListPodSandboxRequest::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::runtime::PodSandboxFilter;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ListPodSandboxRequest.filter)
  return filter_;
}
inline void ListPodSandboxRequest::set_allocated_filter(::runtime::PodSandboxFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:runtime.ListPodSandboxRequest.filter)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PodSandbox

// string id = 1;
inline void PodSandbox::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PodSandbox::id() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandbox.id)
  return id_.GetNoArena();
}
inline void PodSandbox::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PodSandbox.id)
}
#if LANG_CXX11
inline void PodSandbox::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PodSandbox.id)
}
#endif
inline void PodSandbox::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PodSandbox.id)
}
inline void PodSandbox::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PodSandbox.id)
}
inline ::std::string* PodSandbox::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PodSandbox.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PodSandbox::release_id() {
  // @@protoc_insertion_point(field_release:runtime.PodSandbox.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PodSandbox::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandbox.id)
}

// .runtime.PodSandboxMetadata metadata = 2;
inline bool PodSandbox::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void PodSandbox::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::PodSandboxMetadata& PodSandbox::metadata() const {
  const ::runtime::PodSandboxMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.PodSandbox.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxMetadata*>(
      &::runtime::_PodSandboxMetadata_default_instance_);
}
inline ::runtime::PodSandboxMetadata* PodSandbox::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.PodSandbox.metadata)
  
  ::runtime::PodSandboxMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxMetadata* PodSandbox::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::PodSandboxMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PodSandbox.metadata)
  return metadata_;
}
inline void PodSandbox::set_allocated_metadata(::runtime::PodSandboxMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.PodSandbox.metadata)
}

// .runtime.PodSandboxState state = 3;
inline void PodSandbox::clear_state() {
  state_ = 0;
}
inline ::runtime::PodSandboxState PodSandbox::state() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandbox.state)
  return static_cast< ::runtime::PodSandboxState >(state_);
}
inline void PodSandbox::set_state(::runtime::PodSandboxState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandbox.state)
}

// int64 created_at = 4;
inline void PodSandbox::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PodSandbox::created_at() const {
  // @@protoc_insertion_point(field_get:runtime.PodSandbox.created_at)
  return created_at_;
}
inline void PodSandbox::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.PodSandbox.created_at)
}

// map<string, string> labels = 5;
inline int PodSandbox::labels_size() const {
  return labels_.size();
}
inline void PodSandbox::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandbox::labels() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandbox.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandbox::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandbox.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 6;
inline int PodSandbox::annotations_size() const {
  return annotations_.size();
}
inline void PodSandbox::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
PodSandbox::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.PodSandbox.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
PodSandbox::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.PodSandbox.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// ListPodSandboxResponse

// repeated .runtime.PodSandbox items = 1;
inline int ListPodSandboxResponse::items_size() const {
  return items_.size();
}
inline void ListPodSandboxResponse::clear_items() {
  items_.Clear();
}
inline const ::runtime::PodSandbox& ListPodSandboxResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ListPodSandboxResponse.items)
  return items_.Get(index);
}
inline ::runtime::PodSandbox* ListPodSandboxResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ListPodSandboxResponse.items)
  return items_.Mutable(index);
}
inline ::runtime::PodSandbox* ListPodSandboxResponse::add_items() {
  // @@protoc_insertion_point(field_add:runtime.ListPodSandboxResponse.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::PodSandbox >*
ListPodSandboxResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ListPodSandboxResponse.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::PodSandbox >&
ListPodSandboxResponse::items() const {
  // @@protoc_insertion_point(field_list:runtime.ListPodSandboxResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// ImageSpec

// string image = 1;
inline void ImageSpec::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageSpec::image() const {
  // @@protoc_insertion_point(field_get:runtime.ImageSpec.image)
  return image_.GetNoArena();
}
inline void ImageSpec::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ImageSpec.image)
}
#if LANG_CXX11
inline void ImageSpec::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ImageSpec.image)
}
#endif
inline void ImageSpec::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ImageSpec.image)
}
inline void ImageSpec::set_image(const char* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ImageSpec.image)
}
inline ::std::string* ImageSpec::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ImageSpec.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageSpec::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ImageSpec.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageSpec::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:runtime.ImageSpec.image)
}

// -------------------------------------------------------------------

// KeyValue

// string key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:runtime.KeyValue.key)
  return key_.GetNoArena();
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.KeyValue.key)
}
#if LANG_CXX11
inline void KeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.KeyValue.key)
}
#endif
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.KeyValue.key)
}
inline void KeyValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.KeyValue.key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:runtime.KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:runtime.KeyValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:runtime.KeyValue.key)
}

// string value = 2;
inline void KeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:runtime.KeyValue.value)
  return value_.GetNoArena();
}
inline void KeyValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.KeyValue.value)
}
#if LANG_CXX11
inline void KeyValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.KeyValue.value)
}
#endif
inline void KeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.KeyValue.value)
}
inline void KeyValue::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.KeyValue.value)
}
inline ::std::string* KeyValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:runtime.KeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:runtime.KeyValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:runtime.KeyValue.value)
}

// -------------------------------------------------------------------

// LinuxContainerResources

// int64 cpu_period = 1;
inline void LinuxContainerResources::clear_cpu_period() {
  cpu_period_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LinuxContainerResources::cpu_period() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.cpu_period)
  return cpu_period_;
}
inline void LinuxContainerResources::set_cpu_period(::google::protobuf::int64 value) {
  
  cpu_period_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.cpu_period)
}

// int64 cpu_quota = 2;
inline void LinuxContainerResources::clear_cpu_quota() {
  cpu_quota_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LinuxContainerResources::cpu_quota() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.cpu_quota)
  return cpu_quota_;
}
inline void LinuxContainerResources::set_cpu_quota(::google::protobuf::int64 value) {
  
  cpu_quota_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.cpu_quota)
}

// int64 cpu_shares = 3;
inline void LinuxContainerResources::clear_cpu_shares() {
  cpu_shares_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LinuxContainerResources::cpu_shares() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.cpu_shares)
  return cpu_shares_;
}
inline void LinuxContainerResources::set_cpu_shares(::google::protobuf::int64 value) {
  
  cpu_shares_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.cpu_shares)
}

// int64 memory_limit_in_bytes = 4;
inline void LinuxContainerResources::clear_memory_limit_in_bytes() {
  memory_limit_in_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LinuxContainerResources::memory_limit_in_bytes() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.memory_limit_in_bytes)
  return memory_limit_in_bytes_;
}
inline void LinuxContainerResources::set_memory_limit_in_bytes(::google::protobuf::int64 value) {
  
  memory_limit_in_bytes_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.memory_limit_in_bytes)
}

// int64 oom_score_adj = 5;
inline void LinuxContainerResources::clear_oom_score_adj() {
  oom_score_adj_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LinuxContainerResources::oom_score_adj() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.oom_score_adj)
  return oom_score_adj_;
}
inline void LinuxContainerResources::set_oom_score_adj(::google::protobuf::int64 value) {
  
  oom_score_adj_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.oom_score_adj)
}

// string cpuset_cpus = 6;
inline void LinuxContainerResources::clear_cpuset_cpus() {
  cpuset_cpus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxContainerResources::cpuset_cpus() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.cpuset_cpus)
  return cpuset_cpus_.GetNoArena();
}
inline void LinuxContainerResources::set_cpuset_cpus(const ::std::string& value) {
  
  cpuset_cpus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.cpuset_cpus)
}
#if LANG_CXX11
inline void LinuxContainerResources::set_cpuset_cpus(::std::string&& value) {
  
  cpuset_cpus_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxContainerResources.cpuset_cpus)
}
#endif
inline void LinuxContainerResources::set_cpuset_cpus(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpuset_cpus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxContainerResources.cpuset_cpus)
}
inline void LinuxContainerResources::set_cpuset_cpus(const char* value, size_t size) {
  
  cpuset_cpus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxContainerResources.cpuset_cpus)
}
inline ::std::string* LinuxContainerResources::mutable_cpuset_cpus() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerResources.cpuset_cpus)
  return cpuset_cpus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxContainerResources::release_cpuset_cpus() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerResources.cpuset_cpus)
  
  return cpuset_cpus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxContainerResources::set_allocated_cpuset_cpus(::std::string* cpuset_cpus) {
  if (cpuset_cpus != NULL) {
    
  } else {
    
  }
  cpuset_cpus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpuset_cpus);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerResources.cpuset_cpus)
}

// string cpuset_mems = 7;
inline void LinuxContainerResources::clear_cpuset_mems() {
  cpuset_mems_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxContainerResources::cpuset_mems() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerResources.cpuset_mems)
  return cpuset_mems_.GetNoArena();
}
inline void LinuxContainerResources::set_cpuset_mems(const ::std::string& value) {
  
  cpuset_mems_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerResources.cpuset_mems)
}
#if LANG_CXX11
inline void LinuxContainerResources::set_cpuset_mems(::std::string&& value) {
  
  cpuset_mems_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxContainerResources.cpuset_mems)
}
#endif
inline void LinuxContainerResources::set_cpuset_mems(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpuset_mems_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxContainerResources.cpuset_mems)
}
inline void LinuxContainerResources::set_cpuset_mems(const char* value, size_t size) {
  
  cpuset_mems_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxContainerResources.cpuset_mems)
}
inline ::std::string* LinuxContainerResources::mutable_cpuset_mems() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerResources.cpuset_mems)
  return cpuset_mems_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxContainerResources::release_cpuset_mems() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerResources.cpuset_mems)
  
  return cpuset_mems_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxContainerResources::set_allocated_cpuset_mems(::std::string* cpuset_mems) {
  if (cpuset_mems != NULL) {
    
  } else {
    
  }
  cpuset_mems_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpuset_mems);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerResources.cpuset_mems)
}

// -------------------------------------------------------------------

// SELinuxOption

// string user = 1;
inline void SELinuxOption::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SELinuxOption::user() const {
  // @@protoc_insertion_point(field_get:runtime.SELinuxOption.user)
  return user_.GetNoArena();
}
inline void SELinuxOption::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.SELinuxOption.user)
}
#if LANG_CXX11
inline void SELinuxOption::set_user(::std::string&& value) {
  
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.SELinuxOption.user)
}
#endif
inline void SELinuxOption::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.SELinuxOption.user)
}
inline void SELinuxOption::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.SELinuxOption.user)
}
inline ::std::string* SELinuxOption::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:runtime.SELinuxOption.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SELinuxOption::release_user() {
  // @@protoc_insertion_point(field_release:runtime.SELinuxOption.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SELinuxOption::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:runtime.SELinuxOption.user)
}

// string role = 2;
inline void SELinuxOption::clear_role() {
  role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SELinuxOption::role() const {
  // @@protoc_insertion_point(field_get:runtime.SELinuxOption.role)
  return role_.GetNoArena();
}
inline void SELinuxOption::set_role(const ::std::string& value) {
  
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.SELinuxOption.role)
}
#if LANG_CXX11
inline void SELinuxOption::set_role(::std::string&& value) {
  
  role_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.SELinuxOption.role)
}
#endif
inline void SELinuxOption::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.SELinuxOption.role)
}
inline void SELinuxOption::set_role(const char* value, size_t size) {
  
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.SELinuxOption.role)
}
inline ::std::string* SELinuxOption::mutable_role() {
  
  // @@protoc_insertion_point(field_mutable:runtime.SELinuxOption.role)
  return role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SELinuxOption::release_role() {
  // @@protoc_insertion_point(field_release:runtime.SELinuxOption.role)
  
  return role_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SELinuxOption::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    
  } else {
    
  }
  role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role);
  // @@protoc_insertion_point(field_set_allocated:runtime.SELinuxOption.role)
}

// string type = 3;
inline void SELinuxOption::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SELinuxOption::type() const {
  // @@protoc_insertion_point(field_get:runtime.SELinuxOption.type)
  return type_.GetNoArena();
}
inline void SELinuxOption::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.SELinuxOption.type)
}
#if LANG_CXX11
inline void SELinuxOption::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.SELinuxOption.type)
}
#endif
inline void SELinuxOption::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.SELinuxOption.type)
}
inline void SELinuxOption::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.SELinuxOption.type)
}
inline ::std::string* SELinuxOption::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:runtime.SELinuxOption.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SELinuxOption::release_type() {
  // @@protoc_insertion_point(field_release:runtime.SELinuxOption.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SELinuxOption::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:runtime.SELinuxOption.type)
}

// string level = 4;
inline void SELinuxOption::clear_level() {
  level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SELinuxOption::level() const {
  // @@protoc_insertion_point(field_get:runtime.SELinuxOption.level)
  return level_.GetNoArena();
}
inline void SELinuxOption::set_level(const ::std::string& value) {
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.SELinuxOption.level)
}
#if LANG_CXX11
inline void SELinuxOption::set_level(::std::string&& value) {
  
  level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.SELinuxOption.level)
}
#endif
inline void SELinuxOption::set_level(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.SELinuxOption.level)
}
inline void SELinuxOption::set_level(const char* value, size_t size) {
  
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.SELinuxOption.level)
}
inline ::std::string* SELinuxOption::mutable_level() {
  
  // @@protoc_insertion_point(field_mutable:runtime.SELinuxOption.level)
  return level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SELinuxOption::release_level() {
  // @@protoc_insertion_point(field_release:runtime.SELinuxOption.level)
  
  return level_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SELinuxOption::set_allocated_level(::std::string* level) {
  if (level != NULL) {
    
  } else {
    
  }
  level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), level);
  // @@protoc_insertion_point(field_set_allocated:runtime.SELinuxOption.level)
}

// -------------------------------------------------------------------

// Capability

// repeated string add_capabilities = 1;
inline int Capability::add_capabilities_size() const {
  return add_capabilities_.size();
}
inline void Capability::clear_add_capabilities() {
  add_capabilities_.Clear();
}
inline const ::std::string& Capability::add_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:runtime.Capability.add_capabilities)
  return add_capabilities_.Get(index);
}
inline ::std::string* Capability::mutable_add_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.Capability.add_capabilities)
  return add_capabilities_.Mutable(index);
}
inline void Capability::set_add_capabilities(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.Capability.add_capabilities)
  add_capabilities_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Capability::set_add_capabilities(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.Capability.add_capabilities)
  add_capabilities_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Capability::set_add_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  add_capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.Capability.add_capabilities)
}
inline void Capability::set_add_capabilities(int index, const char* value, size_t size) {
  add_capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.Capability.add_capabilities)
}
inline ::std::string* Capability::add_add_capabilities() {
  // @@protoc_insertion_point(field_add_mutable:runtime.Capability.add_capabilities)
  return add_capabilities_.Add();
}
inline void Capability::add_add_capabilities(const ::std::string& value) {
  add_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.Capability.add_capabilities)
}
#if LANG_CXX11
inline void Capability::add_add_capabilities(::std::string&& value) {
  add_capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.Capability.add_capabilities)
}
#endif
inline void Capability::add_add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  add_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.Capability.add_capabilities)
}
inline void Capability::add_add_capabilities(const char* value, size_t size) {
  add_capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.Capability.add_capabilities)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Capability::add_capabilities() const {
  // @@protoc_insertion_point(field_list:runtime.Capability.add_capabilities)
  return add_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Capability::mutable_add_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:runtime.Capability.add_capabilities)
  return &add_capabilities_;
}

// repeated string drop_capabilities = 2;
inline int Capability::drop_capabilities_size() const {
  return drop_capabilities_.size();
}
inline void Capability::clear_drop_capabilities() {
  drop_capabilities_.Clear();
}
inline const ::std::string& Capability::drop_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:runtime.Capability.drop_capabilities)
  return drop_capabilities_.Get(index);
}
inline ::std::string* Capability::mutable_drop_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.Capability.drop_capabilities)
  return drop_capabilities_.Mutable(index);
}
inline void Capability::set_drop_capabilities(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.Capability.drop_capabilities)
  drop_capabilities_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Capability::set_drop_capabilities(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.Capability.drop_capabilities)
  drop_capabilities_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Capability::set_drop_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  drop_capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.Capability.drop_capabilities)
}
inline void Capability::set_drop_capabilities(int index, const char* value, size_t size) {
  drop_capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.Capability.drop_capabilities)
}
inline ::std::string* Capability::add_drop_capabilities() {
  // @@protoc_insertion_point(field_add_mutable:runtime.Capability.drop_capabilities)
  return drop_capabilities_.Add();
}
inline void Capability::add_drop_capabilities(const ::std::string& value) {
  drop_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.Capability.drop_capabilities)
}
#if LANG_CXX11
inline void Capability::add_drop_capabilities(::std::string&& value) {
  drop_capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.Capability.drop_capabilities)
}
#endif
inline void Capability::add_drop_capabilities(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  drop_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.Capability.drop_capabilities)
}
inline void Capability::add_drop_capabilities(const char* value, size_t size) {
  drop_capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.Capability.drop_capabilities)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Capability::drop_capabilities() const {
  // @@protoc_insertion_point(field_list:runtime.Capability.drop_capabilities)
  return drop_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Capability::mutable_drop_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:runtime.Capability.drop_capabilities)
  return &drop_capabilities_;
}

// -------------------------------------------------------------------

// LinuxContainerSecurityContext

// .runtime.Capability capabilities = 1;
inline bool LinuxContainerSecurityContext::has_capabilities() const {
  return this != internal_default_instance() && capabilities_ != NULL;
}
inline void LinuxContainerSecurityContext::clear_capabilities() {
  if (GetArenaNoVirtual() == NULL && capabilities_ != NULL) {
    delete capabilities_;
  }
  capabilities_ = NULL;
}
inline const ::runtime::Capability& LinuxContainerSecurityContext::capabilities() const {
  const ::runtime::Capability* p = capabilities_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.capabilities)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Capability*>(
      &::runtime::_Capability_default_instance_);
}
inline ::runtime::Capability* LinuxContainerSecurityContext::release_capabilities() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.capabilities)
  
  ::runtime::Capability* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline ::runtime::Capability* LinuxContainerSecurityContext::mutable_capabilities() {
  
  if (capabilities_ == NULL) {
    capabilities_ = new ::runtime::Capability;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.capabilities)
  return capabilities_;
}
inline void LinuxContainerSecurityContext::set_allocated_capabilities(::runtime::Capability* capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capabilities_;
  }
  if (capabilities) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.capabilities)
}

// bool privileged = 2;
inline void LinuxContainerSecurityContext::clear_privileged() {
  privileged_ = false;
}
inline bool LinuxContainerSecurityContext::privileged() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.privileged)
  return privileged_;
}
inline void LinuxContainerSecurityContext::set_privileged(bool value) {
  
  privileged_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.privileged)
}

// .runtime.NamespaceOption namespace_options = 3;
inline bool LinuxContainerSecurityContext::has_namespace_options() const {
  return this != internal_default_instance() && namespace_options_ != NULL;
}
inline void LinuxContainerSecurityContext::clear_namespace_options() {
  if (GetArenaNoVirtual() == NULL && namespace_options_ != NULL) {
    delete namespace_options_;
  }
  namespace_options_ = NULL;
}
inline const ::runtime::NamespaceOption& LinuxContainerSecurityContext::namespace_options() const {
  const ::runtime::NamespaceOption* p = namespace_options_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.namespace_options)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::NamespaceOption*>(
      &::runtime::_NamespaceOption_default_instance_);
}
inline ::runtime::NamespaceOption* LinuxContainerSecurityContext::release_namespace_options() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.namespace_options)
  
  ::runtime::NamespaceOption* temp = namespace_options_;
  namespace_options_ = NULL;
  return temp;
}
inline ::runtime::NamespaceOption* LinuxContainerSecurityContext::mutable_namespace_options() {
  
  if (namespace_options_ == NULL) {
    namespace_options_ = new ::runtime::NamespaceOption;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.namespace_options)
  return namespace_options_;
}
inline void LinuxContainerSecurityContext::set_allocated_namespace_options(::runtime::NamespaceOption* namespace_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete namespace_options_;
  }
  if (namespace_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      namespace_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, namespace_options, submessage_arena);
    }
    
  } else {
    
  }
  namespace_options_ = namespace_options;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.namespace_options)
}

// .runtime.SELinuxOption selinux_options = 4;
inline bool LinuxContainerSecurityContext::has_selinux_options() const {
  return this != internal_default_instance() && selinux_options_ != NULL;
}
inline void LinuxContainerSecurityContext::clear_selinux_options() {
  if (GetArenaNoVirtual() == NULL && selinux_options_ != NULL) {
    delete selinux_options_;
  }
  selinux_options_ = NULL;
}
inline const ::runtime::SELinuxOption& LinuxContainerSecurityContext::selinux_options() const {
  const ::runtime::SELinuxOption* p = selinux_options_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.selinux_options)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::SELinuxOption*>(
      &::runtime::_SELinuxOption_default_instance_);
}
inline ::runtime::SELinuxOption* LinuxContainerSecurityContext::release_selinux_options() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.selinux_options)
  
  ::runtime::SELinuxOption* temp = selinux_options_;
  selinux_options_ = NULL;
  return temp;
}
inline ::runtime::SELinuxOption* LinuxContainerSecurityContext::mutable_selinux_options() {
  
  if (selinux_options_ == NULL) {
    selinux_options_ = new ::runtime::SELinuxOption;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.selinux_options)
  return selinux_options_;
}
inline void LinuxContainerSecurityContext::set_allocated_selinux_options(::runtime::SELinuxOption* selinux_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete selinux_options_;
  }
  if (selinux_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selinux_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selinux_options, submessage_arena);
    }
    
  } else {
    
  }
  selinux_options_ = selinux_options;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.selinux_options)
}

// .runtime.Int64Value run_as_user = 5;
inline bool LinuxContainerSecurityContext::has_run_as_user() const {
  return this != internal_default_instance() && run_as_user_ != NULL;
}
inline void LinuxContainerSecurityContext::clear_run_as_user() {
  if (GetArenaNoVirtual() == NULL && run_as_user_ != NULL) {
    delete run_as_user_;
  }
  run_as_user_ = NULL;
}
inline const ::runtime::Int64Value& LinuxContainerSecurityContext::run_as_user() const {
  const ::runtime::Int64Value* p = run_as_user_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.run_as_user)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Int64Value*>(
      &::runtime::_Int64Value_default_instance_);
}
inline ::runtime::Int64Value* LinuxContainerSecurityContext::release_run_as_user() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.run_as_user)
  
  ::runtime::Int64Value* temp = run_as_user_;
  run_as_user_ = NULL;
  return temp;
}
inline ::runtime::Int64Value* LinuxContainerSecurityContext::mutable_run_as_user() {
  
  if (run_as_user_ == NULL) {
    run_as_user_ = new ::runtime::Int64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.run_as_user)
  return run_as_user_;
}
inline void LinuxContainerSecurityContext::set_allocated_run_as_user(::runtime::Int64Value* run_as_user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_as_user_;
  }
  if (run_as_user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run_as_user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run_as_user, submessage_arena);
    }
    
  } else {
    
  }
  run_as_user_ = run_as_user;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.run_as_user)
}

// string run_as_username = 6;
inline void LinuxContainerSecurityContext::clear_run_as_username() {
  run_as_username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxContainerSecurityContext::run_as_username() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.run_as_username)
  return run_as_username_.GetNoArena();
}
inline void LinuxContainerSecurityContext::set_run_as_username(const ::std::string& value) {
  
  run_as_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.run_as_username)
}
#if LANG_CXX11
inline void LinuxContainerSecurityContext::set_run_as_username(::std::string&& value) {
  
  run_as_username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxContainerSecurityContext.run_as_username)
}
#endif
inline void LinuxContainerSecurityContext::set_run_as_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  run_as_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxContainerSecurityContext.run_as_username)
}
inline void LinuxContainerSecurityContext::set_run_as_username(const char* value, size_t size) {
  
  run_as_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxContainerSecurityContext.run_as_username)
}
inline ::std::string* LinuxContainerSecurityContext::mutable_run_as_username() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.run_as_username)
  return run_as_username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxContainerSecurityContext::release_run_as_username() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.run_as_username)
  
  return run_as_username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxContainerSecurityContext::set_allocated_run_as_username(::std::string* run_as_username) {
  if (run_as_username != NULL) {
    
  } else {
    
  }
  run_as_username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_as_username);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.run_as_username)
}

// bool readonly_rootfs = 7;
inline void LinuxContainerSecurityContext::clear_readonly_rootfs() {
  readonly_rootfs_ = false;
}
inline bool LinuxContainerSecurityContext::readonly_rootfs() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.readonly_rootfs)
  return readonly_rootfs_;
}
inline void LinuxContainerSecurityContext::set_readonly_rootfs(bool value) {
  
  readonly_rootfs_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.readonly_rootfs)
}

// repeated int64 supplemental_groups = 8;
inline int LinuxContainerSecurityContext::supplemental_groups_size() const {
  return supplemental_groups_.size();
}
inline void LinuxContainerSecurityContext::clear_supplemental_groups() {
  supplemental_groups_.Clear();
}
inline ::google::protobuf::int64 LinuxContainerSecurityContext::supplemental_groups(int index) const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.supplemental_groups)
  return supplemental_groups_.Get(index);
}
inline void LinuxContainerSecurityContext::set_supplemental_groups(int index, ::google::protobuf::int64 value) {
  supplemental_groups_.Set(index, value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.supplemental_groups)
}
inline void LinuxContainerSecurityContext::add_supplemental_groups(::google::protobuf::int64 value) {
  supplemental_groups_.Add(value);
  // @@protoc_insertion_point(field_add:runtime.LinuxContainerSecurityContext.supplemental_groups)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LinuxContainerSecurityContext::supplemental_groups() const {
  // @@protoc_insertion_point(field_list:runtime.LinuxContainerSecurityContext.supplemental_groups)
  return supplemental_groups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LinuxContainerSecurityContext::mutable_supplemental_groups() {
  // @@protoc_insertion_point(field_mutable_list:runtime.LinuxContainerSecurityContext.supplemental_groups)
  return &supplemental_groups_;
}

// string apparmor_profile = 9;
inline void LinuxContainerSecurityContext::clear_apparmor_profile() {
  apparmor_profile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxContainerSecurityContext::apparmor_profile() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.apparmor_profile)
  return apparmor_profile_.GetNoArena();
}
inline void LinuxContainerSecurityContext::set_apparmor_profile(const ::std::string& value) {
  
  apparmor_profile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.apparmor_profile)
}
#if LANG_CXX11
inline void LinuxContainerSecurityContext::set_apparmor_profile(::std::string&& value) {
  
  apparmor_profile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxContainerSecurityContext.apparmor_profile)
}
#endif
inline void LinuxContainerSecurityContext::set_apparmor_profile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  apparmor_profile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxContainerSecurityContext.apparmor_profile)
}
inline void LinuxContainerSecurityContext::set_apparmor_profile(const char* value, size_t size) {
  
  apparmor_profile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxContainerSecurityContext.apparmor_profile)
}
inline ::std::string* LinuxContainerSecurityContext::mutable_apparmor_profile() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.apparmor_profile)
  return apparmor_profile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxContainerSecurityContext::release_apparmor_profile() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.apparmor_profile)
  
  return apparmor_profile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxContainerSecurityContext::set_allocated_apparmor_profile(::std::string* apparmor_profile) {
  if (apparmor_profile != NULL) {
    
  } else {
    
  }
  apparmor_profile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apparmor_profile);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.apparmor_profile)
}

// string seccomp_profile_path = 10;
inline void LinuxContainerSecurityContext::clear_seccomp_profile_path() {
  seccomp_profile_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LinuxContainerSecurityContext::seccomp_profile_path() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
  return seccomp_profile_path_.GetNoArena();
}
inline void LinuxContainerSecurityContext::set_seccomp_profile_path(const ::std::string& value) {
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
}
#if LANG_CXX11
inline void LinuxContainerSecurityContext::set_seccomp_profile_path(::std::string&& value) {
  
  seccomp_profile_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
}
#endif
inline void LinuxContainerSecurityContext::set_seccomp_profile_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
}
inline void LinuxContainerSecurityContext::set_seccomp_profile_path(const char* value, size_t size) {
  
  seccomp_profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
}
inline ::std::string* LinuxContainerSecurityContext::mutable_seccomp_profile_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
  return seccomp_profile_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinuxContainerSecurityContext::release_seccomp_profile_path() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
  
  return seccomp_profile_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinuxContainerSecurityContext::set_allocated_seccomp_profile_path(::std::string* seccomp_profile_path) {
  if (seccomp_profile_path != NULL) {
    
  } else {
    
  }
  seccomp_profile_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seccomp_profile_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerSecurityContext.seccomp_profile_path)
}

// bool no_new_privs = 11;
inline void LinuxContainerSecurityContext::clear_no_new_privs() {
  no_new_privs_ = false;
}
inline bool LinuxContainerSecurityContext::no_new_privs() const {
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerSecurityContext.no_new_privs)
  return no_new_privs_;
}
inline void LinuxContainerSecurityContext::set_no_new_privs(bool value) {
  
  no_new_privs_ = value;
  // @@protoc_insertion_point(field_set:runtime.LinuxContainerSecurityContext.no_new_privs)
}

// -------------------------------------------------------------------

// LinuxContainerConfig

// .runtime.LinuxContainerResources resources = 1;
inline bool LinuxContainerConfig::has_resources() const {
  return this != internal_default_instance() && resources_ != NULL;
}
inline void LinuxContainerConfig::clear_resources() {
  if (GetArenaNoVirtual() == NULL && resources_ != NULL) {
    delete resources_;
  }
  resources_ = NULL;
}
inline const ::runtime::LinuxContainerResources& LinuxContainerConfig::resources() const {
  const ::runtime::LinuxContainerResources* p = resources_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerConfig.resources)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxContainerResources*>(
      &::runtime::_LinuxContainerResources_default_instance_);
}
inline ::runtime::LinuxContainerResources* LinuxContainerConfig::release_resources() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerConfig.resources)
  
  ::runtime::LinuxContainerResources* temp = resources_;
  resources_ = NULL;
  return temp;
}
inline ::runtime::LinuxContainerResources* LinuxContainerConfig::mutable_resources() {
  
  if (resources_ == NULL) {
    resources_ = new ::runtime::LinuxContainerResources;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerConfig.resources)
  return resources_;
}
inline void LinuxContainerConfig::set_allocated_resources(::runtime::LinuxContainerResources* resources) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resources_;
  }
  if (resources) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resources = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerConfig.resources)
}

// .runtime.LinuxContainerSecurityContext security_context = 2;
inline bool LinuxContainerConfig::has_security_context() const {
  return this != internal_default_instance() && security_context_ != NULL;
}
inline void LinuxContainerConfig::clear_security_context() {
  if (GetArenaNoVirtual() == NULL && security_context_ != NULL) {
    delete security_context_;
  }
  security_context_ = NULL;
}
inline const ::runtime::LinuxContainerSecurityContext& LinuxContainerConfig::security_context() const {
  const ::runtime::LinuxContainerSecurityContext* p = security_context_;
  // @@protoc_insertion_point(field_get:runtime.LinuxContainerConfig.security_context)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxContainerSecurityContext*>(
      &::runtime::_LinuxContainerSecurityContext_default_instance_);
}
inline ::runtime::LinuxContainerSecurityContext* LinuxContainerConfig::release_security_context() {
  // @@protoc_insertion_point(field_release:runtime.LinuxContainerConfig.security_context)
  
  ::runtime::LinuxContainerSecurityContext* temp = security_context_;
  security_context_ = NULL;
  return temp;
}
inline ::runtime::LinuxContainerSecurityContext* LinuxContainerConfig::mutable_security_context() {
  
  if (security_context_ == NULL) {
    security_context_ = new ::runtime::LinuxContainerSecurityContext;
  }
  // @@protoc_insertion_point(field_mutable:runtime.LinuxContainerConfig.security_context)
  return security_context_;
}
inline void LinuxContainerConfig::set_allocated_security_context(::runtime::LinuxContainerSecurityContext* security_context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete security_context_;
  }
  if (security_context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      security_context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, security_context, submessage_arena);
    }
    
  } else {
    
  }
  security_context_ = security_context;
  // @@protoc_insertion_point(field_set_allocated:runtime.LinuxContainerConfig.security_context)
}

// -------------------------------------------------------------------

// ContainerMetadata

// string name = 1;
inline void ContainerMetadata::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerMetadata::name() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerMetadata.name)
  return name_.GetNoArena();
}
inline void ContainerMetadata::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerMetadata.name)
}
#if LANG_CXX11
inline void ContainerMetadata::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerMetadata.name)
}
#endif
inline void ContainerMetadata::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerMetadata.name)
}
inline void ContainerMetadata::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerMetadata.name)
}
inline ::std::string* ContainerMetadata::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerMetadata.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerMetadata::release_name() {
  // @@protoc_insertion_point(field_release:runtime.ContainerMetadata.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerMetadata::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerMetadata.name)
}

// uint32 attempt = 2;
inline void ContainerMetadata::clear_attempt() {
  attempt_ = 0u;
}
inline ::google::protobuf::uint32 ContainerMetadata::attempt() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerMetadata.attempt)
  return attempt_;
}
inline void ContainerMetadata::set_attempt(::google::protobuf::uint32 value) {
  
  attempt_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerMetadata.attempt)
}

// -------------------------------------------------------------------

// Device

// string container_path = 1;
inline void Device::clear_container_path() {
  container_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Device::container_path() const {
  // @@protoc_insertion_point(field_get:runtime.Device.container_path)
  return container_path_.GetNoArena();
}
inline void Device::set_container_path(const ::std::string& value) {
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Device.container_path)
}
#if LANG_CXX11
inline void Device::set_container_path(::std::string&& value) {
  
  container_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Device.container_path)
}
#endif
inline void Device::set_container_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Device.container_path)
}
inline void Device::set_container_path(const char* value, size_t size) {
  
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Device.container_path)
}
inline ::std::string* Device::mutable_container_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Device.container_path)
  return container_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Device::release_container_path() {
  // @@protoc_insertion_point(field_release:runtime.Device.container_path)
  
  return container_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_container_path(::std::string* container_path) {
  if (container_path != NULL) {
    
  } else {
    
  }
  container_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.Device.container_path)
}

// string host_path = 2;
inline void Device::clear_host_path() {
  host_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Device::host_path() const {
  // @@protoc_insertion_point(field_get:runtime.Device.host_path)
  return host_path_.GetNoArena();
}
inline void Device::set_host_path(const ::std::string& value) {
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Device.host_path)
}
#if LANG_CXX11
inline void Device::set_host_path(::std::string&& value) {
  
  host_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Device.host_path)
}
#endif
inline void Device::set_host_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Device.host_path)
}
inline void Device::set_host_path(const char* value, size_t size) {
  
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Device.host_path)
}
inline ::std::string* Device::mutable_host_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Device.host_path)
  return host_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Device::release_host_path() {
  // @@protoc_insertion_point(field_release:runtime.Device.host_path)
  
  return host_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_host_path(::std::string* host_path) {
  if (host_path != NULL) {
    
  } else {
    
  }
  host_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.Device.host_path)
}

// string permissions = 3;
inline void Device::clear_permissions() {
  permissions_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Device::permissions() const {
  // @@protoc_insertion_point(field_get:runtime.Device.permissions)
  return permissions_.GetNoArena();
}
inline void Device::set_permissions(const ::std::string& value) {
  
  permissions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Device.permissions)
}
#if LANG_CXX11
inline void Device::set_permissions(::std::string&& value) {
  
  permissions_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Device.permissions)
}
#endif
inline void Device::set_permissions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  permissions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Device.permissions)
}
inline void Device::set_permissions(const char* value, size_t size) {
  
  permissions_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Device.permissions)
}
inline ::std::string* Device::mutable_permissions() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Device.permissions)
  return permissions_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Device::release_permissions() {
  // @@protoc_insertion_point(field_release:runtime.Device.permissions)
  
  return permissions_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Device::set_allocated_permissions(::std::string* permissions) {
  if (permissions != NULL) {
    
  } else {
    
  }
  permissions_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), permissions);
  // @@protoc_insertion_point(field_set_allocated:runtime.Device.permissions)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerConfig

// .runtime.ContainerMetadata metadata = 1;
inline bool ContainerConfig::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void ContainerConfig::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::ContainerMetadata& ContainerConfig::metadata() const {
  const ::runtime::ContainerMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerMetadata*>(
      &::runtime::_ContainerMetadata_default_instance_);
}
inline ::runtime::ContainerMetadata* ContainerConfig::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.ContainerConfig.metadata)
  
  ::runtime::ContainerMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::ContainerMetadata* ContainerConfig::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::ContainerMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.metadata)
  return metadata_;
}
inline void ContainerConfig::set_allocated_metadata(::runtime::ContainerMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerConfig.metadata)
}

// .runtime.ImageSpec image = 2;
inline bool ContainerConfig::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ContainerConfig::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& ContainerConfig::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* ContainerConfig::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ContainerConfig.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* ContainerConfig::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.image)
  return image_;
}
inline void ContainerConfig::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerConfig.image)
}

// repeated string command = 3;
inline int ContainerConfig::command_size() const {
  return command_.size();
}
inline void ContainerConfig::clear_command() {
  command_.Clear();
}
inline const ::std::string& ContainerConfig::command(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.command)
  return command_.Get(index);
}
inline ::std::string* ContainerConfig::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.command)
  return command_.Mutable(index);
}
inline void ContainerConfig::set_command(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.command)
  command_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ContainerConfig::set_command(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.command)
  command_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ContainerConfig::set_command(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.ContainerConfig.command)
}
inline void ContainerConfig::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerConfig.command)
}
inline ::std::string* ContainerConfig::add_command() {
  // @@protoc_insertion_point(field_add_mutable:runtime.ContainerConfig.command)
  return command_.Add();
}
inline void ContainerConfig::add_command(const ::std::string& value) {
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.command)
}
#if LANG_CXX11
inline void ContainerConfig::add_command(::std::string&& value) {
  command_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.command)
}
#endif
inline void ContainerConfig::add_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.ContainerConfig.command)
}
inline void ContainerConfig::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.ContainerConfig.command)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ContainerConfig::command() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerConfig.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ContainerConfig::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerConfig.command)
  return &command_;
}

// repeated string args = 4;
inline int ContainerConfig::args_size() const {
  return args_.size();
}
inline void ContainerConfig::clear_args() {
  args_.Clear();
}
inline const ::std::string& ContainerConfig::args(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.args)
  return args_.Get(index);
}
inline ::std::string* ContainerConfig::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.args)
  return args_.Mutable(index);
}
inline void ContainerConfig::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.args)
  args_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ContainerConfig::set_args(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.args)
  args_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ContainerConfig::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.ContainerConfig.args)
}
inline void ContainerConfig::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerConfig.args)
}
inline ::std::string* ContainerConfig::add_args() {
  // @@protoc_insertion_point(field_add_mutable:runtime.ContainerConfig.args)
  return args_.Add();
}
inline void ContainerConfig::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.args)
}
#if LANG_CXX11
inline void ContainerConfig::add_args(::std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.args)
}
#endif
inline void ContainerConfig::add_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.ContainerConfig.args)
}
inline void ContainerConfig::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.ContainerConfig.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ContainerConfig::args() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerConfig.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ContainerConfig::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerConfig.args)
  return &args_;
}

// string working_dir = 5;
inline void ContainerConfig::clear_working_dir() {
  working_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerConfig::working_dir() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.working_dir)
  return working_dir_.GetNoArena();
}
inline void ContainerConfig::set_working_dir(const ::std::string& value) {
  
  working_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.working_dir)
}
#if LANG_CXX11
inline void ContainerConfig::set_working_dir(::std::string&& value) {
  
  working_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerConfig.working_dir)
}
#endif
inline void ContainerConfig::set_working_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  working_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerConfig.working_dir)
}
inline void ContainerConfig::set_working_dir(const char* value, size_t size) {
  
  working_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerConfig.working_dir)
}
inline ::std::string* ContainerConfig::mutable_working_dir() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.working_dir)
  return working_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerConfig::release_working_dir() {
  // @@protoc_insertion_point(field_release:runtime.ContainerConfig.working_dir)
  
  return working_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerConfig::set_allocated_working_dir(::std::string* working_dir) {
  if (working_dir != NULL) {
    
  } else {
    
  }
  working_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_dir);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerConfig.working_dir)
}

// repeated .runtime.KeyValue envs = 6;
inline int ContainerConfig::envs_size() const {
  return envs_.size();
}
inline void ContainerConfig::clear_envs() {
  envs_.Clear();
}
inline const ::runtime::KeyValue& ContainerConfig::envs(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.envs)
  return envs_.Get(index);
}
inline ::runtime::KeyValue* ContainerConfig::mutable_envs(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.envs)
  return envs_.Mutable(index);
}
inline ::runtime::KeyValue* ContainerConfig::add_envs() {
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.envs)
  return envs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::KeyValue >*
ContainerConfig::mutable_envs() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerConfig.envs)
  return &envs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::KeyValue >&
ContainerConfig::envs() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerConfig.envs)
  return envs_;
}

// repeated .runtime.Mount mounts = 7;
inline int ContainerConfig::mounts_size() const {
  return mounts_.size();
}
inline void ContainerConfig::clear_mounts() {
  mounts_.Clear();
}
inline const ::runtime::Mount& ContainerConfig::mounts(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.mounts)
  return mounts_.Get(index);
}
inline ::runtime::Mount* ContainerConfig::mutable_mounts(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.mounts)
  return mounts_.Mutable(index);
}
inline ::runtime::Mount* ContainerConfig::add_mounts() {
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.mounts)
  return mounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::Mount >*
ContainerConfig::mutable_mounts() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerConfig.mounts)
  return &mounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::Mount >&
ContainerConfig::mounts() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerConfig.mounts)
  return mounts_;
}

// repeated .runtime.Device devices = 8;
inline int ContainerConfig::devices_size() const {
  return devices_.size();
}
inline void ContainerConfig::clear_devices() {
  devices_.Clear();
}
inline const ::runtime::Device& ContainerConfig::devices(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.devices)
  return devices_.Get(index);
}
inline ::runtime::Device* ContainerConfig::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.devices)
  return devices_.Mutable(index);
}
inline ::runtime::Device* ContainerConfig::add_devices() {
  // @@protoc_insertion_point(field_add:runtime.ContainerConfig.devices)
  return devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::Device >*
ContainerConfig::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerConfig.devices)
  return &devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::Device >&
ContainerConfig::devices() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerConfig.devices)
  return devices_;
}

// map<string, string> labels = 9;
inline int ContainerConfig::labels_size() const {
  return labels_.size();
}
inline void ContainerConfig::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerConfig::labels() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerConfig.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerConfig::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerConfig.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 10;
inline int ContainerConfig::annotations_size() const {
  return annotations_.size();
}
inline void ContainerConfig::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerConfig::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerConfig.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerConfig::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerConfig.annotations)
  return annotations_.MutableMap();
}

// string log_path = 11;
inline void ContainerConfig::clear_log_path() {
  log_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerConfig::log_path() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.log_path)
  return log_path_.GetNoArena();
}
inline void ContainerConfig::set_log_path(const ::std::string& value) {
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.log_path)
}
#if LANG_CXX11
inline void ContainerConfig::set_log_path(::std::string&& value) {
  
  log_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerConfig.log_path)
}
#endif
inline void ContainerConfig::set_log_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerConfig.log_path)
}
inline void ContainerConfig::set_log_path(const char* value, size_t size) {
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerConfig.log_path)
}
inline ::std::string* ContainerConfig::mutable_log_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.log_path)
  return log_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerConfig::release_log_path() {
  // @@protoc_insertion_point(field_release:runtime.ContainerConfig.log_path)
  
  return log_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerConfig::set_allocated_log_path(::std::string* log_path) {
  if (log_path != NULL) {
    
  } else {
    
  }
  log_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerConfig.log_path)
}

// bool stdin = 12;
inline void ContainerConfig::clear_stdin() {
  stdin_ = false;
}
inline bool ContainerConfig::stdin() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.stdin)
  return stdin_;
}
inline void ContainerConfig::set_stdin(bool value) {
  
  stdin_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.stdin)
}

// bool stdin_once = 13;
inline void ContainerConfig::clear_stdin_once() {
  stdin_once_ = false;
}
inline bool ContainerConfig::stdin_once() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.stdin_once)
  return stdin_once_;
}
inline void ContainerConfig::set_stdin_once(bool value) {
  
  stdin_once_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.stdin_once)
}

// bool tty = 14;
inline void ContainerConfig::clear_tty() {
  tty_ = false;
}
inline bool ContainerConfig::tty() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.tty)
  return tty_;
}
inline void ContainerConfig::set_tty(bool value) {
  
  tty_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerConfig.tty)
}

// .runtime.LinuxContainerConfig linux = 15;
inline bool ContainerConfig::has_linux() const {
  return this != internal_default_instance() && linux_ != NULL;
}
inline void ContainerConfig::clear_linux() {
  if (GetArenaNoVirtual() == NULL && linux_ != NULL) {
    delete linux_;
  }
  linux_ = NULL;
}
inline const ::runtime::LinuxContainerConfig& ContainerConfig::linux() const {
  const ::runtime::LinuxContainerConfig* p = linux_;
  // @@protoc_insertion_point(field_get:runtime.ContainerConfig.linux)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxContainerConfig*>(
      &::runtime::_LinuxContainerConfig_default_instance_);
}
inline ::runtime::LinuxContainerConfig* ContainerConfig::release_linux() {
  // @@protoc_insertion_point(field_release:runtime.ContainerConfig.linux)
  
  ::runtime::LinuxContainerConfig* temp = linux_;
  linux_ = NULL;
  return temp;
}
inline ::runtime::LinuxContainerConfig* ContainerConfig::mutable_linux() {
  
  if (linux_ == NULL) {
    linux_ = new ::runtime::LinuxContainerConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerConfig.linux)
  return linux_;
}
inline void ContainerConfig::set_allocated_linux(::runtime::LinuxContainerConfig* linux) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linux_;
  }
  if (linux) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linux = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linux, submessage_arena);
    }
    
  } else {
    
  }
  linux_ = linux;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerConfig.linux)
}

// -------------------------------------------------------------------

// CreateContainerRequest

// string pod_sandbox_id = 1;
inline void CreateContainerRequest::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerRequest::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.CreateContainerRequest.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void CreateContainerRequest::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.CreateContainerRequest.pod_sandbox_id)
}
#if LANG_CXX11
inline void CreateContainerRequest::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.CreateContainerRequest.pod_sandbox_id)
}
#endif
inline void CreateContainerRequest::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.CreateContainerRequest.pod_sandbox_id)
}
inline void CreateContainerRequest::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.CreateContainerRequest.pod_sandbox_id)
}
inline ::std::string* CreateContainerRequest::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.CreateContainerRequest.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerRequest::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.CreateContainerRequest.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerRequest::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.CreateContainerRequest.pod_sandbox_id)
}

// .runtime.ContainerConfig config = 2;
inline bool CreateContainerRequest::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void CreateContainerRequest::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::runtime::ContainerConfig& CreateContainerRequest::config() const {
  const ::runtime::ContainerConfig* p = config_;
  // @@protoc_insertion_point(field_get:runtime.CreateContainerRequest.config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerConfig*>(
      &::runtime::_ContainerConfig_default_instance_);
}
inline ::runtime::ContainerConfig* CreateContainerRequest::release_config() {
  // @@protoc_insertion_point(field_release:runtime.CreateContainerRequest.config)
  
  ::runtime::ContainerConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::runtime::ContainerConfig* CreateContainerRequest::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::runtime::ContainerConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.CreateContainerRequest.config)
  return config_;
}
inline void CreateContainerRequest::set_allocated_config(::runtime::ContainerConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:runtime.CreateContainerRequest.config)
}

// .runtime.PodSandboxConfig sandbox_config = 3;
inline bool CreateContainerRequest::has_sandbox_config() const {
  return this != internal_default_instance() && sandbox_config_ != NULL;
}
inline void CreateContainerRequest::clear_sandbox_config() {
  if (GetArenaNoVirtual() == NULL && sandbox_config_ != NULL) {
    delete sandbox_config_;
  }
  sandbox_config_ = NULL;
}
inline const ::runtime::PodSandboxConfig& CreateContainerRequest::sandbox_config() const {
  const ::runtime::PodSandboxConfig* p = sandbox_config_;
  // @@protoc_insertion_point(field_get:runtime.CreateContainerRequest.sandbox_config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxConfig*>(
      &::runtime::_PodSandboxConfig_default_instance_);
}
inline ::runtime::PodSandboxConfig* CreateContainerRequest::release_sandbox_config() {
  // @@protoc_insertion_point(field_release:runtime.CreateContainerRequest.sandbox_config)
  
  ::runtime::PodSandboxConfig* temp = sandbox_config_;
  sandbox_config_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxConfig* CreateContainerRequest::mutable_sandbox_config() {
  
  if (sandbox_config_ == NULL) {
    sandbox_config_ = new ::runtime::PodSandboxConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.CreateContainerRequest.sandbox_config)
  return sandbox_config_;
}
inline void CreateContainerRequest::set_allocated_sandbox_config(::runtime::PodSandboxConfig* sandbox_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sandbox_config_;
  }
  if (sandbox_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sandbox_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sandbox_config, submessage_arena);
    }
    
  } else {
    
  }
  sandbox_config_ = sandbox_config;
  // @@protoc_insertion_point(field_set_allocated:runtime.CreateContainerRequest.sandbox_config)
}

// -------------------------------------------------------------------

// CreateContainerResponse

// string container_id = 1;
inline void CreateContainerResponse::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateContainerResponse::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.CreateContainerResponse.container_id)
  return container_id_.GetNoArena();
}
inline void CreateContainerResponse::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.CreateContainerResponse.container_id)
}
#if LANG_CXX11
inline void CreateContainerResponse::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.CreateContainerResponse.container_id)
}
#endif
inline void CreateContainerResponse::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.CreateContainerResponse.container_id)
}
inline void CreateContainerResponse::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.CreateContainerResponse.container_id)
}
inline ::std::string* CreateContainerResponse::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.CreateContainerResponse.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateContainerResponse::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.CreateContainerResponse.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateContainerResponse::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.CreateContainerResponse.container_id)
}

// -------------------------------------------------------------------

// StartContainerRequest

// string container_id = 1;
inline void StartContainerRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartContainerRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.StartContainerRequest.container_id)
  return container_id_.GetNoArena();
}
inline void StartContainerRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.StartContainerRequest.container_id)
}
#if LANG_CXX11
inline void StartContainerRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.StartContainerRequest.container_id)
}
#endif
inline void StartContainerRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.StartContainerRequest.container_id)
}
inline void StartContainerRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.StartContainerRequest.container_id)
}
inline ::std::string* StartContainerRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.StartContainerRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartContainerRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.StartContainerRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartContainerRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.StartContainerRequest.container_id)
}

// -------------------------------------------------------------------

// StartContainerResponse

// -------------------------------------------------------------------

// StopContainerRequest

// string container_id = 1;
inline void StopContainerRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StopContainerRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.StopContainerRequest.container_id)
  return container_id_.GetNoArena();
}
inline void StopContainerRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.StopContainerRequest.container_id)
}
#if LANG_CXX11
inline void StopContainerRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.StopContainerRequest.container_id)
}
#endif
inline void StopContainerRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.StopContainerRequest.container_id)
}
inline void StopContainerRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.StopContainerRequest.container_id)
}
inline ::std::string* StopContainerRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.StopContainerRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopContainerRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.StopContainerRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopContainerRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.StopContainerRequest.container_id)
}

// int64 timeout = 2;
inline void StopContainerRequest::clear_timeout() {
  timeout_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StopContainerRequest::timeout() const {
  // @@protoc_insertion_point(field_get:runtime.StopContainerRequest.timeout)
  return timeout_;
}
inline void StopContainerRequest::set_timeout(::google::protobuf::int64 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:runtime.StopContainerRequest.timeout)
}

// -------------------------------------------------------------------

// StopContainerResponse

// -------------------------------------------------------------------

// RemoveContainerRequest

// string container_id = 1;
inline void RemoveContainerRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RemoveContainerRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.RemoveContainerRequest.container_id)
  return container_id_.GetNoArena();
}
inline void RemoveContainerRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RemoveContainerRequest.container_id)
}
#if LANG_CXX11
inline void RemoveContainerRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RemoveContainerRequest.container_id)
}
#endif
inline void RemoveContainerRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RemoveContainerRequest.container_id)
}
inline void RemoveContainerRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RemoveContainerRequest.container_id)
}
inline ::std::string* RemoveContainerRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RemoveContainerRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoveContainerRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.RemoveContainerRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoveContainerRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.RemoveContainerRequest.container_id)
}

// -------------------------------------------------------------------

// RemoveContainerResponse

// -------------------------------------------------------------------

// ContainerStateValue

// .runtime.ContainerState state = 1;
inline void ContainerStateValue::clear_state() {
  state_ = 0;
}
inline ::runtime::ContainerState ContainerStateValue::state() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStateValue.state)
  return static_cast< ::runtime::ContainerState >(state_);
}
inline void ContainerStateValue::set_state(::runtime::ContainerState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStateValue.state)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerFilter

// string id = 1;
inline void ContainerFilter::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerFilter::id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerFilter.id)
  return id_.GetNoArena();
}
inline void ContainerFilter::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerFilter.id)
}
#if LANG_CXX11
inline void ContainerFilter::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerFilter.id)
}
#endif
inline void ContainerFilter::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerFilter.id)
}
inline void ContainerFilter::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerFilter.id)
}
inline ::std::string* ContainerFilter::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerFilter.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerFilter::release_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerFilter.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerFilter::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerFilter.id)
}

// .runtime.ContainerStateValue state = 2;
inline bool ContainerFilter::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void ContainerFilter::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::runtime::ContainerStateValue& ContainerFilter::state() const {
  const ::runtime::ContainerStateValue* p = state_;
  // @@protoc_insertion_point(field_get:runtime.ContainerFilter.state)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerStateValue*>(
      &::runtime::_ContainerStateValue_default_instance_);
}
inline ::runtime::ContainerStateValue* ContainerFilter::release_state() {
  // @@protoc_insertion_point(field_release:runtime.ContainerFilter.state)
  
  ::runtime::ContainerStateValue* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::runtime::ContainerStateValue* ContainerFilter::mutable_state() {
  
  if (state_ == NULL) {
    state_ = new ::runtime::ContainerStateValue;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerFilter.state)
  return state_;
}
inline void ContainerFilter::set_allocated_state(::runtime::ContainerStateValue* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerFilter.state)
}

// string pod_sandbox_id = 3;
inline void ContainerFilter::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerFilter::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerFilter.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void ContainerFilter::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerFilter.pod_sandbox_id)
}
#if LANG_CXX11
inline void ContainerFilter::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerFilter.pod_sandbox_id)
}
#endif
inline void ContainerFilter::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerFilter.pod_sandbox_id)
}
inline void ContainerFilter::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerFilter.pod_sandbox_id)
}
inline ::std::string* ContainerFilter::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerFilter.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerFilter::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerFilter.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerFilter::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerFilter.pod_sandbox_id)
}

// map<string, string> label_selector = 4;
inline int ContainerFilter::label_selector_size() const {
  return label_selector_.size();
}
inline void ContainerFilter::clear_label_selector() {
  label_selector_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerFilter::label_selector() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerFilter.label_selector)
  return label_selector_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerFilter::mutable_label_selector() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerFilter.label_selector)
  return label_selector_.MutableMap();
}

// -------------------------------------------------------------------

// ListContainersRequest

// .runtime.ContainerFilter filter = 1;
inline bool ListContainersRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void ListContainersRequest::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::runtime::ContainerFilter& ListContainersRequest::filter() const {
  const ::runtime::ContainerFilter* p = filter_;
  // @@protoc_insertion_point(field_get:runtime.ListContainersRequest.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerFilter*>(
      &::runtime::_ContainerFilter_default_instance_);
}
inline ::runtime::ContainerFilter* ListContainersRequest::release_filter() {
  // @@protoc_insertion_point(field_release:runtime.ListContainersRequest.filter)
  
  ::runtime::ContainerFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::runtime::ContainerFilter* ListContainersRequest::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::runtime::ContainerFilter;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ListContainersRequest.filter)
  return filter_;
}
inline void ListContainersRequest::set_allocated_filter(::runtime::ContainerFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:runtime.ListContainersRequest.filter)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Container

// string id = 1;
inline void Container::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::id() const {
  // @@protoc_insertion_point(field_get:runtime.Container.id)
  return id_.GetNoArena();
}
inline void Container::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Container.id)
}
#if LANG_CXX11
inline void Container::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Container.id)
}
#endif
inline void Container::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Container.id)
}
inline void Container::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Container.id)
}
inline ::std::string* Container::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Container.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_id() {
  // @@protoc_insertion_point(field_release:runtime.Container.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.Container.id)
}

// string pod_sandbox_id = 2;
inline void Container::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.Container.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void Container::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Container.pod_sandbox_id)
}
#if LANG_CXX11
inline void Container::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Container.pod_sandbox_id)
}
#endif
inline void Container::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Container.pod_sandbox_id)
}
inline void Container::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Container.pod_sandbox_id)
}
inline ::std::string* Container::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Container.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.Container.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.Container.pod_sandbox_id)
}

// .runtime.ContainerMetadata metadata = 3;
inline bool Container::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void Container::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::ContainerMetadata& Container::metadata() const {
  const ::runtime::ContainerMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.Container.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerMetadata*>(
      &::runtime::_ContainerMetadata_default_instance_);
}
inline ::runtime::ContainerMetadata* Container::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.Container.metadata)
  
  ::runtime::ContainerMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::ContainerMetadata* Container::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::ContainerMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.Container.metadata)
  return metadata_;
}
inline void Container::set_allocated_metadata(::runtime::ContainerMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.Container.metadata)
}

// .runtime.ImageSpec image = 4;
inline bool Container::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void Container::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& Container::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.Container.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* Container::release_image() {
  // @@protoc_insertion_point(field_release:runtime.Container.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* Container::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.Container.image)
  return image_;
}
inline void Container::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.Container.image)
}

// string image_ref = 5;
inline void Container::clear_image_ref() {
  image_ref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Container::image_ref() const {
  // @@protoc_insertion_point(field_get:runtime.Container.image_ref)
  return image_ref_.GetNoArena();
}
inline void Container::set_image_ref(const ::std::string& value) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Container.image_ref)
}
#if LANG_CXX11
inline void Container::set_image_ref(::std::string&& value) {
  
  image_ref_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Container.image_ref)
}
#endif
inline void Container::set_image_ref(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Container.image_ref)
}
inline void Container::set_image_ref(const char* value, size_t size) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Container.image_ref)
}
inline ::std::string* Container::mutable_image_ref() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Container.image_ref)
  return image_ref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_image_ref() {
  // @@protoc_insertion_point(field_release:runtime.Container.image_ref)
  
  return image_ref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_image_ref(::std::string* image_ref) {
  if (image_ref != NULL) {
    
  } else {
    
  }
  image_ref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_ref);
  // @@protoc_insertion_point(field_set_allocated:runtime.Container.image_ref)
}

// .runtime.ContainerState state = 6;
inline void Container::clear_state() {
  state_ = 0;
}
inline ::runtime::ContainerState Container::state() const {
  // @@protoc_insertion_point(field_get:runtime.Container.state)
  return static_cast< ::runtime::ContainerState >(state_);
}
inline void Container::set_state(::runtime::ContainerState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.Container.state)
}

// int64 created_at = 7;
inline void Container::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Container::created_at() const {
  // @@protoc_insertion_point(field_get:runtime.Container.created_at)
  return created_at_;
}
inline void Container::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.Container.created_at)
}

// map<string, string> labels = 8;
inline int Container::labels_size() const {
  return labels_.size();
}
inline void Container::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Container::labels() const {
  // @@protoc_insertion_point(field_map:runtime.Container.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Container::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.Container.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 9;
inline int Container::annotations_size() const {
  return annotations_.size();
}
inline void Container::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Container::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.Container.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Container::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.Container.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// ListContainersResponse

// repeated .runtime.Container containers = 1;
inline int ListContainersResponse::containers_size() const {
  return containers_.size();
}
inline void ListContainersResponse::clear_containers() {
  containers_.Clear();
}
inline const ::runtime::Container& ListContainersResponse::containers(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ListContainersResponse.containers)
  return containers_.Get(index);
}
inline ::runtime::Container* ListContainersResponse::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ListContainersResponse.containers)
  return containers_.Mutable(index);
}
inline ::runtime::Container* ListContainersResponse::add_containers() {
  // @@protoc_insertion_point(field_add:runtime.ListContainersResponse.containers)
  return containers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::Container >*
ListContainersResponse::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ListContainersResponse.containers)
  return &containers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::Container >&
ListContainersResponse::containers() const {
  // @@protoc_insertion_point(field_list:runtime.ListContainersResponse.containers)
  return containers_;
}

// -------------------------------------------------------------------

// ContainerStatusRequest

// string container_id = 1;
inline void ContainerStatusRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatusRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatusRequest.container_id)
  return container_id_.GetNoArena();
}
inline void ContainerStatusRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatusRequest.container_id)
}
#if LANG_CXX11
inline void ContainerStatusRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatusRequest.container_id)
}
#endif
inline void ContainerStatusRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatusRequest.container_id)
}
inline void ContainerStatusRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatusRequest.container_id)
}
inline ::std::string* ContainerStatusRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatusRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatusRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatusRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatusRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatusRequest.container_id)
}

// bool verbose = 2;
inline void ContainerStatusRequest::clear_verbose() {
  verbose_ = false;
}
inline bool ContainerStatusRequest::verbose() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatusRequest.verbose)
  return verbose_;
}
inline void ContainerStatusRequest::set_verbose(bool value) {
  
  verbose_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatusRequest.verbose)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerStatus

// string id = 1;
inline void ContainerStatus::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatus::id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.id)
  return id_.GetNoArena();
}
inline void ContainerStatus::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.id)
}
#if LANG_CXX11
inline void ContainerStatus::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatus.id)
}
#endif
inline void ContainerStatus::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatus.id)
}
inline void ContainerStatus::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatus.id)
}
inline ::std::string* ContainerStatus::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatus::release_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatus::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.id)
}

// .runtime.ContainerMetadata metadata = 2;
inline bool ContainerStatus::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void ContainerStatus::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::ContainerMetadata& ContainerStatus::metadata() const {
  const ::runtime::ContainerMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerMetadata*>(
      &::runtime::_ContainerMetadata_default_instance_);
}
inline ::runtime::ContainerMetadata* ContainerStatus::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.metadata)
  
  ::runtime::ContainerMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::ContainerMetadata* ContainerStatus::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::ContainerMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.metadata)
  return metadata_;
}
inline void ContainerStatus::set_allocated_metadata(::runtime::ContainerMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.metadata)
}

// .runtime.ContainerState state = 3;
inline void ContainerStatus::clear_state() {
  state_ = 0;
}
inline ::runtime::ContainerState ContainerStatus::state() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.state)
  return static_cast< ::runtime::ContainerState >(state_);
}
inline void ContainerStatus::set_state(::runtime::ContainerState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.state)
}

// int64 created_at = 4;
inline void ContainerStatus::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ContainerStatus::created_at() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.created_at)
  return created_at_;
}
inline void ContainerStatus::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.created_at)
}

// int64 started_at = 5;
inline void ContainerStatus::clear_started_at() {
  started_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ContainerStatus::started_at() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.started_at)
  return started_at_;
}
inline void ContainerStatus::set_started_at(::google::protobuf::int64 value) {
  
  started_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.started_at)
}

// int64 finished_at = 6;
inline void ContainerStatus::clear_finished_at() {
  finished_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ContainerStatus::finished_at() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.finished_at)
  return finished_at_;
}
inline void ContainerStatus::set_finished_at(::google::protobuf::int64 value) {
  
  finished_at_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.finished_at)
}

// int32 exit_code = 7;
inline void ContainerStatus::clear_exit_code() {
  exit_code_ = 0;
}
inline ::google::protobuf::int32 ContainerStatus::exit_code() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.exit_code)
  return exit_code_;
}
inline void ContainerStatus::set_exit_code(::google::protobuf::int32 value) {
  
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.exit_code)
}

// .runtime.ImageSpec image = 8;
inline bool ContainerStatus::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ContainerStatus::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& ContainerStatus::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* ContainerStatus::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* ContainerStatus::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.image)
  return image_;
}
inline void ContainerStatus::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.image)
}

// string image_ref = 9;
inline void ContainerStatus::clear_image_ref() {
  image_ref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatus::image_ref() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.image_ref)
  return image_ref_.GetNoArena();
}
inline void ContainerStatus::set_image_ref(const ::std::string& value) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.image_ref)
}
#if LANG_CXX11
inline void ContainerStatus::set_image_ref(::std::string&& value) {
  
  image_ref_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatus.image_ref)
}
#endif
inline void ContainerStatus::set_image_ref(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatus.image_ref)
}
inline void ContainerStatus::set_image_ref(const char* value, size_t size) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatus.image_ref)
}
inline ::std::string* ContainerStatus::mutable_image_ref() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.image_ref)
  return image_ref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatus::release_image_ref() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.image_ref)
  
  return image_ref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatus::set_allocated_image_ref(::std::string* image_ref) {
  if (image_ref != NULL) {
    
  } else {
    
  }
  image_ref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_ref);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.image_ref)
}

// string reason = 10;
inline void ContainerStatus::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatus::reason() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.reason)
  return reason_.GetNoArena();
}
inline void ContainerStatus::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.reason)
}
#if LANG_CXX11
inline void ContainerStatus::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatus.reason)
}
#endif
inline void ContainerStatus::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatus.reason)
}
inline void ContainerStatus::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatus.reason)
}
inline ::std::string* ContainerStatus::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatus::release_reason() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatus::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.reason)
}

// string message = 11;
inline void ContainerStatus::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatus::message() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.message)
  return message_.GetNoArena();
}
inline void ContainerStatus::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.message)
}
#if LANG_CXX11
inline void ContainerStatus::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatus.message)
}
#endif
inline void ContainerStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatus.message)
}
inline void ContainerStatus::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatus.message)
}
inline ::std::string* ContainerStatus::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatus::release_message() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.message)
}

// map<string, string> labels = 12;
inline int ContainerStatus::labels_size() const {
  return labels_.size();
}
inline void ContainerStatus::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerStatus::labels() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerStatus.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerStatus::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerStatus.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 13;
inline int ContainerStatus::annotations_size() const {
  return annotations_.size();
}
inline void ContainerStatus::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerStatus::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerStatus.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerStatus::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerStatus.annotations)
  return annotations_.MutableMap();
}

// repeated .runtime.Mount mounts = 14;
inline int ContainerStatus::mounts_size() const {
  return mounts_.size();
}
inline void ContainerStatus::clear_mounts() {
  mounts_.Clear();
}
inline const ::runtime::Mount& ContainerStatus::mounts(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.mounts)
  return mounts_.Get(index);
}
inline ::runtime::Mount* ContainerStatus::mutable_mounts(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.mounts)
  return mounts_.Mutable(index);
}
inline ::runtime::Mount* ContainerStatus::add_mounts() {
  // @@protoc_insertion_point(field_add:runtime.ContainerStatus.mounts)
  return mounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::Mount >*
ContainerStatus::mutable_mounts() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ContainerStatus.mounts)
  return &mounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::Mount >&
ContainerStatus::mounts() const {
  // @@protoc_insertion_point(field_list:runtime.ContainerStatus.mounts)
  return mounts_;
}

// string log_path = 15;
inline void ContainerStatus::clear_log_path() {
  log_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatus::log_path() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatus.log_path)
  return log_path_.GetNoArena();
}
inline void ContainerStatus::set_log_path(const ::std::string& value) {
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatus.log_path)
}
#if LANG_CXX11
inline void ContainerStatus::set_log_path(::std::string&& value) {
  
  log_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatus.log_path)
}
#endif
inline void ContainerStatus::set_log_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatus.log_path)
}
inline void ContainerStatus::set_log_path(const char* value, size_t size) {
  
  log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatus.log_path)
}
inline ::std::string* ContainerStatus::mutable_log_path() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatus.log_path)
  return log_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatus::release_log_path() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatus.log_path)
  
  return log_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatus::set_allocated_log_path(::std::string* log_path) {
  if (log_path != NULL) {
    
  } else {
    
  }
  log_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log_path);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatus.log_path)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerStatusResponse

// .runtime.ContainerStatus status = 1;
inline bool ContainerStatusResponse::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void ContainerStatusResponse::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::runtime::ContainerStatus& ContainerStatusResponse::status() const {
  const ::runtime::ContainerStatus* p = status_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStatusResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerStatus*>(
      &::runtime::_ContainerStatus_default_instance_);
}
inline ::runtime::ContainerStatus* ContainerStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatusResponse.status)
  
  ::runtime::ContainerStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::runtime::ContainerStatus* ContainerStatusResponse::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::runtime::ContainerStatus;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatusResponse.status)
  return status_;
}
inline void ContainerStatusResponse::set_allocated_status(::runtime::ContainerStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatusResponse.status)
}

// map<string, string> info = 2;
inline int ContainerStatusResponse::info_size() const {
  return info_.size();
}
inline void ContainerStatusResponse::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerStatusResponse::info() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerStatusResponse.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerStatusResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerStatusResponse.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// UpdateContainerResourcesRequest

// string container_id = 1;
inline void UpdateContainerResourcesRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateContainerResourcesRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.UpdateContainerResourcesRequest.container_id)
  return container_id_.GetNoArena();
}
inline void UpdateContainerResourcesRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.UpdateContainerResourcesRequest.container_id)
}
#if LANG_CXX11
inline void UpdateContainerResourcesRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.UpdateContainerResourcesRequest.container_id)
}
#endif
inline void UpdateContainerResourcesRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.UpdateContainerResourcesRequest.container_id)
}
inline void UpdateContainerResourcesRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.UpdateContainerResourcesRequest.container_id)
}
inline ::std::string* UpdateContainerResourcesRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.UpdateContainerResourcesRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateContainerResourcesRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.UpdateContainerResourcesRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateContainerResourcesRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.UpdateContainerResourcesRequest.container_id)
}

// .runtime.LinuxContainerResources linux = 2;
inline bool UpdateContainerResourcesRequest::has_linux() const {
  return this != internal_default_instance() && linux_ != NULL;
}
inline void UpdateContainerResourcesRequest::clear_linux() {
  if (GetArenaNoVirtual() == NULL && linux_ != NULL) {
    delete linux_;
  }
  linux_ = NULL;
}
inline const ::runtime::LinuxContainerResources& UpdateContainerResourcesRequest::linux() const {
  const ::runtime::LinuxContainerResources* p = linux_;
  // @@protoc_insertion_point(field_get:runtime.UpdateContainerResourcesRequest.linux)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::LinuxContainerResources*>(
      &::runtime::_LinuxContainerResources_default_instance_);
}
inline ::runtime::LinuxContainerResources* UpdateContainerResourcesRequest::release_linux() {
  // @@protoc_insertion_point(field_release:runtime.UpdateContainerResourcesRequest.linux)
  
  ::runtime::LinuxContainerResources* temp = linux_;
  linux_ = NULL;
  return temp;
}
inline ::runtime::LinuxContainerResources* UpdateContainerResourcesRequest::mutable_linux() {
  
  if (linux_ == NULL) {
    linux_ = new ::runtime::LinuxContainerResources;
  }
  // @@protoc_insertion_point(field_mutable:runtime.UpdateContainerResourcesRequest.linux)
  return linux_;
}
inline void UpdateContainerResourcesRequest::set_allocated_linux(::runtime::LinuxContainerResources* linux) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linux_;
  }
  if (linux) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linux = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linux, submessage_arena);
    }
    
  } else {
    
  }
  linux_ = linux;
  // @@protoc_insertion_point(field_set_allocated:runtime.UpdateContainerResourcesRequest.linux)
}

// -------------------------------------------------------------------

// UpdateContainerResourcesResponse

// -------------------------------------------------------------------

// ExecSyncRequest

// string container_id = 1;
inline void ExecSyncRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecSyncRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncRequest.container_id)
  return container_id_.GetNoArena();
}
inline void ExecSyncRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ExecSyncRequest.container_id)
}
#if LANG_CXX11
inline void ExecSyncRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ExecSyncRequest.container_id)
}
#endif
inline void ExecSyncRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ExecSyncRequest.container_id)
}
inline void ExecSyncRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecSyncRequest.container_id)
}
inline ::std::string* ExecSyncRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ExecSyncRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecSyncRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.ExecSyncRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecSyncRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ExecSyncRequest.container_id)
}

// repeated string cmd = 2;
inline int ExecSyncRequest::cmd_size() const {
  return cmd_.size();
}
inline void ExecSyncRequest::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& ExecSyncRequest::cmd(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncRequest.cmd)
  return cmd_.Get(index);
}
inline ::std::string* ExecSyncRequest::mutable_cmd(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ExecSyncRequest.cmd)
  return cmd_.Mutable(index);
}
inline void ExecSyncRequest::set_cmd(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.ExecSyncRequest.cmd)
  cmd_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ExecSyncRequest::set_cmd(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.ExecSyncRequest.cmd)
  cmd_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ExecSyncRequest::set_cmd(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.ExecSyncRequest.cmd)
}
inline void ExecSyncRequest::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecSyncRequest.cmd)
}
inline ::std::string* ExecSyncRequest::add_cmd() {
  // @@protoc_insertion_point(field_add_mutable:runtime.ExecSyncRequest.cmd)
  return cmd_.Add();
}
inline void ExecSyncRequest::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.ExecSyncRequest.cmd)
}
#if LANG_CXX11
inline void ExecSyncRequest::add_cmd(::std::string&& value) {
  cmd_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.ExecSyncRequest.cmd)
}
#endif
inline void ExecSyncRequest::add_cmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.ExecSyncRequest.cmd)
}
inline void ExecSyncRequest::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.ExecSyncRequest.cmd)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExecSyncRequest::cmd() const {
  // @@protoc_insertion_point(field_list:runtime.ExecSyncRequest.cmd)
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExecSyncRequest::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ExecSyncRequest.cmd)
  return &cmd_;
}

// int64 timeout = 3;
inline void ExecSyncRequest::clear_timeout() {
  timeout_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExecSyncRequest::timeout() const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncRequest.timeout)
  return timeout_;
}
inline void ExecSyncRequest::set_timeout(::google::protobuf::int64 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecSyncRequest.timeout)
}

// -------------------------------------------------------------------

// ExecSyncResponse

// bytes stdout = 1;
inline void ExecSyncResponse::clear_stdout() {
  stdout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecSyncResponse::stdout() const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncResponse.stdout)
  return stdout_.GetNoArena();
}
inline void ExecSyncResponse::set_stdout(const ::std::string& value) {
  
  stdout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ExecSyncResponse.stdout)
}
#if LANG_CXX11
inline void ExecSyncResponse::set_stdout(::std::string&& value) {
  
  stdout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ExecSyncResponse.stdout)
}
#endif
inline void ExecSyncResponse::set_stdout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stdout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ExecSyncResponse.stdout)
}
inline void ExecSyncResponse::set_stdout(const void* value, size_t size) {
  
  stdout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecSyncResponse.stdout)
}
inline ::std::string* ExecSyncResponse::mutable_stdout() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ExecSyncResponse.stdout)
  return stdout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecSyncResponse::release_stdout() {
  // @@protoc_insertion_point(field_release:runtime.ExecSyncResponse.stdout)
  
  return stdout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecSyncResponse::set_allocated_stdout(::std::string* stdout) {
  if (stdout != NULL) {
    
  } else {
    
  }
  stdout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stdout);
  // @@protoc_insertion_point(field_set_allocated:runtime.ExecSyncResponse.stdout)
}

// bytes stderr = 2;
inline void ExecSyncResponse::clear_stderr() {
  stderr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecSyncResponse::stderr() const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncResponse.stderr)
  return stderr_.GetNoArena();
}
inline void ExecSyncResponse::set_stderr(const ::std::string& value) {
  
  stderr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ExecSyncResponse.stderr)
}
#if LANG_CXX11
inline void ExecSyncResponse::set_stderr(::std::string&& value) {
  
  stderr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ExecSyncResponse.stderr)
}
#endif
inline void ExecSyncResponse::set_stderr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stderr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ExecSyncResponse.stderr)
}
inline void ExecSyncResponse::set_stderr(const void* value, size_t size) {
  
  stderr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecSyncResponse.stderr)
}
inline ::std::string* ExecSyncResponse::mutable_stderr() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ExecSyncResponse.stderr)
  return stderr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecSyncResponse::release_stderr() {
  // @@protoc_insertion_point(field_release:runtime.ExecSyncResponse.stderr)
  
  return stderr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecSyncResponse::set_allocated_stderr(::std::string* stderr) {
  if (stderr != NULL) {
    
  } else {
    
  }
  stderr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stderr);
  // @@protoc_insertion_point(field_set_allocated:runtime.ExecSyncResponse.stderr)
}

// int32 exit_code = 3;
inline void ExecSyncResponse::clear_exit_code() {
  exit_code_ = 0;
}
inline ::google::protobuf::int32 ExecSyncResponse::exit_code() const {
  // @@protoc_insertion_point(field_get:runtime.ExecSyncResponse.exit_code)
  return exit_code_;
}
inline void ExecSyncResponse::set_exit_code(::google::protobuf::int32 value) {
  
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecSyncResponse.exit_code)
}

// -------------------------------------------------------------------

// ExecRequest

// string container_id = 1;
inline void ExecRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.container_id)
  return container_id_.GetNoArena();
}
inline void ExecRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.container_id)
}
#if LANG_CXX11
inline void ExecRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ExecRequest.container_id)
}
#endif
inline void ExecRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ExecRequest.container_id)
}
inline void ExecRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecRequest.container_id)
}
inline ::std::string* ExecRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ExecRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.ExecRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ExecRequest.container_id)
}

// repeated string cmd = 2;
inline int ExecRequest::cmd_size() const {
  return cmd_.size();
}
inline void ExecRequest::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& ExecRequest::cmd(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.cmd)
  return cmd_.Get(index);
}
inline ::std::string* ExecRequest::mutable_cmd(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ExecRequest.cmd)
  return cmd_.Mutable(index);
}
inline void ExecRequest::set_cmd(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.cmd)
  cmd_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ExecRequest::set_cmd(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.cmd)
  cmd_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ExecRequest::set_cmd(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.ExecRequest.cmd)
}
inline void ExecRequest::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecRequest.cmd)
}
inline ::std::string* ExecRequest::add_cmd() {
  // @@protoc_insertion_point(field_add_mutable:runtime.ExecRequest.cmd)
  return cmd_.Add();
}
inline void ExecRequest::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.ExecRequest.cmd)
}
#if LANG_CXX11
inline void ExecRequest::add_cmd(::std::string&& value) {
  cmd_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.ExecRequest.cmd)
}
#endif
inline void ExecRequest::add_cmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.ExecRequest.cmd)
}
inline void ExecRequest::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.ExecRequest.cmd)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExecRequest::cmd() const {
  // @@protoc_insertion_point(field_list:runtime.ExecRequest.cmd)
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExecRequest::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ExecRequest.cmd)
  return &cmd_;
}

// bool tty = 3;
inline void ExecRequest::clear_tty() {
  tty_ = false;
}
inline bool ExecRequest::tty() const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.tty)
  return tty_;
}
inline void ExecRequest::set_tty(bool value) {
  
  tty_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.tty)
}

// bool stdin = 4;
inline void ExecRequest::clear_stdin() {
  stdin_ = false;
}
inline bool ExecRequest::stdin() const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.stdin)
  return stdin_;
}
inline void ExecRequest::set_stdin(bool value) {
  
  stdin_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.stdin)
}

// bool stdout = 5;
inline void ExecRequest::clear_stdout() {
  stdout_ = false;
}
inline bool ExecRequest::stdout() const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.stdout)
  return stdout_;
}
inline void ExecRequest::set_stdout(bool value) {
  
  stdout_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.stdout)
}

// bool stderr = 6;
inline void ExecRequest::clear_stderr() {
  stderr_ = false;
}
inline bool ExecRequest::stderr() const {
  // @@protoc_insertion_point(field_get:runtime.ExecRequest.stderr)
  return stderr_;
}
inline void ExecRequest::set_stderr(bool value) {
  
  stderr_ = value;
  // @@protoc_insertion_point(field_set:runtime.ExecRequest.stderr)
}

// -------------------------------------------------------------------

// ExecResponse

// string url = 1;
inline void ExecResponse::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecResponse::url() const {
  // @@protoc_insertion_point(field_get:runtime.ExecResponse.url)
  return url_.GetNoArena();
}
inline void ExecResponse::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ExecResponse.url)
}
#if LANG_CXX11
inline void ExecResponse::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ExecResponse.url)
}
#endif
inline void ExecResponse::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ExecResponse.url)
}
inline void ExecResponse::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ExecResponse.url)
}
inline ::std::string* ExecResponse::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ExecResponse.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecResponse::release_url() {
  // @@protoc_insertion_point(field_release:runtime.ExecResponse.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecResponse::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:runtime.ExecResponse.url)
}

// -------------------------------------------------------------------

// AttachRequest

// string container_id = 1;
inline void AttachRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttachRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.AttachRequest.container_id)
  return container_id_.GetNoArena();
}
inline void AttachRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AttachRequest.container_id)
}
#if LANG_CXX11
inline void AttachRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AttachRequest.container_id)
}
#endif
inline void AttachRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AttachRequest.container_id)
}
inline void AttachRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AttachRequest.container_id)
}
inline ::std::string* AttachRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AttachRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.AttachRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.AttachRequest.container_id)
}

// bool stdin = 2;
inline void AttachRequest::clear_stdin() {
  stdin_ = false;
}
inline bool AttachRequest::stdin() const {
  // @@protoc_insertion_point(field_get:runtime.AttachRequest.stdin)
  return stdin_;
}
inline void AttachRequest::set_stdin(bool value) {
  
  stdin_ = value;
  // @@protoc_insertion_point(field_set:runtime.AttachRequest.stdin)
}

// bool tty = 3;
inline void AttachRequest::clear_tty() {
  tty_ = false;
}
inline bool AttachRequest::tty() const {
  // @@protoc_insertion_point(field_get:runtime.AttachRequest.tty)
  return tty_;
}
inline void AttachRequest::set_tty(bool value) {
  
  tty_ = value;
  // @@protoc_insertion_point(field_set:runtime.AttachRequest.tty)
}

// bool stdout = 4;
inline void AttachRequest::clear_stdout() {
  stdout_ = false;
}
inline bool AttachRequest::stdout() const {
  // @@protoc_insertion_point(field_get:runtime.AttachRequest.stdout)
  return stdout_;
}
inline void AttachRequest::set_stdout(bool value) {
  
  stdout_ = value;
  // @@protoc_insertion_point(field_set:runtime.AttachRequest.stdout)
}

// bool stderr = 5;
inline void AttachRequest::clear_stderr() {
  stderr_ = false;
}
inline bool AttachRequest::stderr() const {
  // @@protoc_insertion_point(field_get:runtime.AttachRequest.stderr)
  return stderr_;
}
inline void AttachRequest::set_stderr(bool value) {
  
  stderr_ = value;
  // @@protoc_insertion_point(field_set:runtime.AttachRequest.stderr)
}

// -------------------------------------------------------------------

// AttachResponse

// string url = 1;
inline void AttachResponse::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttachResponse::url() const {
  // @@protoc_insertion_point(field_get:runtime.AttachResponse.url)
  return url_.GetNoArena();
}
inline void AttachResponse::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AttachResponse.url)
}
#if LANG_CXX11
inline void AttachResponse::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AttachResponse.url)
}
#endif
inline void AttachResponse::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AttachResponse.url)
}
inline void AttachResponse::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AttachResponse.url)
}
inline ::std::string* AttachResponse::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AttachResponse.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachResponse::release_url() {
  // @@protoc_insertion_point(field_release:runtime.AttachResponse.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachResponse::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:runtime.AttachResponse.url)
}

// -------------------------------------------------------------------

// PortForwardRequest

// string pod_sandbox_id = 1;
inline void PortForwardRequest::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortForwardRequest::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.PortForwardRequest.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void PortForwardRequest::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PortForwardRequest.pod_sandbox_id)
}
#if LANG_CXX11
inline void PortForwardRequest::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PortForwardRequest.pod_sandbox_id)
}
#endif
inline void PortForwardRequest::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PortForwardRequest.pod_sandbox_id)
}
inline void PortForwardRequest::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PortForwardRequest.pod_sandbox_id)
}
inline ::std::string* PortForwardRequest::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PortForwardRequest.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortForwardRequest::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.PortForwardRequest.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortForwardRequest::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.PortForwardRequest.pod_sandbox_id)
}

// repeated int32 port = 2;
inline int PortForwardRequest::port_size() const {
  return port_.size();
}
inline void PortForwardRequest::clear_port() {
  port_.Clear();
}
inline ::google::protobuf::int32 PortForwardRequest::port(int index) const {
  // @@protoc_insertion_point(field_get:runtime.PortForwardRequest.port)
  return port_.Get(index);
}
inline void PortForwardRequest::set_port(int index, ::google::protobuf::int32 value) {
  port_.Set(index, value);
  // @@protoc_insertion_point(field_set:runtime.PortForwardRequest.port)
}
inline void PortForwardRequest::add_port(::google::protobuf::int32 value) {
  port_.Add(value);
  // @@protoc_insertion_point(field_add:runtime.PortForwardRequest.port)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PortForwardRequest::port() const {
  // @@protoc_insertion_point(field_list:runtime.PortForwardRequest.port)
  return port_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PortForwardRequest::mutable_port() {
  // @@protoc_insertion_point(field_mutable_list:runtime.PortForwardRequest.port)
  return &port_;
}

// -------------------------------------------------------------------

// PortForwardResponse

// string url = 1;
inline void PortForwardResponse::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortForwardResponse::url() const {
  // @@protoc_insertion_point(field_get:runtime.PortForwardResponse.url)
  return url_.GetNoArena();
}
inline void PortForwardResponse::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PortForwardResponse.url)
}
#if LANG_CXX11
inline void PortForwardResponse::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PortForwardResponse.url)
}
#endif
inline void PortForwardResponse::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PortForwardResponse.url)
}
inline void PortForwardResponse::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PortForwardResponse.url)
}
inline ::std::string* PortForwardResponse::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PortForwardResponse.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortForwardResponse::release_url() {
  // @@protoc_insertion_point(field_release:runtime.PortForwardResponse.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortForwardResponse::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:runtime.PortForwardResponse.url)
}

// -------------------------------------------------------------------

// ImageFilter

// .runtime.ImageSpec image = 1;
inline bool ImageFilter::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ImageFilter::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& ImageFilter::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.ImageFilter.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* ImageFilter::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ImageFilter.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* ImageFilter::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ImageFilter.image)
  return image_;
}
inline void ImageFilter::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.ImageFilter.image)
}

// -------------------------------------------------------------------

// ListImagesRequest

// .runtime.ImageFilter filter = 1;
inline bool ListImagesRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void ListImagesRequest::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::runtime::ImageFilter& ListImagesRequest::filter() const {
  const ::runtime::ImageFilter* p = filter_;
  // @@protoc_insertion_point(field_get:runtime.ListImagesRequest.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageFilter*>(
      &::runtime::_ImageFilter_default_instance_);
}
inline ::runtime::ImageFilter* ListImagesRequest::release_filter() {
  // @@protoc_insertion_point(field_release:runtime.ListImagesRequest.filter)
  
  ::runtime::ImageFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::runtime::ImageFilter* ListImagesRequest::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::runtime::ImageFilter;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ListImagesRequest.filter)
  return filter_;
}
inline void ListImagesRequest::set_allocated_filter(::runtime::ImageFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:runtime.ListImagesRequest.filter)
}

// -------------------------------------------------------------------

// Image

// string id = 1;
inline void Image::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::id() const {
  // @@protoc_insertion_point(field_get:runtime.Image.id)
  return id_.GetNoArena();
}
inline void Image::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Image.id)
}
#if LANG_CXX11
inline void Image::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Image.id)
}
#endif
inline void Image::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Image.id)
}
inline void Image::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Image.id)
}
inline ::std::string* Image::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Image.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_id() {
  // @@protoc_insertion_point(field_release:runtime.Image.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.Image.id)
}

// repeated string repo_tags = 2;
inline int Image::repo_tags_size() const {
  return repo_tags_.size();
}
inline void Image::clear_repo_tags() {
  repo_tags_.Clear();
}
inline const ::std::string& Image::repo_tags(int index) const {
  // @@protoc_insertion_point(field_get:runtime.Image.repo_tags)
  return repo_tags_.Get(index);
}
inline ::std::string* Image::mutable_repo_tags(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.Image.repo_tags)
  return repo_tags_.Mutable(index);
}
inline void Image::set_repo_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.Image.repo_tags)
  repo_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Image::set_repo_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.Image.repo_tags)
  repo_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Image::set_repo_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  repo_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.Image.repo_tags)
}
inline void Image::set_repo_tags(int index, const char* value, size_t size) {
  repo_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.Image.repo_tags)
}
inline ::std::string* Image::add_repo_tags() {
  // @@protoc_insertion_point(field_add_mutable:runtime.Image.repo_tags)
  return repo_tags_.Add();
}
inline void Image::add_repo_tags(const ::std::string& value) {
  repo_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.Image.repo_tags)
}
#if LANG_CXX11
inline void Image::add_repo_tags(::std::string&& value) {
  repo_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.Image.repo_tags)
}
#endif
inline void Image::add_repo_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  repo_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.Image.repo_tags)
}
inline void Image::add_repo_tags(const char* value, size_t size) {
  repo_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.Image.repo_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Image::repo_tags() const {
  // @@protoc_insertion_point(field_list:runtime.Image.repo_tags)
  return repo_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Image::mutable_repo_tags() {
  // @@protoc_insertion_point(field_mutable_list:runtime.Image.repo_tags)
  return &repo_tags_;
}

// repeated string repo_digests = 3;
inline int Image::repo_digests_size() const {
  return repo_digests_.size();
}
inline void Image::clear_repo_digests() {
  repo_digests_.Clear();
}
inline const ::std::string& Image::repo_digests(int index) const {
  // @@protoc_insertion_point(field_get:runtime.Image.repo_digests)
  return repo_digests_.Get(index);
}
inline ::std::string* Image::mutable_repo_digests(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.Image.repo_digests)
  return repo_digests_.Mutable(index);
}
inline void Image::set_repo_digests(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:runtime.Image.repo_digests)
  repo_digests_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Image::set_repo_digests(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:runtime.Image.repo_digests)
  repo_digests_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Image::set_repo_digests(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  repo_digests_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:runtime.Image.repo_digests)
}
inline void Image::set_repo_digests(int index, const char* value, size_t size) {
  repo_digests_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:runtime.Image.repo_digests)
}
inline ::std::string* Image::add_repo_digests() {
  // @@protoc_insertion_point(field_add_mutable:runtime.Image.repo_digests)
  return repo_digests_.Add();
}
inline void Image::add_repo_digests(const ::std::string& value) {
  repo_digests_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:runtime.Image.repo_digests)
}
#if LANG_CXX11
inline void Image::add_repo_digests(::std::string&& value) {
  repo_digests_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:runtime.Image.repo_digests)
}
#endif
inline void Image::add_repo_digests(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  repo_digests_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:runtime.Image.repo_digests)
}
inline void Image::add_repo_digests(const char* value, size_t size) {
  repo_digests_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:runtime.Image.repo_digests)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Image::repo_digests() const {
  // @@protoc_insertion_point(field_list:runtime.Image.repo_digests)
  return repo_digests_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Image::mutable_repo_digests() {
  // @@protoc_insertion_point(field_mutable_list:runtime.Image.repo_digests)
  return &repo_digests_;
}

// uint64 size = 4;
inline void Image::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Image::size() const {
  // @@protoc_insertion_point(field_get:runtime.Image.size)
  return size_;
}
inline void Image::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:runtime.Image.size)
}

// .runtime.Int64Value uid = 5;
inline bool Image::has_uid() const {
  return this != internal_default_instance() && uid_ != NULL;
}
inline void Image::clear_uid() {
  if (GetArenaNoVirtual() == NULL && uid_ != NULL) {
    delete uid_;
  }
  uid_ = NULL;
}
inline const ::runtime::Int64Value& Image::uid() const {
  const ::runtime::Int64Value* p = uid_;
  // @@protoc_insertion_point(field_get:runtime.Image.uid)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Int64Value*>(
      &::runtime::_Int64Value_default_instance_);
}
inline ::runtime::Int64Value* Image::release_uid() {
  // @@protoc_insertion_point(field_release:runtime.Image.uid)
  
  ::runtime::Int64Value* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline ::runtime::Int64Value* Image::mutable_uid() {
  
  if (uid_ == NULL) {
    uid_ = new ::runtime::Int64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.Image.uid)
  return uid_;
}
inline void Image::set_allocated_uid(::runtime::Int64Value* uid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uid_;
  }
  if (uid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uid, submessage_arena);
    }
    
  } else {
    
  }
  uid_ = uid;
  // @@protoc_insertion_point(field_set_allocated:runtime.Image.uid)
}

// string username = 6;
inline void Image::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::username() const {
  // @@protoc_insertion_point(field_get:runtime.Image.username)
  return username_.GetNoArena();
}
inline void Image::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.Image.username)
}
#if LANG_CXX11
inline void Image::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.Image.username)
}
#endif
inline void Image::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.Image.username)
}
inline void Image::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.Image.username)
}
inline ::std::string* Image::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:runtime.Image.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_username() {
  // @@protoc_insertion_point(field_release:runtime.Image.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:runtime.Image.username)
}

// -------------------------------------------------------------------

// ListImagesResponse

// repeated .runtime.Image images = 1;
inline int ListImagesResponse::images_size() const {
  return images_.size();
}
inline void ListImagesResponse::clear_images() {
  images_.Clear();
}
inline const ::runtime::Image& ListImagesResponse::images(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ListImagesResponse.images)
  return images_.Get(index);
}
inline ::runtime::Image* ListImagesResponse::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ListImagesResponse.images)
  return images_.Mutable(index);
}
inline ::runtime::Image* ListImagesResponse::add_images() {
  // @@protoc_insertion_point(field_add:runtime.ListImagesResponse.images)
  return images_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::Image >*
ListImagesResponse::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ListImagesResponse.images)
  return &images_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::Image >&
ListImagesResponse::images() const {
  // @@protoc_insertion_point(field_list:runtime.ListImagesResponse.images)
  return images_;
}

// -------------------------------------------------------------------

// ImageStatusRequest

// .runtime.ImageSpec image = 1;
inline bool ImageStatusRequest::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ImageStatusRequest::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& ImageStatusRequest::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.ImageStatusRequest.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* ImageStatusRequest::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ImageStatusRequest.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* ImageStatusRequest::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ImageStatusRequest.image)
  return image_;
}
inline void ImageStatusRequest::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.ImageStatusRequest.image)
}

// bool verbose = 2;
inline void ImageStatusRequest::clear_verbose() {
  verbose_ = false;
}
inline bool ImageStatusRequest::verbose() const {
  // @@protoc_insertion_point(field_get:runtime.ImageStatusRequest.verbose)
  return verbose_;
}
inline void ImageStatusRequest::set_verbose(bool value) {
  
  verbose_ = value;
  // @@protoc_insertion_point(field_set:runtime.ImageStatusRequest.verbose)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ImageStatusResponse

// .runtime.Image image = 1;
inline bool ImageStatusResponse::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ImageStatusResponse::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::Image& ImageStatusResponse::image() const {
  const ::runtime::Image* p = image_;
  // @@protoc_insertion_point(field_get:runtime.ImageStatusResponse.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::Image*>(
      &::runtime::_Image_default_instance_);
}
inline ::runtime::Image* ImageStatusResponse::release_image() {
  // @@protoc_insertion_point(field_release:runtime.ImageStatusResponse.image)
  
  ::runtime::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::Image* ImageStatusResponse::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::Image;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ImageStatusResponse.image)
  return image_;
}
inline void ImageStatusResponse::set_allocated_image(::runtime::Image* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.ImageStatusResponse.image)
}

// map<string, string> info = 2;
inline int ImageStatusResponse::info_size() const {
  return info_.size();
}
inline void ImageStatusResponse::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ImageStatusResponse::info() const {
  // @@protoc_insertion_point(field_map:runtime.ImageStatusResponse.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ImageStatusResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ImageStatusResponse.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// AuthConfig

// string username = 1;
inline void AuthConfig::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::username() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.username)
  return username_.GetNoArena();
}
inline void AuthConfig::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.username)
}
#if LANG_CXX11
inline void AuthConfig::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.username)
}
#endif
inline void AuthConfig::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.username)
}
inline void AuthConfig::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.username)
}
inline ::std::string* AuthConfig::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_username() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.username)
}

// string password = 2;
inline void AuthConfig::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::password() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.password)
  return password_.GetNoArena();
}
inline void AuthConfig::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.password)
}
#if LANG_CXX11
inline void AuthConfig::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.password)
}
#endif
inline void AuthConfig::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.password)
}
inline void AuthConfig::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.password)
}
inline ::std::string* AuthConfig::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_password() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.password)
}

// string auth = 3;
inline void AuthConfig::clear_auth() {
  auth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::auth() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.auth)
  return auth_.GetNoArena();
}
inline void AuthConfig::set_auth(const ::std::string& value) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.auth)
}
#if LANG_CXX11
inline void AuthConfig::set_auth(::std::string&& value) {
  
  auth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.auth)
}
#endif
inline void AuthConfig::set_auth(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.auth)
}
inline void AuthConfig::set_auth(const char* value, size_t size) {
  
  auth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.auth)
}
inline ::std::string* AuthConfig::mutable_auth() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.auth)
  return auth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_auth() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.auth)
  
  return auth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_auth(::std::string* auth) {
  if (auth != NULL) {
    
  } else {
    
  }
  auth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.auth)
}

// string server_address = 4;
inline void AuthConfig::clear_server_address() {
  server_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::server_address() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.server_address)
  return server_address_.GetNoArena();
}
inline void AuthConfig::set_server_address(const ::std::string& value) {
  
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.server_address)
}
#if LANG_CXX11
inline void AuthConfig::set_server_address(::std::string&& value) {
  
  server_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.server_address)
}
#endif
inline void AuthConfig::set_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.server_address)
}
inline void AuthConfig::set_server_address(const char* value, size_t size) {
  
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.server_address)
}
inline ::std::string* AuthConfig::mutable_server_address() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.server_address)
  return server_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_server_address() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.server_address)
  
  return server_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_server_address(::std::string* server_address) {
  if (server_address != NULL) {
    
  } else {
    
  }
  server_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_address);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.server_address)
}

// string identity_token = 5;
inline void AuthConfig::clear_identity_token() {
  identity_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::identity_token() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.identity_token)
  return identity_token_.GetNoArena();
}
inline void AuthConfig::set_identity_token(const ::std::string& value) {
  
  identity_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.identity_token)
}
#if LANG_CXX11
inline void AuthConfig::set_identity_token(::std::string&& value) {
  
  identity_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.identity_token)
}
#endif
inline void AuthConfig::set_identity_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  identity_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.identity_token)
}
inline void AuthConfig::set_identity_token(const char* value, size_t size) {
  
  identity_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.identity_token)
}
inline ::std::string* AuthConfig::mutable_identity_token() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.identity_token)
  return identity_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_identity_token() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.identity_token)
  
  return identity_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_identity_token(::std::string* identity_token) {
  if (identity_token != NULL) {
    
  } else {
    
  }
  identity_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identity_token);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.identity_token)
}

// string registry_token = 6;
inline void AuthConfig::clear_registry_token() {
  registry_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthConfig::registry_token() const {
  // @@protoc_insertion_point(field_get:runtime.AuthConfig.registry_token)
  return registry_token_.GetNoArena();
}
inline void AuthConfig::set_registry_token(const ::std::string& value) {
  
  registry_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.AuthConfig.registry_token)
}
#if LANG_CXX11
inline void AuthConfig::set_registry_token(::std::string&& value) {
  
  registry_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.AuthConfig.registry_token)
}
#endif
inline void AuthConfig::set_registry_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  registry_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.AuthConfig.registry_token)
}
inline void AuthConfig::set_registry_token(const char* value, size_t size) {
  
  registry_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.AuthConfig.registry_token)
}
inline ::std::string* AuthConfig::mutable_registry_token() {
  
  // @@protoc_insertion_point(field_mutable:runtime.AuthConfig.registry_token)
  return registry_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthConfig::release_registry_token() {
  // @@protoc_insertion_point(field_release:runtime.AuthConfig.registry_token)
  
  return registry_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthConfig::set_allocated_registry_token(::std::string* registry_token) {
  if (registry_token != NULL) {
    
  } else {
    
  }
  registry_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), registry_token);
  // @@protoc_insertion_point(field_set_allocated:runtime.AuthConfig.registry_token)
}

// -------------------------------------------------------------------

// PullImageRequest

// .runtime.ImageSpec image = 1;
inline bool PullImageRequest::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void PullImageRequest::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& PullImageRequest::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.PullImageRequest.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* PullImageRequest::release_image() {
  // @@protoc_insertion_point(field_release:runtime.PullImageRequest.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* PullImageRequest::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PullImageRequest.image)
  return image_;
}
inline void PullImageRequest::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.PullImageRequest.image)
}

// .runtime.AuthConfig auth = 2;
inline bool PullImageRequest::has_auth() const {
  return this != internal_default_instance() && auth_ != NULL;
}
inline void PullImageRequest::clear_auth() {
  if (GetArenaNoVirtual() == NULL && auth_ != NULL) {
    delete auth_;
  }
  auth_ = NULL;
}
inline const ::runtime::AuthConfig& PullImageRequest::auth() const {
  const ::runtime::AuthConfig* p = auth_;
  // @@protoc_insertion_point(field_get:runtime.PullImageRequest.auth)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::AuthConfig*>(
      &::runtime::_AuthConfig_default_instance_);
}
inline ::runtime::AuthConfig* PullImageRequest::release_auth() {
  // @@protoc_insertion_point(field_release:runtime.PullImageRequest.auth)
  
  ::runtime::AuthConfig* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline ::runtime::AuthConfig* PullImageRequest::mutable_auth() {
  
  if (auth_ == NULL) {
    auth_ = new ::runtime::AuthConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PullImageRequest.auth)
  return auth_;
}
inline void PullImageRequest::set_allocated_auth(::runtime::AuthConfig* auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete auth_;
  }
  if (auth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:runtime.PullImageRequest.auth)
}

// .runtime.PodSandboxConfig sandbox_config = 3;
inline bool PullImageRequest::has_sandbox_config() const {
  return this != internal_default_instance() && sandbox_config_ != NULL;
}
inline void PullImageRequest::clear_sandbox_config() {
  if (GetArenaNoVirtual() == NULL && sandbox_config_ != NULL) {
    delete sandbox_config_;
  }
  sandbox_config_ = NULL;
}
inline const ::runtime::PodSandboxConfig& PullImageRequest::sandbox_config() const {
  const ::runtime::PodSandboxConfig* p = sandbox_config_;
  // @@protoc_insertion_point(field_get:runtime.PullImageRequest.sandbox_config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::PodSandboxConfig*>(
      &::runtime::_PodSandboxConfig_default_instance_);
}
inline ::runtime::PodSandboxConfig* PullImageRequest::release_sandbox_config() {
  // @@protoc_insertion_point(field_release:runtime.PullImageRequest.sandbox_config)
  
  ::runtime::PodSandboxConfig* temp = sandbox_config_;
  sandbox_config_ = NULL;
  return temp;
}
inline ::runtime::PodSandboxConfig* PullImageRequest::mutable_sandbox_config() {
  
  if (sandbox_config_ == NULL) {
    sandbox_config_ = new ::runtime::PodSandboxConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.PullImageRequest.sandbox_config)
  return sandbox_config_;
}
inline void PullImageRequest::set_allocated_sandbox_config(::runtime::PodSandboxConfig* sandbox_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sandbox_config_;
  }
  if (sandbox_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sandbox_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sandbox_config, submessage_arena);
    }
    
  } else {
    
  }
  sandbox_config_ = sandbox_config;
  // @@protoc_insertion_point(field_set_allocated:runtime.PullImageRequest.sandbox_config)
}

// -------------------------------------------------------------------

// PullImageResponse

// string image_ref = 1;
inline void PullImageResponse::clear_image_ref() {
  image_ref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PullImageResponse::image_ref() const {
  // @@protoc_insertion_point(field_get:runtime.PullImageResponse.image_ref)
  return image_ref_.GetNoArena();
}
inline void PullImageResponse::set_image_ref(const ::std::string& value) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.PullImageResponse.image_ref)
}
#if LANG_CXX11
inline void PullImageResponse::set_image_ref(::std::string&& value) {
  
  image_ref_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.PullImageResponse.image_ref)
}
#endif
inline void PullImageResponse::set_image_ref(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.PullImageResponse.image_ref)
}
inline void PullImageResponse::set_image_ref(const char* value, size_t size) {
  
  image_ref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.PullImageResponse.image_ref)
}
inline ::std::string* PullImageResponse::mutable_image_ref() {
  
  // @@protoc_insertion_point(field_mutable:runtime.PullImageResponse.image_ref)
  return image_ref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PullImageResponse::release_image_ref() {
  // @@protoc_insertion_point(field_release:runtime.PullImageResponse.image_ref)
  
  return image_ref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PullImageResponse::set_allocated_image_ref(::std::string* image_ref) {
  if (image_ref != NULL) {
    
  } else {
    
  }
  image_ref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_ref);
  // @@protoc_insertion_point(field_set_allocated:runtime.PullImageResponse.image_ref)
}

// -------------------------------------------------------------------

// RemoveImageRequest

// .runtime.ImageSpec image = 1;
inline bool RemoveImageRequest::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void RemoveImageRequest::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::runtime::ImageSpec& RemoveImageRequest::image() const {
  const ::runtime::ImageSpec* p = image_;
  // @@protoc_insertion_point(field_get:runtime.RemoveImageRequest.image)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ImageSpec*>(
      &::runtime::_ImageSpec_default_instance_);
}
inline ::runtime::ImageSpec* RemoveImageRequest::release_image() {
  // @@protoc_insertion_point(field_release:runtime.RemoveImageRequest.image)
  
  ::runtime::ImageSpec* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::runtime::ImageSpec* RemoveImageRequest::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::runtime::ImageSpec;
  }
  // @@protoc_insertion_point(field_mutable:runtime.RemoveImageRequest.image)
  return image_;
}
inline void RemoveImageRequest::set_allocated_image(::runtime::ImageSpec* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:runtime.RemoveImageRequest.image)
}

// -------------------------------------------------------------------

// RemoveImageResponse

// -------------------------------------------------------------------

// NetworkConfig

// string pod_cidr = 1;
inline void NetworkConfig::clear_pod_cidr() {
  pod_cidr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkConfig::pod_cidr() const {
  // @@protoc_insertion_point(field_get:runtime.NetworkConfig.pod_cidr)
  return pod_cidr_.GetNoArena();
}
inline void NetworkConfig::set_pod_cidr(const ::std::string& value) {
  
  pod_cidr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.NetworkConfig.pod_cidr)
}
#if LANG_CXX11
inline void NetworkConfig::set_pod_cidr(::std::string&& value) {
  
  pod_cidr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.NetworkConfig.pod_cidr)
}
#endif
inline void NetworkConfig::set_pod_cidr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_cidr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.NetworkConfig.pod_cidr)
}
inline void NetworkConfig::set_pod_cidr(const char* value, size_t size) {
  
  pod_cidr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.NetworkConfig.pod_cidr)
}
inline ::std::string* NetworkConfig::mutable_pod_cidr() {
  
  // @@protoc_insertion_point(field_mutable:runtime.NetworkConfig.pod_cidr)
  return pod_cidr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkConfig::release_pod_cidr() {
  // @@protoc_insertion_point(field_release:runtime.NetworkConfig.pod_cidr)
  
  return pod_cidr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkConfig::set_allocated_pod_cidr(::std::string* pod_cidr) {
  if (pod_cidr != NULL) {
    
  } else {
    
  }
  pod_cidr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_cidr);
  // @@protoc_insertion_point(field_set_allocated:runtime.NetworkConfig.pod_cidr)
}

// -------------------------------------------------------------------

// RuntimeConfig

// .runtime.NetworkConfig network_config = 1;
inline bool RuntimeConfig::has_network_config() const {
  return this != internal_default_instance() && network_config_ != NULL;
}
inline void RuntimeConfig::clear_network_config() {
  if (GetArenaNoVirtual() == NULL && network_config_ != NULL) {
    delete network_config_;
  }
  network_config_ = NULL;
}
inline const ::runtime::NetworkConfig& RuntimeConfig::network_config() const {
  const ::runtime::NetworkConfig* p = network_config_;
  // @@protoc_insertion_point(field_get:runtime.RuntimeConfig.network_config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::NetworkConfig*>(
      &::runtime::_NetworkConfig_default_instance_);
}
inline ::runtime::NetworkConfig* RuntimeConfig::release_network_config() {
  // @@protoc_insertion_point(field_release:runtime.RuntimeConfig.network_config)
  
  ::runtime::NetworkConfig* temp = network_config_;
  network_config_ = NULL;
  return temp;
}
inline ::runtime::NetworkConfig* RuntimeConfig::mutable_network_config() {
  
  if (network_config_ == NULL) {
    network_config_ = new ::runtime::NetworkConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.RuntimeConfig.network_config)
  return network_config_;
}
inline void RuntimeConfig::set_allocated_network_config(::runtime::NetworkConfig* network_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete network_config_;
  }
  if (network_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      network_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, network_config, submessage_arena);
    }
    
  } else {
    
  }
  network_config_ = network_config;
  // @@protoc_insertion_point(field_set_allocated:runtime.RuntimeConfig.network_config)
}

// -------------------------------------------------------------------

// UpdateRuntimeConfigRequest

// .runtime.RuntimeConfig runtime_config = 1;
inline bool UpdateRuntimeConfigRequest::has_runtime_config() const {
  return this != internal_default_instance() && runtime_config_ != NULL;
}
inline void UpdateRuntimeConfigRequest::clear_runtime_config() {
  if (GetArenaNoVirtual() == NULL && runtime_config_ != NULL) {
    delete runtime_config_;
  }
  runtime_config_ = NULL;
}
inline const ::runtime::RuntimeConfig& UpdateRuntimeConfigRequest::runtime_config() const {
  const ::runtime::RuntimeConfig* p = runtime_config_;
  // @@protoc_insertion_point(field_get:runtime.UpdateRuntimeConfigRequest.runtime_config)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::RuntimeConfig*>(
      &::runtime::_RuntimeConfig_default_instance_);
}
inline ::runtime::RuntimeConfig* UpdateRuntimeConfigRequest::release_runtime_config() {
  // @@protoc_insertion_point(field_release:runtime.UpdateRuntimeConfigRequest.runtime_config)
  
  ::runtime::RuntimeConfig* temp = runtime_config_;
  runtime_config_ = NULL;
  return temp;
}
inline ::runtime::RuntimeConfig* UpdateRuntimeConfigRequest::mutable_runtime_config() {
  
  if (runtime_config_ == NULL) {
    runtime_config_ = new ::runtime::RuntimeConfig;
  }
  // @@protoc_insertion_point(field_mutable:runtime.UpdateRuntimeConfigRequest.runtime_config)
  return runtime_config_;
}
inline void UpdateRuntimeConfigRequest::set_allocated_runtime_config(::runtime::RuntimeConfig* runtime_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete runtime_config_;
  }
  if (runtime_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      runtime_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, runtime_config, submessage_arena);
    }
    
  } else {
    
  }
  runtime_config_ = runtime_config;
  // @@protoc_insertion_point(field_set_allocated:runtime.UpdateRuntimeConfigRequest.runtime_config)
}

// -------------------------------------------------------------------

// UpdateRuntimeConfigResponse

// -------------------------------------------------------------------

// RuntimeCondition

// string type = 1;
inline void RuntimeCondition::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeCondition::type() const {
  // @@protoc_insertion_point(field_get:runtime.RuntimeCondition.type)
  return type_.GetNoArena();
}
inline void RuntimeCondition::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RuntimeCondition.type)
}
#if LANG_CXX11
inline void RuntimeCondition::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RuntimeCondition.type)
}
#endif
inline void RuntimeCondition::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RuntimeCondition.type)
}
inline void RuntimeCondition::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RuntimeCondition.type)
}
inline ::std::string* RuntimeCondition::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RuntimeCondition.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeCondition::release_type() {
  // @@protoc_insertion_point(field_release:runtime.RuntimeCondition.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeCondition::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:runtime.RuntimeCondition.type)
}

// bool status = 2;
inline void RuntimeCondition::clear_status() {
  status_ = false;
}
inline bool RuntimeCondition::status() const {
  // @@protoc_insertion_point(field_get:runtime.RuntimeCondition.status)
  return status_;
}
inline void RuntimeCondition::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:runtime.RuntimeCondition.status)
}

// string reason = 3;
inline void RuntimeCondition::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeCondition::reason() const {
  // @@protoc_insertion_point(field_get:runtime.RuntimeCondition.reason)
  return reason_.GetNoArena();
}
inline void RuntimeCondition::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RuntimeCondition.reason)
}
#if LANG_CXX11
inline void RuntimeCondition::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RuntimeCondition.reason)
}
#endif
inline void RuntimeCondition::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RuntimeCondition.reason)
}
inline void RuntimeCondition::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RuntimeCondition.reason)
}
inline ::std::string* RuntimeCondition::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RuntimeCondition.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeCondition::release_reason() {
  // @@protoc_insertion_point(field_release:runtime.RuntimeCondition.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeCondition::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:runtime.RuntimeCondition.reason)
}

// string message = 4;
inline void RuntimeCondition::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeCondition::message() const {
  // @@protoc_insertion_point(field_get:runtime.RuntimeCondition.message)
  return message_.GetNoArena();
}
inline void RuntimeCondition::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.RuntimeCondition.message)
}
#if LANG_CXX11
inline void RuntimeCondition::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.RuntimeCondition.message)
}
#endif
inline void RuntimeCondition::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.RuntimeCondition.message)
}
inline void RuntimeCondition::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.RuntimeCondition.message)
}
inline ::std::string* RuntimeCondition::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:runtime.RuntimeCondition.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeCondition::release_message() {
  // @@protoc_insertion_point(field_release:runtime.RuntimeCondition.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeCondition::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:runtime.RuntimeCondition.message)
}

// -------------------------------------------------------------------

// RuntimeStatus

// repeated .runtime.RuntimeCondition conditions = 1;
inline int RuntimeStatus::conditions_size() const {
  return conditions_.size();
}
inline void RuntimeStatus::clear_conditions() {
  conditions_.Clear();
}
inline const ::runtime::RuntimeCondition& RuntimeStatus::conditions(int index) const {
  // @@protoc_insertion_point(field_get:runtime.RuntimeStatus.conditions)
  return conditions_.Get(index);
}
inline ::runtime::RuntimeCondition* RuntimeStatus::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.RuntimeStatus.conditions)
  return conditions_.Mutable(index);
}
inline ::runtime::RuntimeCondition* RuntimeStatus::add_conditions() {
  // @@protoc_insertion_point(field_add:runtime.RuntimeStatus.conditions)
  return conditions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::RuntimeCondition >*
RuntimeStatus::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:runtime.RuntimeStatus.conditions)
  return &conditions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::RuntimeCondition >&
RuntimeStatus::conditions() const {
  // @@protoc_insertion_point(field_list:runtime.RuntimeStatus.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// StatusRequest

// bool verbose = 1;
inline void StatusRequest::clear_verbose() {
  verbose_ = false;
}
inline bool StatusRequest::verbose() const {
  // @@protoc_insertion_point(field_get:runtime.StatusRequest.verbose)
  return verbose_;
}
inline void StatusRequest::set_verbose(bool value) {
  
  verbose_ = value;
  // @@protoc_insertion_point(field_set:runtime.StatusRequest.verbose)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StatusResponse

// .runtime.RuntimeStatus status = 1;
inline bool StatusResponse::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void StatusResponse::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::runtime::RuntimeStatus& StatusResponse::status() const {
  const ::runtime::RuntimeStatus* p = status_;
  // @@protoc_insertion_point(field_get:runtime.StatusResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::RuntimeStatus*>(
      &::runtime::_RuntimeStatus_default_instance_);
}
inline ::runtime::RuntimeStatus* StatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:runtime.StatusResponse.status)
  
  ::runtime::RuntimeStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::runtime::RuntimeStatus* StatusResponse::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::runtime::RuntimeStatus;
  }
  // @@protoc_insertion_point(field_mutable:runtime.StatusResponse.status)
  return status_;
}
inline void StatusResponse::set_allocated_status(::runtime::RuntimeStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:runtime.StatusResponse.status)
}

// map<string, string> info = 2;
inline int StatusResponse::info_size() const {
  return info_.size();
}
inline void StatusResponse::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
StatusResponse::info() const {
  // @@protoc_insertion_point(field_map:runtime.StatusResponse.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
StatusResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:runtime.StatusResponse.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// ImageFsInfoRequest

// -------------------------------------------------------------------

// UInt64Value

// uint64 value = 1;
inline void UInt64Value::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UInt64Value::value() const {
  // @@protoc_insertion_point(field_get:runtime.UInt64Value.value)
  return value_;
}
inline void UInt64Value::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:runtime.UInt64Value.value)
}

// -------------------------------------------------------------------

// StorageIdentifier

// string uuid = 1;
inline void StorageIdentifier::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StorageIdentifier::uuid() const {
  // @@protoc_insertion_point(field_get:runtime.StorageIdentifier.uuid)
  return uuid_.GetNoArena();
}
inline void StorageIdentifier::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.StorageIdentifier.uuid)
}
#if LANG_CXX11
inline void StorageIdentifier::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.StorageIdentifier.uuid)
}
#endif
inline void StorageIdentifier::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.StorageIdentifier.uuid)
}
inline void StorageIdentifier::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.StorageIdentifier.uuid)
}
inline ::std::string* StorageIdentifier::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:runtime.StorageIdentifier.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageIdentifier::release_uuid() {
  // @@protoc_insertion_point(field_release:runtime.StorageIdentifier.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageIdentifier::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:runtime.StorageIdentifier.uuid)
}

// -------------------------------------------------------------------

// FilesystemUsage

// int64 timestamp = 1;
inline void FilesystemUsage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FilesystemUsage::timestamp() const {
  // @@protoc_insertion_point(field_get:runtime.FilesystemUsage.timestamp)
  return timestamp_;
}
inline void FilesystemUsage::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:runtime.FilesystemUsage.timestamp)
}

// .runtime.StorageIdentifier storage_id = 2;
inline bool FilesystemUsage::has_storage_id() const {
  return this != internal_default_instance() && storage_id_ != NULL;
}
inline void FilesystemUsage::clear_storage_id() {
  if (GetArenaNoVirtual() == NULL && storage_id_ != NULL) {
    delete storage_id_;
  }
  storage_id_ = NULL;
}
inline const ::runtime::StorageIdentifier& FilesystemUsage::storage_id() const {
  const ::runtime::StorageIdentifier* p = storage_id_;
  // @@protoc_insertion_point(field_get:runtime.FilesystemUsage.storage_id)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::StorageIdentifier*>(
      &::runtime::_StorageIdentifier_default_instance_);
}
inline ::runtime::StorageIdentifier* FilesystemUsage::release_storage_id() {
  // @@protoc_insertion_point(field_release:runtime.FilesystemUsage.storage_id)
  
  ::runtime::StorageIdentifier* temp = storage_id_;
  storage_id_ = NULL;
  return temp;
}
inline ::runtime::StorageIdentifier* FilesystemUsage::mutable_storage_id() {
  
  if (storage_id_ == NULL) {
    storage_id_ = new ::runtime::StorageIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:runtime.FilesystemUsage.storage_id)
  return storage_id_;
}
inline void FilesystemUsage::set_allocated_storage_id(::runtime::StorageIdentifier* storage_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete storage_id_;
  }
  if (storage_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      storage_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, storage_id, submessage_arena);
    }
    
  } else {
    
  }
  storage_id_ = storage_id;
  // @@protoc_insertion_point(field_set_allocated:runtime.FilesystemUsage.storage_id)
}

// .runtime.UInt64Value used_bytes = 3;
inline bool FilesystemUsage::has_used_bytes() const {
  return this != internal_default_instance() && used_bytes_ != NULL;
}
inline void FilesystemUsage::clear_used_bytes() {
  if (GetArenaNoVirtual() == NULL && used_bytes_ != NULL) {
    delete used_bytes_;
  }
  used_bytes_ = NULL;
}
inline const ::runtime::UInt64Value& FilesystemUsage::used_bytes() const {
  const ::runtime::UInt64Value* p = used_bytes_;
  // @@protoc_insertion_point(field_get:runtime.FilesystemUsage.used_bytes)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::UInt64Value*>(
      &::runtime::_UInt64Value_default_instance_);
}
inline ::runtime::UInt64Value* FilesystemUsage::release_used_bytes() {
  // @@protoc_insertion_point(field_release:runtime.FilesystemUsage.used_bytes)
  
  ::runtime::UInt64Value* temp = used_bytes_;
  used_bytes_ = NULL;
  return temp;
}
inline ::runtime::UInt64Value* FilesystemUsage::mutable_used_bytes() {
  
  if (used_bytes_ == NULL) {
    used_bytes_ = new ::runtime::UInt64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.FilesystemUsage.used_bytes)
  return used_bytes_;
}
inline void FilesystemUsage::set_allocated_used_bytes(::runtime::UInt64Value* used_bytes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete used_bytes_;
  }
  if (used_bytes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      used_bytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, used_bytes, submessage_arena);
    }
    
  } else {
    
  }
  used_bytes_ = used_bytes;
  // @@protoc_insertion_point(field_set_allocated:runtime.FilesystemUsage.used_bytes)
}

// .runtime.UInt64Value inodes_used = 4;
inline bool FilesystemUsage::has_inodes_used() const {
  return this != internal_default_instance() && inodes_used_ != NULL;
}
inline void FilesystemUsage::clear_inodes_used() {
  if (GetArenaNoVirtual() == NULL && inodes_used_ != NULL) {
    delete inodes_used_;
  }
  inodes_used_ = NULL;
}
inline const ::runtime::UInt64Value& FilesystemUsage::inodes_used() const {
  const ::runtime::UInt64Value* p = inodes_used_;
  // @@protoc_insertion_point(field_get:runtime.FilesystemUsage.inodes_used)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::UInt64Value*>(
      &::runtime::_UInt64Value_default_instance_);
}
inline ::runtime::UInt64Value* FilesystemUsage::release_inodes_used() {
  // @@protoc_insertion_point(field_release:runtime.FilesystemUsage.inodes_used)
  
  ::runtime::UInt64Value* temp = inodes_used_;
  inodes_used_ = NULL;
  return temp;
}
inline ::runtime::UInt64Value* FilesystemUsage::mutable_inodes_used() {
  
  if (inodes_used_ == NULL) {
    inodes_used_ = new ::runtime::UInt64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.FilesystemUsage.inodes_used)
  return inodes_used_;
}
inline void FilesystemUsage::set_allocated_inodes_used(::runtime::UInt64Value* inodes_used) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inodes_used_;
  }
  if (inodes_used) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      inodes_used = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inodes_used, submessage_arena);
    }
    
  } else {
    
  }
  inodes_used_ = inodes_used;
  // @@protoc_insertion_point(field_set_allocated:runtime.FilesystemUsage.inodes_used)
}

// -------------------------------------------------------------------

// ImageFsInfoResponse

// repeated .runtime.FilesystemUsage image_filesystems = 1;
inline int ImageFsInfoResponse::image_filesystems_size() const {
  return image_filesystems_.size();
}
inline void ImageFsInfoResponse::clear_image_filesystems() {
  image_filesystems_.Clear();
}
inline const ::runtime::FilesystemUsage& ImageFsInfoResponse::image_filesystems(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ImageFsInfoResponse.image_filesystems)
  return image_filesystems_.Get(index);
}
inline ::runtime::FilesystemUsage* ImageFsInfoResponse::mutable_image_filesystems(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ImageFsInfoResponse.image_filesystems)
  return image_filesystems_.Mutable(index);
}
inline ::runtime::FilesystemUsage* ImageFsInfoResponse::add_image_filesystems() {
  // @@protoc_insertion_point(field_add:runtime.ImageFsInfoResponse.image_filesystems)
  return image_filesystems_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::FilesystemUsage >*
ImageFsInfoResponse::mutable_image_filesystems() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ImageFsInfoResponse.image_filesystems)
  return &image_filesystems_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::FilesystemUsage >&
ImageFsInfoResponse::image_filesystems() const {
  // @@protoc_insertion_point(field_list:runtime.ImageFsInfoResponse.image_filesystems)
  return image_filesystems_;
}

// -------------------------------------------------------------------

// ContainerStatsRequest

// string container_id = 1;
inline void ContainerStatsRequest::clear_container_id() {
  container_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatsRequest::container_id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatsRequest.container_id)
  return container_id_.GetNoArena();
}
inline void ContainerStatsRequest::set_container_id(const ::std::string& value) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatsRequest.container_id)
}
#if LANG_CXX11
inline void ContainerStatsRequest::set_container_id(::std::string&& value) {
  
  container_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatsRequest.container_id)
}
#endif
inline void ContainerStatsRequest::set_container_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatsRequest.container_id)
}
inline void ContainerStatsRequest::set_container_id(const char* value, size_t size) {
  
  container_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatsRequest.container_id)
}
inline ::std::string* ContainerStatsRequest::mutable_container_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatsRequest.container_id)
  return container_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatsRequest::release_container_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatsRequest.container_id)
  
  return container_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatsRequest::set_allocated_container_id(::std::string* container_id) {
  if (container_id != NULL) {
    
  } else {
    
  }
  container_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatsRequest.container_id)
}

// -------------------------------------------------------------------

// ContainerStatsResponse

// .runtime.ContainerStats stats = 1;
inline bool ContainerStatsResponse::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void ContainerStatsResponse::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
}
inline const ::runtime::ContainerStats& ContainerStatsResponse::stats() const {
  const ::runtime::ContainerStats* p = stats_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStatsResponse.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerStats*>(
      &::runtime::_ContainerStats_default_instance_);
}
inline ::runtime::ContainerStats* ContainerStatsResponse::release_stats() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatsResponse.stats)
  
  ::runtime::ContainerStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::runtime::ContainerStats* ContainerStatsResponse::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::runtime::ContainerStats;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatsResponse.stats)
  return stats_;
}
inline void ContainerStatsResponse::set_allocated_stats(::runtime::ContainerStats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatsResponse.stats)
}

// -------------------------------------------------------------------

// ListContainerStatsRequest

// .runtime.ContainerStatsFilter filter = 1;
inline bool ListContainerStatsRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void ListContainerStatsRequest::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::runtime::ContainerStatsFilter& ListContainerStatsRequest::filter() const {
  const ::runtime::ContainerStatsFilter* p = filter_;
  // @@protoc_insertion_point(field_get:runtime.ListContainerStatsRequest.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerStatsFilter*>(
      &::runtime::_ContainerStatsFilter_default_instance_);
}
inline ::runtime::ContainerStatsFilter* ListContainerStatsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:runtime.ListContainerStatsRequest.filter)
  
  ::runtime::ContainerStatsFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::runtime::ContainerStatsFilter* ListContainerStatsRequest::mutable_filter() {
  
  if (filter_ == NULL) {
    filter_ = new ::runtime::ContainerStatsFilter;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ListContainerStatsRequest.filter)
  return filter_;
}
inline void ListContainerStatsRequest::set_allocated_filter(::runtime::ContainerStatsFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:runtime.ListContainerStatsRequest.filter)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerStatsFilter

// string id = 1;
inline void ContainerStatsFilter::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatsFilter::id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatsFilter.id)
  return id_.GetNoArena();
}
inline void ContainerStatsFilter::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatsFilter.id)
}
#if LANG_CXX11
inline void ContainerStatsFilter::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatsFilter.id)
}
#endif
inline void ContainerStatsFilter::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatsFilter.id)
}
inline void ContainerStatsFilter::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatsFilter.id)
}
inline ::std::string* ContainerStatsFilter::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatsFilter.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatsFilter::release_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatsFilter.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatsFilter::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatsFilter.id)
}

// string pod_sandbox_id = 2;
inline void ContainerStatsFilter::clear_pod_sandbox_id() {
  pod_sandbox_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerStatsFilter::pod_sandbox_id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerStatsFilter.pod_sandbox_id)
  return pod_sandbox_id_.GetNoArena();
}
inline void ContainerStatsFilter::set_pod_sandbox_id(const ::std::string& value) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerStatsFilter.pod_sandbox_id)
}
#if LANG_CXX11
inline void ContainerStatsFilter::set_pod_sandbox_id(::std::string&& value) {
  
  pod_sandbox_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerStatsFilter.pod_sandbox_id)
}
#endif
inline void ContainerStatsFilter::set_pod_sandbox_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerStatsFilter.pod_sandbox_id)
}
inline void ContainerStatsFilter::set_pod_sandbox_id(const char* value, size_t size) {
  
  pod_sandbox_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerStatsFilter.pod_sandbox_id)
}
inline ::std::string* ContainerStatsFilter::mutable_pod_sandbox_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStatsFilter.pod_sandbox_id)
  return pod_sandbox_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerStatsFilter::release_pod_sandbox_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStatsFilter.pod_sandbox_id)
  
  return pod_sandbox_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerStatsFilter::set_allocated_pod_sandbox_id(::std::string* pod_sandbox_id) {
  if (pod_sandbox_id != NULL) {
    
  } else {
    
  }
  pod_sandbox_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pod_sandbox_id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStatsFilter.pod_sandbox_id)
}

// map<string, string> label_selector = 3;
inline int ContainerStatsFilter::label_selector_size() const {
  return label_selector_.size();
}
inline void ContainerStatsFilter::clear_label_selector() {
  label_selector_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerStatsFilter::label_selector() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerStatsFilter.label_selector)
  return label_selector_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerStatsFilter::mutable_label_selector() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerStatsFilter.label_selector)
  return label_selector_.MutableMap();
}

// -------------------------------------------------------------------

// ListContainerStatsResponse

// repeated .runtime.ContainerStats stats = 1;
inline int ListContainerStatsResponse::stats_size() const {
  return stats_.size();
}
inline void ListContainerStatsResponse::clear_stats() {
  stats_.Clear();
}
inline const ::runtime::ContainerStats& ListContainerStatsResponse::stats(int index) const {
  // @@protoc_insertion_point(field_get:runtime.ListContainerStatsResponse.stats)
  return stats_.Get(index);
}
inline ::runtime::ContainerStats* ListContainerStatsResponse::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:runtime.ListContainerStatsResponse.stats)
  return stats_.Mutable(index);
}
inline ::runtime::ContainerStats* ListContainerStatsResponse::add_stats() {
  // @@protoc_insertion_point(field_add:runtime.ListContainerStatsResponse.stats)
  return stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::runtime::ContainerStats >*
ListContainerStatsResponse::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:runtime.ListContainerStatsResponse.stats)
  return &stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::runtime::ContainerStats >&
ListContainerStatsResponse::stats() const {
  // @@protoc_insertion_point(field_list:runtime.ListContainerStatsResponse.stats)
  return stats_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContainerAttributes

// string id = 1;
inline void ContainerAttributes::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContainerAttributes::id() const {
  // @@protoc_insertion_point(field_get:runtime.ContainerAttributes.id)
  return id_.GetNoArena();
}
inline void ContainerAttributes::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:runtime.ContainerAttributes.id)
}
#if LANG_CXX11
inline void ContainerAttributes::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:runtime.ContainerAttributes.id)
}
#endif
inline void ContainerAttributes::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:runtime.ContainerAttributes.id)
}
inline void ContainerAttributes::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:runtime.ContainerAttributes.id)
}
inline ::std::string* ContainerAttributes::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:runtime.ContainerAttributes.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContainerAttributes::release_id() {
  // @@protoc_insertion_point(field_release:runtime.ContainerAttributes.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContainerAttributes::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerAttributes.id)
}

// .runtime.ContainerMetadata metadata = 2;
inline bool ContainerAttributes::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void ContainerAttributes::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::runtime::ContainerMetadata& ContainerAttributes::metadata() const {
  const ::runtime::ContainerMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:runtime.ContainerAttributes.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerMetadata*>(
      &::runtime::_ContainerMetadata_default_instance_);
}
inline ::runtime::ContainerMetadata* ContainerAttributes::release_metadata() {
  // @@protoc_insertion_point(field_release:runtime.ContainerAttributes.metadata)
  
  ::runtime::ContainerMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::runtime::ContainerMetadata* ContainerAttributes::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::runtime::ContainerMetadata;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerAttributes.metadata)
  return metadata_;
}
inline void ContainerAttributes::set_allocated_metadata(::runtime::ContainerMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerAttributes.metadata)
}

// map<string, string> labels = 3;
inline int ContainerAttributes::labels_size() const {
  return labels_.size();
}
inline void ContainerAttributes::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerAttributes::labels() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerAttributes.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerAttributes::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerAttributes.labels)
  return labels_.MutableMap();
}

// map<string, string> annotations = 4;
inline int ContainerAttributes::annotations_size() const {
  return annotations_.size();
}
inline void ContainerAttributes::clear_annotations() {
  annotations_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ContainerAttributes::annotations() const {
  // @@protoc_insertion_point(field_map:runtime.ContainerAttributes.annotations)
  return annotations_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ContainerAttributes::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:runtime.ContainerAttributes.annotations)
  return annotations_.MutableMap();
}

// -------------------------------------------------------------------

// ContainerStats

// .runtime.ContainerAttributes attributes = 1;
inline bool ContainerStats::has_attributes() const {
  return this != internal_default_instance() && attributes_ != NULL;
}
inline void ContainerStats::clear_attributes() {
  if (GetArenaNoVirtual() == NULL && attributes_ != NULL) {
    delete attributes_;
  }
  attributes_ = NULL;
}
inline const ::runtime::ContainerAttributes& ContainerStats::attributes() const {
  const ::runtime::ContainerAttributes* p = attributes_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStats.attributes)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::ContainerAttributes*>(
      &::runtime::_ContainerAttributes_default_instance_);
}
inline ::runtime::ContainerAttributes* ContainerStats::release_attributes() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStats.attributes)
  
  ::runtime::ContainerAttributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline ::runtime::ContainerAttributes* ContainerStats::mutable_attributes() {
  
  if (attributes_ == NULL) {
    attributes_ = new ::runtime::ContainerAttributes;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStats.attributes)
  return attributes_;
}
inline void ContainerStats::set_allocated_attributes(::runtime::ContainerAttributes* attributes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attributes_;
  }
  if (attributes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attributes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStats.attributes)
}

// .runtime.CpuUsage cpu = 2;
inline bool ContainerStats::has_cpu() const {
  return this != internal_default_instance() && cpu_ != NULL;
}
inline void ContainerStats::clear_cpu() {
  if (GetArenaNoVirtual() == NULL && cpu_ != NULL) {
    delete cpu_;
  }
  cpu_ = NULL;
}
inline const ::runtime::CpuUsage& ContainerStats::cpu() const {
  const ::runtime::CpuUsage* p = cpu_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStats.cpu)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::CpuUsage*>(
      &::runtime::_CpuUsage_default_instance_);
}
inline ::runtime::CpuUsage* ContainerStats::release_cpu() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStats.cpu)
  
  ::runtime::CpuUsage* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline ::runtime::CpuUsage* ContainerStats::mutable_cpu() {
  
  if (cpu_ == NULL) {
    cpu_ = new ::runtime::CpuUsage;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStats.cpu)
  return cpu_;
}
inline void ContainerStats::set_allocated_cpu(::runtime::CpuUsage* cpu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cpu_;
  }
  if (cpu) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cpu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    
  } else {
    
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStats.cpu)
}

// .runtime.MemoryUsage memory = 3;
inline bool ContainerStats::has_memory() const {
  return this != internal_default_instance() && memory_ != NULL;
}
inline void ContainerStats::clear_memory() {
  if (GetArenaNoVirtual() == NULL && memory_ != NULL) {
    delete memory_;
  }
  memory_ = NULL;
}
inline const ::runtime::MemoryUsage& ContainerStats::memory() const {
  const ::runtime::MemoryUsage* p = memory_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStats.memory)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::MemoryUsage*>(
      &::runtime::_MemoryUsage_default_instance_);
}
inline ::runtime::MemoryUsage* ContainerStats::release_memory() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStats.memory)
  
  ::runtime::MemoryUsage* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline ::runtime::MemoryUsage* ContainerStats::mutable_memory() {
  
  if (memory_ == NULL) {
    memory_ = new ::runtime::MemoryUsage;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStats.memory)
  return memory_;
}
inline void ContainerStats::set_allocated_memory(::runtime::MemoryUsage* memory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete memory_;
  }
  if (memory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      memory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, memory, submessage_arena);
    }
    
  } else {
    
  }
  memory_ = memory;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStats.memory)
}

// .runtime.FilesystemUsage writable_layer = 4;
inline bool ContainerStats::has_writable_layer() const {
  return this != internal_default_instance() && writable_layer_ != NULL;
}
inline void ContainerStats::clear_writable_layer() {
  if (GetArenaNoVirtual() == NULL && writable_layer_ != NULL) {
    delete writable_layer_;
  }
  writable_layer_ = NULL;
}
inline const ::runtime::FilesystemUsage& ContainerStats::writable_layer() const {
  const ::runtime::FilesystemUsage* p = writable_layer_;
  // @@protoc_insertion_point(field_get:runtime.ContainerStats.writable_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::FilesystemUsage*>(
      &::runtime::_FilesystemUsage_default_instance_);
}
inline ::runtime::FilesystemUsage* ContainerStats::release_writable_layer() {
  // @@protoc_insertion_point(field_release:runtime.ContainerStats.writable_layer)
  
  ::runtime::FilesystemUsage* temp = writable_layer_;
  writable_layer_ = NULL;
  return temp;
}
inline ::runtime::FilesystemUsage* ContainerStats::mutable_writable_layer() {
  
  if (writable_layer_ == NULL) {
    writable_layer_ = new ::runtime::FilesystemUsage;
  }
  // @@protoc_insertion_point(field_mutable:runtime.ContainerStats.writable_layer)
  return writable_layer_;
}
inline void ContainerStats::set_allocated_writable_layer(::runtime::FilesystemUsage* writable_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete writable_layer_;
  }
  if (writable_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      writable_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, writable_layer, submessage_arena);
    }
    
  } else {
    
  }
  writable_layer_ = writable_layer;
  // @@protoc_insertion_point(field_set_allocated:runtime.ContainerStats.writable_layer)
}

// -------------------------------------------------------------------

// CpuUsage

// int64 timestamp = 1;
inline void CpuUsage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CpuUsage::timestamp() const {
  // @@protoc_insertion_point(field_get:runtime.CpuUsage.timestamp)
  return timestamp_;
}
inline void CpuUsage::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:runtime.CpuUsage.timestamp)
}

// .runtime.UInt64Value usage_core_nano_seconds = 2;
inline bool CpuUsage::has_usage_core_nano_seconds() const {
  return this != internal_default_instance() && usage_core_nano_seconds_ != NULL;
}
inline void CpuUsage::clear_usage_core_nano_seconds() {
  if (GetArenaNoVirtual() == NULL && usage_core_nano_seconds_ != NULL) {
    delete usage_core_nano_seconds_;
  }
  usage_core_nano_seconds_ = NULL;
}
inline const ::runtime::UInt64Value& CpuUsage::usage_core_nano_seconds() const {
  const ::runtime::UInt64Value* p = usage_core_nano_seconds_;
  // @@protoc_insertion_point(field_get:runtime.CpuUsage.usage_core_nano_seconds)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::UInt64Value*>(
      &::runtime::_UInt64Value_default_instance_);
}
inline ::runtime::UInt64Value* CpuUsage::release_usage_core_nano_seconds() {
  // @@protoc_insertion_point(field_release:runtime.CpuUsage.usage_core_nano_seconds)
  
  ::runtime::UInt64Value* temp = usage_core_nano_seconds_;
  usage_core_nano_seconds_ = NULL;
  return temp;
}
inline ::runtime::UInt64Value* CpuUsage::mutable_usage_core_nano_seconds() {
  
  if (usage_core_nano_seconds_ == NULL) {
    usage_core_nano_seconds_ = new ::runtime::UInt64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.CpuUsage.usage_core_nano_seconds)
  return usage_core_nano_seconds_;
}
inline void CpuUsage::set_allocated_usage_core_nano_seconds(::runtime::UInt64Value* usage_core_nano_seconds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete usage_core_nano_seconds_;
  }
  if (usage_core_nano_seconds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      usage_core_nano_seconds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, usage_core_nano_seconds, submessage_arena);
    }
    
  } else {
    
  }
  usage_core_nano_seconds_ = usage_core_nano_seconds;
  // @@protoc_insertion_point(field_set_allocated:runtime.CpuUsage.usage_core_nano_seconds)
}

// -------------------------------------------------------------------

// MemoryUsage

// int64 timestamp = 1;
inline void MemoryUsage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MemoryUsage::timestamp() const {
  // @@protoc_insertion_point(field_get:runtime.MemoryUsage.timestamp)
  return timestamp_;
}
inline void MemoryUsage::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:runtime.MemoryUsage.timestamp)
}

// .runtime.UInt64Value working_set_bytes = 2;
inline bool MemoryUsage::has_working_set_bytes() const {
  return this != internal_default_instance() && working_set_bytes_ != NULL;
}
inline void MemoryUsage::clear_working_set_bytes() {
  if (GetArenaNoVirtual() == NULL && working_set_bytes_ != NULL) {
    delete working_set_bytes_;
  }
  working_set_bytes_ = NULL;
}
inline const ::runtime::UInt64Value& MemoryUsage::working_set_bytes() const {
  const ::runtime::UInt64Value* p = working_set_bytes_;
  // @@protoc_insertion_point(field_get:runtime.MemoryUsage.working_set_bytes)
  return p != NULL ? *p : *reinterpret_cast<const ::runtime::UInt64Value*>(
      &::runtime::_UInt64Value_default_instance_);
}
inline ::runtime::UInt64Value* MemoryUsage::release_working_set_bytes() {
  // @@protoc_insertion_point(field_release:runtime.MemoryUsage.working_set_bytes)
  
  ::runtime::UInt64Value* temp = working_set_bytes_;
  working_set_bytes_ = NULL;
  return temp;
}
inline ::runtime::UInt64Value* MemoryUsage::mutable_working_set_bytes() {
  
  if (working_set_bytes_ == NULL) {
    working_set_bytes_ = new ::runtime::UInt64Value;
  }
  // @@protoc_insertion_point(field_mutable:runtime.MemoryUsage.working_set_bytes)
  return working_set_bytes_;
}
inline void MemoryUsage::set_allocated_working_set_bytes(::runtime::UInt64Value* working_set_bytes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete working_set_bytes_;
  }
  if (working_set_bytes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      working_set_bytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, working_set_bytes, submessage_arena);
    }
    
  } else {
    
  }
  working_set_bytes_ = working_set_bytes;
  // @@protoc_insertion_point(field_set_allocated:runtime.MemoryUsage.working_set_bytes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace runtime

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::runtime::Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::Protocol>() {
  return ::runtime::Protocol_descriptor();
}
template <> struct is_proto_enum< ::runtime::MountPropagation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::MountPropagation>() {
  return ::runtime::MountPropagation_descriptor();
}
template <> struct is_proto_enum< ::runtime::PodSandboxState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::PodSandboxState>() {
  return ::runtime::PodSandboxState_descriptor();
}
template <> struct is_proto_enum< ::runtime::ContainerState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::ContainerState>() {
  return ::runtime::ContainerState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cri_2dapi_2eproto__INCLUDED
