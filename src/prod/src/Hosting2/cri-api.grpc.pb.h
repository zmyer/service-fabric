// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cri-api.proto
// Original file comments:
// To regenerate api.pb.go run hack/update-generated-runtime.sh
#ifndef GRPC_cri_2dapi_2eproto__INCLUDED
#define GRPC_cri_2dapi_2eproto__INCLUDED

#include "cri-api.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace runtime {

// import "github.com/gogo/protobuf/gogoproto/gogo.proto";
//
// option (gogoproto.goproto_stringer_all) = false;
// option (gogoproto.stringer_all) =  true;
// option (gogoproto.goproto_getters_all) = true;
// option (gogoproto.marshaler_all) = true;
// option (gogoproto.sizer_all) = true;
// option (gogoproto.unmarshaler_all) = true;
// option (gogoproto.goproto_unrecognized_all) = false;
//
// Runtime service defines the public APIs for remote container runtimes
class RuntimeService final {
 public:
  static constexpr char const* service_full_name() {
    return "runtime.RuntimeService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Version returns the runtime name, runtime version, and runtime API version.
    virtual ::grpc::Status Version(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::runtime::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    // RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
    // the sandbox is in the ready state on success.
    virtual ::grpc::Status RunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::runtime::RunPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>> AsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>>(AsyncRunPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>> PrepareAsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>>(PrepareAsyncRunPodSandboxRaw(context, request, cq));
    }
    // StopPodSandbox stops any running process that is part of the sandbox and
    // reclaims network resources (e.g., IP addresses) allocated to the sandbox.
    // If there are any running containers in the sandbox, they must be forcibly
    // terminated.
    // This call is idempotent, and must not return an error if all relevant
    // resources have already been reclaimed. kubelet will call StopPodSandbox
    // at least once before calling RemovePodSandbox. It will also attempt to
    // reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
    // multiple StopPodSandbox calls are expected.
    virtual ::grpc::Status StopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::runtime::StopPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>> AsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>>(AsyncStopPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>> PrepareAsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>>(PrepareAsyncStopPodSandboxRaw(context, request, cq));
    }
    // RemovePodSandbox removes the sandbox. If there are any running containers
    // in the sandbox, they must be forcibly terminated and removed.
    // This call is idempotent, and must not return an error if the sandbox has
    // already been removed.
    virtual ::grpc::Status RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::runtime::RemovePodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>> AsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>>(AsyncRemovePodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>> PrepareAsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>>(PrepareAsyncRemovePodSandboxRaw(context, request, cq));
    }
    // PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
    // present, returns an error.
    virtual ::grpc::Status PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::runtime::PodSandboxStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>> AsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>>(AsyncPodSandboxStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>> PrepareAsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>>(PrepareAsyncPodSandboxStatusRaw(context, request, cq));
    }
    // ListPodSandbox returns a list of PodSandboxes.
    virtual ::grpc::Status ListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::runtime::ListPodSandboxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>> AsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>>(AsyncListPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>> PrepareAsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>>(PrepareAsyncListPodSandboxRaw(context, request, cq));
    }
    // CreateContainer creates a new container in specified PodSandbox
    virtual ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::runtime::CreateContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>> AsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    // StartContainer starts the container.
    virtual ::grpc::Status StartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::runtime::StartContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>> AsyncStartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>>(AsyncStartContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>> PrepareAsyncStartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>>(PrepareAsyncStartContainerRaw(context, request, cq));
    }
    // StopContainer stops a running container with a grace period (i.e., timeout).
    // This call is idempotent, and must not return an error if the container has
    // already been stopped.
    // TODO: what must the runtime do after the grace period is reached?
    virtual ::grpc::Status StopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::runtime::StopContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>> AsyncStopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>>(AsyncStopContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>> PrepareAsyncStopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>>(PrepareAsyncStopContainerRaw(context, request, cq));
    }
    // RemoveContainer removes the container. If the container is running, the
    // container must be forcibly removed.
    // This call is idempotent, and must not return an error if the container has
    // already been removed.
    virtual ::grpc::Status RemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::runtime::RemoveContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>> AsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>>(AsyncRemoveContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>> PrepareAsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>>(PrepareAsyncRemoveContainerRaw(context, request, cq));
    }
    // ListContainers lists all containers by filters.
    virtual ::grpc::Status ListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::runtime::ListContainersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>> AsyncListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>>(AsyncListContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>> PrepareAsyncListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>>(PrepareAsyncListContainersRaw(context, request, cq));
    }
    // ContainerStatus returns status of the container. If the container is not
    // present, returns an error.
    virtual ::grpc::Status ContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::runtime::ContainerStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>> AsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>>(AsyncContainerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>> PrepareAsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>>(PrepareAsyncContainerStatusRaw(context, request, cq));
    }
    // UpdateContainerResources updates ContainerConfig of the container.
    virtual ::grpc::Status UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::runtime::UpdateContainerResourcesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>> AsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>>(AsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>> PrepareAsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>>(PrepareAsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    // ExecSync runs a command in a container synchronously.
    virtual ::grpc::Status ExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::runtime::ExecSyncResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>> AsyncExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>>(AsyncExecSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>> PrepareAsyncExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>>(PrepareAsyncExecSyncRaw(context, request, cq));
    }
    // Exec prepares a streaming endpoint to execute a command in the container.
    virtual ::grpc::Status Exec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::runtime::ExecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    // Attach prepares a streaming endpoint to attach to a running container.
    virtual ::grpc::Status Attach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::runtime::AttachResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>>(PrepareAsyncAttachRaw(context, request, cq));
    }
    // PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
    virtual ::grpc::Status PortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::runtime::PortForwardResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>> AsyncPortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>>(AsyncPortForwardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>> PrepareAsyncPortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>>(PrepareAsyncPortForwardRaw(context, request, cq));
    }
    // ContainerStats returns stats of the container. If the container does not
    // exist, the call returns an error.
    virtual ::grpc::Status ContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::runtime::ContainerStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>> AsyncContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>>(AsyncContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>> PrepareAsyncContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>>(PrepareAsyncContainerStatsRaw(context, request, cq));
    }
    // ListContainerStats returns stats of all running containers.
    virtual ::grpc::Status ListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::runtime::ListContainerStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>> AsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>>(AsyncListContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>> PrepareAsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>>(PrepareAsyncListContainerStatsRaw(context, request, cq));
    }
    // UpdateRuntimeConfig updates the runtime configuration based on the given request.
    virtual ::grpc::Status UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::runtime::UpdateRuntimeConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>> AsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>>(AsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>> PrepareAsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>>(PrepareAsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    // Status returns the status of the runtime.
    virtual ::grpc::Status Status(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::runtime::StatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>> AsyncStatus(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>>(AsyncStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>> PrepareAsyncStatus(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>>(PrepareAsyncStatusRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>* AsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RunPodSandboxResponse>* PrepareAsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>* AsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopPodSandboxResponse>* PrepareAsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>* AsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemovePodSandboxResponse>* PrepareAsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>* AsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PodSandboxStatusResponse>* PrepareAsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>* AsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListPodSandboxResponse>* PrepareAsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::CreateContainerResponse>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>* AsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StartContainerResponse>* PrepareAsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>* AsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StopContainerResponse>* PrepareAsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>* AsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveContainerResponse>* PrepareAsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>* AsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainersResponse>* PrepareAsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>* AsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatusResponse>* PrepareAsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>* AsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateContainerResourcesResponse>* PrepareAsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>* AsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecSyncResponse>* PrepareAsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>* AsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PortForwardResponse>* PrepareAsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>* AsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ContainerStatsResponse>* PrepareAsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>* AsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListContainerStatsResponse>* PrepareAsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>* AsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::UpdateRuntimeConfigResponse>* PrepareAsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>* AsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::StatusResponse>* PrepareAsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Version(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::runtime::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    ::grpc::Status RunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::runtime::RunPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>> AsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>>(AsyncRunPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>> PrepareAsyncRunPodSandbox(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>>(PrepareAsyncRunPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status StopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::runtime::StopPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>> AsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>>(AsyncStopPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>> PrepareAsyncStopPodSandbox(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>>(PrepareAsyncStopPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status RemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::runtime::RemovePodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>> AsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>>(AsyncRemovePodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>> PrepareAsyncRemovePodSandbox(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>>(PrepareAsyncRemovePodSandboxRaw(context, request, cq));
    }
    ::grpc::Status PodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::runtime::PodSandboxStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>> AsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>>(AsyncPodSandboxStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>> PrepareAsyncPodSandboxStatus(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>>(PrepareAsyncPodSandboxStatusRaw(context, request, cq));
    }
    ::grpc::Status ListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::runtime::ListPodSandboxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>> AsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>>(AsyncListPodSandboxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>> PrepareAsyncListPodSandbox(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>>(PrepareAsyncListPodSandboxRaw(context, request, cq));
    }
    ::grpc::Status CreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::runtime::CreateContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>> AsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>>(AsyncCreateContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>> PrepareAsyncCreateContainer(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>>(PrepareAsyncCreateContainerRaw(context, request, cq));
    }
    ::grpc::Status StartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::runtime::StartContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>> AsyncStartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>>(AsyncStartContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>> PrepareAsyncStartContainer(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>>(PrepareAsyncStartContainerRaw(context, request, cq));
    }
    ::grpc::Status StopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::runtime::StopContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>> AsyncStopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>>(AsyncStopContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>> PrepareAsyncStopContainer(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>>(PrepareAsyncStopContainerRaw(context, request, cq));
    }
    ::grpc::Status RemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::runtime::RemoveContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>> AsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>>(AsyncRemoveContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>> PrepareAsyncRemoveContainer(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>>(PrepareAsyncRemoveContainerRaw(context, request, cq));
    }
    ::grpc::Status ListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::runtime::ListContainersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>> AsyncListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>>(AsyncListContainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>> PrepareAsyncListContainers(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>>(PrepareAsyncListContainersRaw(context, request, cq));
    }
    ::grpc::Status ContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::runtime::ContainerStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>> AsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>>(AsyncContainerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>> PrepareAsyncContainerStatus(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>>(PrepareAsyncContainerStatusRaw(context, request, cq));
    }
    ::grpc::Status UpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::runtime::UpdateContainerResourcesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>> AsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>>(AsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>> PrepareAsyncUpdateContainerResources(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>>(PrepareAsyncUpdateContainerResourcesRaw(context, request, cq));
    }
    ::grpc::Status ExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::runtime::ExecSyncResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>> AsyncExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>>(AsyncExecSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>> PrepareAsyncExecSync(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>>(PrepareAsyncExecSyncRaw(context, request, cq));
    }
    ::grpc::Status Exec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::runtime::ExecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    ::grpc::Status Attach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::runtime::AttachResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>>(AsyncAttachRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>>(PrepareAsyncAttachRaw(context, request, cq));
    }
    ::grpc::Status PortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::runtime::PortForwardResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>> AsyncPortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>>(AsyncPortForwardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>> PrepareAsyncPortForward(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>>(PrepareAsyncPortForwardRaw(context, request, cq));
    }
    ::grpc::Status ContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::runtime::ContainerStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>> AsyncContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>>(AsyncContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>> PrepareAsyncContainerStats(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>>(PrepareAsyncContainerStatsRaw(context, request, cq));
    }
    ::grpc::Status ListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::runtime::ListContainerStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>> AsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>>(AsyncListContainerStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>> PrepareAsyncListContainerStats(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>>(PrepareAsyncListContainerStatsRaw(context, request, cq));
    }
    ::grpc::Status UpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::runtime::UpdateRuntimeConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>> AsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>>(AsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>> PrepareAsyncUpdateRuntimeConfig(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>>(PrepareAsyncUpdateRuntimeConfigRaw(context, request, cq));
    }
    ::grpc::Status Status(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::runtime::StatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>> AsyncStatus(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>>(AsyncStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>> PrepareAsyncStatus(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>>(PrepareAsyncStatusRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::runtime::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>* AsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RunPodSandboxResponse>* PrepareAsyncRunPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RunPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>* AsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StopPodSandboxResponse>* PrepareAsyncStopPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::StopPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>* AsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemovePodSandboxResponse>* PrepareAsyncRemovePodSandboxRaw(::grpc::ClientContext* context, const ::runtime::RemovePodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>* AsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PodSandboxStatusResponse>* PrepareAsyncPodSandboxStatusRaw(::grpc::ClientContext* context, const ::runtime::PodSandboxStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>* AsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListPodSandboxResponse>* PrepareAsyncListPodSandboxRaw(::grpc::ClientContext* context, const ::runtime::ListPodSandboxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>* AsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::CreateContainerResponse>* PrepareAsyncCreateContainerRaw(::grpc::ClientContext* context, const ::runtime::CreateContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>* AsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StartContainerResponse>* PrepareAsyncStartContainerRaw(::grpc::ClientContext* context, const ::runtime::StartContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>* AsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StopContainerResponse>* PrepareAsyncStopContainerRaw(::grpc::ClientContext* context, const ::runtime::StopContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>* AsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemoveContainerResponse>* PrepareAsyncRemoveContainerRaw(::grpc::ClientContext* context, const ::runtime::RemoveContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>* AsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListContainersResponse>* PrepareAsyncListContainersRaw(::grpc::ClientContext* context, const ::runtime::ListContainersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>* AsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatusResponse>* PrepareAsyncContainerStatusRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>* AsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::UpdateContainerResourcesResponse>* PrepareAsyncUpdateContainerResourcesRaw(::grpc::ClientContext* context, const ::runtime::UpdateContainerResourcesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>* AsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ExecSyncResponse>* PrepareAsyncExecSyncRaw(::grpc::ClientContext* context, const ::runtime::ExecSyncRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::runtime::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, const ::runtime::AttachRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>* AsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PortForwardResponse>* PrepareAsyncPortForwardRaw(::grpc::ClientContext* context, const ::runtime::PortForwardRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>* AsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ContainerStatsResponse>* PrepareAsyncContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>* AsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListContainerStatsResponse>* PrepareAsyncListContainerStatsRaw(::grpc::ClientContext* context, const ::runtime::ListContainerStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>* AsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::UpdateRuntimeConfigResponse>* PrepareAsyncUpdateRuntimeConfigRaw(::grpc::ClientContext* context, const ::runtime::UpdateRuntimeConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>* AsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::StatusResponse>* PrepareAsyncStatusRaw(::grpc::ClientContext* context, const ::runtime::StatusRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Version_;
    const ::grpc::internal::RpcMethod rpcmethod_RunPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_StopPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_RemovePodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_PodSandboxStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPodSandbox_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_StartContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_StopContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_ListContainers_;
    const ::grpc::internal::RpcMethod rpcmethod_ContainerStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateContainerResources_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecSync_;
    const ::grpc::internal::RpcMethod rpcmethod_Exec_;
    const ::grpc::internal::RpcMethod rpcmethod_Attach_;
    const ::grpc::internal::RpcMethod rpcmethod_PortForward_;
    const ::grpc::internal::RpcMethod rpcmethod_ContainerStats_;
    const ::grpc::internal::RpcMethod rpcmethod_ListContainerStats_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateRuntimeConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_Status_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Version returns the runtime name, runtime version, and runtime API version.
    virtual ::grpc::Status Version(::grpc::ServerContext* context, const ::runtime::VersionRequest* request, ::runtime::VersionResponse* response);
    // RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
    // the sandbox is in the ready state on success.
    virtual ::grpc::Status RunPodSandbox(::grpc::ServerContext* context, const ::runtime::RunPodSandboxRequest* request, ::runtime::RunPodSandboxResponse* response);
    // StopPodSandbox stops any running process that is part of the sandbox and
    // reclaims network resources (e.g., IP addresses) allocated to the sandbox.
    // If there are any running containers in the sandbox, they must be forcibly
    // terminated.
    // This call is idempotent, and must not return an error if all relevant
    // resources have already been reclaimed. kubelet will call StopPodSandbox
    // at least once before calling RemovePodSandbox. It will also attempt to
    // reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
    // multiple StopPodSandbox calls are expected.
    virtual ::grpc::Status StopPodSandbox(::grpc::ServerContext* context, const ::runtime::StopPodSandboxRequest* request, ::runtime::StopPodSandboxResponse* response);
    // RemovePodSandbox removes the sandbox. If there are any running containers
    // in the sandbox, they must be forcibly terminated and removed.
    // This call is idempotent, and must not return an error if the sandbox has
    // already been removed.
    virtual ::grpc::Status RemovePodSandbox(::grpc::ServerContext* context, const ::runtime::RemovePodSandboxRequest* request, ::runtime::RemovePodSandboxResponse* response);
    // PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
    // present, returns an error.
    virtual ::grpc::Status PodSandboxStatus(::grpc::ServerContext* context, const ::runtime::PodSandboxStatusRequest* request, ::runtime::PodSandboxStatusResponse* response);
    // ListPodSandbox returns a list of PodSandboxes.
    virtual ::grpc::Status ListPodSandbox(::grpc::ServerContext* context, const ::runtime::ListPodSandboxRequest* request, ::runtime::ListPodSandboxResponse* response);
    // CreateContainer creates a new container in specified PodSandbox
    virtual ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::runtime::CreateContainerRequest* request, ::runtime::CreateContainerResponse* response);
    // StartContainer starts the container.
    virtual ::grpc::Status StartContainer(::grpc::ServerContext* context, const ::runtime::StartContainerRequest* request, ::runtime::StartContainerResponse* response);
    // StopContainer stops a running container with a grace period (i.e., timeout).
    // This call is idempotent, and must not return an error if the container has
    // already been stopped.
    // TODO: what must the runtime do after the grace period is reached?
    virtual ::grpc::Status StopContainer(::grpc::ServerContext* context, const ::runtime::StopContainerRequest* request, ::runtime::StopContainerResponse* response);
    // RemoveContainer removes the container. If the container is running, the
    // container must be forcibly removed.
    // This call is idempotent, and must not return an error if the container has
    // already been removed.
    virtual ::grpc::Status RemoveContainer(::grpc::ServerContext* context, const ::runtime::RemoveContainerRequest* request, ::runtime::RemoveContainerResponse* response);
    // ListContainers lists all containers by filters.
    virtual ::grpc::Status ListContainers(::grpc::ServerContext* context, const ::runtime::ListContainersRequest* request, ::runtime::ListContainersResponse* response);
    // ContainerStatus returns status of the container. If the container is not
    // present, returns an error.
    virtual ::grpc::Status ContainerStatus(::grpc::ServerContext* context, const ::runtime::ContainerStatusRequest* request, ::runtime::ContainerStatusResponse* response);
    // UpdateContainerResources updates ContainerConfig of the container.
    virtual ::grpc::Status UpdateContainerResources(::grpc::ServerContext* context, const ::runtime::UpdateContainerResourcesRequest* request, ::runtime::UpdateContainerResourcesResponse* response);
    // ExecSync runs a command in a container synchronously.
    virtual ::grpc::Status ExecSync(::grpc::ServerContext* context, const ::runtime::ExecSyncRequest* request, ::runtime::ExecSyncResponse* response);
    // Exec prepares a streaming endpoint to execute a command in the container.
    virtual ::grpc::Status Exec(::grpc::ServerContext* context, const ::runtime::ExecRequest* request, ::runtime::ExecResponse* response);
    // Attach prepares a streaming endpoint to attach to a running container.
    virtual ::grpc::Status Attach(::grpc::ServerContext* context, const ::runtime::AttachRequest* request, ::runtime::AttachResponse* response);
    // PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
    virtual ::grpc::Status PortForward(::grpc::ServerContext* context, const ::runtime::PortForwardRequest* request, ::runtime::PortForwardResponse* response);
    // ContainerStats returns stats of the container. If the container does not
    // exist, the call returns an error.
    virtual ::grpc::Status ContainerStats(::grpc::ServerContext* context, const ::runtime::ContainerStatsRequest* request, ::runtime::ContainerStatsResponse* response);
    // ListContainerStats returns stats of all running containers.
    virtual ::grpc::Status ListContainerStats(::grpc::ServerContext* context, const ::runtime::ListContainerStatsRequest* request, ::runtime::ListContainerStatsResponse* response);
    // UpdateRuntimeConfig updates the runtime configuration based on the given request.
    virtual ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* context, const ::runtime::UpdateRuntimeConfigRequest* request, ::runtime::UpdateRuntimeConfigResponse* response);
    // Status returns the status of the runtime.
    virtual ::grpc::Status Status(::grpc::ServerContext* context, const ::runtime::StatusRequest* request, ::runtime::StatusResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Version() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* context, const ::runtime::VersionRequest* request, ::runtime::VersionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::runtime::VersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* context, const ::runtime::RunPodSandboxRequest* request, ::runtime::RunPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunPodSandbox(::grpc::ServerContext* context, ::runtime::RunPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::RunPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* context, const ::runtime::StopPodSandboxRequest* request, ::runtime::StopPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopPodSandbox(::grpc::ServerContext* context, ::runtime::StopPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::StopPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* context, const ::runtime::RemovePodSandboxRequest* request, ::runtime::RemovePodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemovePodSandbox(::grpc::ServerContext* context, ::runtime::RemovePodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::RemovePodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* context, const ::runtime::PodSandboxStatusRequest* request, ::runtime::PodSandboxStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPodSandboxStatus(::grpc::ServerContext* context, ::runtime::PodSandboxStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::PodSandboxStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* context, const ::runtime::ListPodSandboxRequest* request, ::runtime::ListPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPodSandbox(::grpc::ServerContext* context, ::runtime::ListPodSandboxRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ListPodSandboxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateContainer() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::runtime::CreateContainerRequest* request, ::runtime::CreateContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateContainer(::grpc::ServerContext* context, ::runtime::CreateContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::CreateContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StartContainer() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* context, const ::runtime::StartContainerRequest* request, ::runtime::StartContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartContainer(::grpc::ServerContext* context, ::runtime::StartContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::StartContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopContainer() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* context, const ::runtime::StopContainerRequest* request, ::runtime::StopContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopContainer(::grpc::ServerContext* context, ::runtime::StopContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::StopContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* context, const ::runtime::RemoveContainerRequest* request, ::runtime::RemoveContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveContainer(::grpc::ServerContext* context, ::runtime::RemoveContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::RemoveContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListContainers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* context, const ::runtime::ListContainersRequest* request, ::runtime::ListContainersResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainers(::grpc::ServerContext* context, ::runtime::ListContainersRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ListContainersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* context, const ::runtime::ContainerStatusRequest* request, ::runtime::ContainerStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStatus(::grpc::ServerContext* context, ::runtime::ContainerStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ContainerStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* context, const ::runtime::UpdateContainerResourcesRequest* request, ::runtime::UpdateContainerResourcesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateContainerResources(::grpc::ServerContext* context, ::runtime::UpdateContainerResourcesRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::UpdateContainerResourcesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ExecSync() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* context, const ::runtime::ExecSyncRequest* request, ::runtime::ExecSyncResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecSync(::grpc::ServerContext* context, ::runtime::ExecSyncRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ExecSyncResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Exec() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* context, const ::runtime::ExecRequest* request, ::runtime::ExecResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExec(::grpc::ServerContext* context, ::runtime::ExecRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ExecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Attach() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* context, const ::runtime::AttachRequest* request, ::runtime::AttachResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAttach(::grpc::ServerContext* context, ::runtime::AttachRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::AttachResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PortForward() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* context, const ::runtime::PortForwardRequest* request, ::runtime::PortForwardResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortForward(::grpc::ServerContext* context, ::runtime::PortForwardRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::PortForwardResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ContainerStats() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* context, const ::runtime::ContainerStatsRequest* request, ::runtime::ContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestContainerStats(::grpc::ServerContext* context, ::runtime::ContainerStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ContainerStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* context, const ::runtime::ListContainerStatsRequest* request, ::runtime::ListContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListContainerStats(::grpc::ServerContext* context, ::runtime::ListContainerStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ListContainerStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* context, const ::runtime::UpdateRuntimeConfigRequest* request, ::runtime::UpdateRuntimeConfigResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRuntimeConfig(::grpc::ServerContext* context, ::runtime::UpdateRuntimeConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::UpdateRuntimeConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Status() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* context, const ::runtime::StatusRequest* request, ::runtime::StatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatus(::grpc::ServerContext* context, ::runtime::StatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::StatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Version<WithAsyncMethod_RunPodSandbox<WithAsyncMethod_StopPodSandbox<WithAsyncMethod_RemovePodSandbox<WithAsyncMethod_PodSandboxStatus<WithAsyncMethod_ListPodSandbox<WithAsyncMethod_CreateContainer<WithAsyncMethod_StartContainer<WithAsyncMethod_StopContainer<WithAsyncMethod_RemoveContainer<WithAsyncMethod_ListContainers<WithAsyncMethod_ContainerStatus<WithAsyncMethod_UpdateContainerResources<WithAsyncMethod_ExecSync<WithAsyncMethod_Exec<WithAsyncMethod_Attach<WithAsyncMethod_PortForward<WithAsyncMethod_ContainerStats<WithAsyncMethod_ListContainerStats<WithAsyncMethod_UpdateRuntimeConfig<WithAsyncMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Version() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* context, const ::runtime::VersionRequest* request, ::runtime::VersionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* context, const ::runtime::RunPodSandboxRequest* request, ::runtime::RunPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* context, const ::runtime::StopPodSandboxRequest* request, ::runtime::StopPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* context, const ::runtime::RemovePodSandboxRequest* request, ::runtime::RemovePodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* context, const ::runtime::PodSandboxStatusRequest* request, ::runtime::PodSandboxStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* context, const ::runtime::ListPodSandboxRequest* request, ::runtime::ListPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateContainer() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::runtime::CreateContainerRequest* request, ::runtime::CreateContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StartContainer() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* context, const ::runtime::StartContainerRequest* request, ::runtime::StartContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopContainer() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* context, const ::runtime::StopContainerRequest* request, ::runtime::StopContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* context, const ::runtime::RemoveContainerRequest* request, ::runtime::RemoveContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListContainers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* context, const ::runtime::ListContainersRequest* request, ::runtime::ListContainersResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* context, const ::runtime::ContainerStatusRequest* request, ::runtime::ContainerStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* context, const ::runtime::UpdateContainerResourcesRequest* request, ::runtime::UpdateContainerResourcesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ExecSync() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* context, const ::runtime::ExecSyncRequest* request, ::runtime::ExecSyncResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Exec() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* context, const ::runtime::ExecRequest* request, ::runtime::ExecResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Attach() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* context, const ::runtime::AttachRequest* request, ::runtime::AttachResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PortForward() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* context, const ::runtime::PortForwardRequest* request, ::runtime::PortForwardResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ContainerStats() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* context, const ::runtime::ContainerStatsRequest* request, ::runtime::ContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* context, const ::runtime::ListContainerStatsRequest* request, ::runtime::ListContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* context, const ::runtime::UpdateRuntimeConfigRequest* request, ::runtime::UpdateRuntimeConfigResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Status() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Status(::grpc::ServerContext* context, const ::runtime::StatusRequest* request, ::runtime::StatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Version() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::VersionRequest, ::runtime::VersionResponse>(std::bind(&WithStreamedUnaryMethod_Version<BaseClass>::StreamedVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Version(::grpc::ServerContext* context, const ::runtime::VersionRequest* request, ::runtime::VersionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::VersionRequest,::runtime::VersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RunPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::RunPodSandboxRequest, ::runtime::RunPodSandboxResponse>(std::bind(&WithStreamedUnaryMethod_RunPodSandbox<BaseClass>::StreamedRunPodSandbox, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RunPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunPodSandbox(::grpc::ServerContext* context, const ::runtime::RunPodSandboxRequest* request, ::runtime::RunPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::RunPodSandboxRequest,::runtime::RunPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::StopPodSandboxRequest, ::runtime::StopPodSandboxResponse>(std::bind(&WithStreamedUnaryMethod_StopPodSandbox<BaseClass>::StreamedStopPodSandbox, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopPodSandbox(::grpc::ServerContext* context, const ::runtime::StopPodSandboxRequest* request, ::runtime::StopPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::StopPodSandboxRequest,::runtime::StopPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemovePodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RemovePodSandbox() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::RemovePodSandboxRequest, ::runtime::RemovePodSandboxResponse>(std::bind(&WithStreamedUnaryMethod_RemovePodSandbox<BaseClass>::StreamedRemovePodSandbox, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RemovePodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemovePodSandbox(::grpc::ServerContext* context, const ::runtime::RemovePodSandboxRequest* request, ::runtime::RemovePodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemovePodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::RemovePodSandboxRequest,::runtime::RemovePodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PodSandboxStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_PodSandboxStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::PodSandboxStatusRequest, ::runtime::PodSandboxStatusResponse>(std::bind(&WithStreamedUnaryMethod_PodSandboxStatus<BaseClass>::StreamedPodSandboxStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PodSandboxStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PodSandboxStatus(::grpc::ServerContext* context, const ::runtime::PodSandboxStatusRequest* request, ::runtime::PodSandboxStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPodSandboxStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::PodSandboxStatusRequest,::runtime::PodSandboxStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPodSandbox : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListPodSandbox() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ListPodSandboxRequest, ::runtime::ListPodSandboxResponse>(std::bind(&WithStreamedUnaryMethod_ListPodSandbox<BaseClass>::StreamedListPodSandbox, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListPodSandbox() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPodSandbox(::grpc::ServerContext* context, const ::runtime::ListPodSandboxRequest* request, ::runtime::ListPodSandboxResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPodSandbox(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ListPodSandboxRequest,::runtime::ListPodSandboxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateContainer() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::CreateContainerRequest, ::runtime::CreateContainerResponse>(std::bind(&WithStreamedUnaryMethod_CreateContainer<BaseClass>::StreamedCreateContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateContainer(::grpc::ServerContext* context, const ::runtime::CreateContainerRequest* request, ::runtime::CreateContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::CreateContainerRequest,::runtime::CreateContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StartContainer() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::StartContainerRequest, ::runtime::StartContainerResponse>(std::bind(&WithStreamedUnaryMethod_StartContainer<BaseClass>::StreamedStartContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StartContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartContainer(::grpc::ServerContext* context, const ::runtime::StartContainerRequest* request, ::runtime::StartContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::StartContainerRequest,::runtime::StartContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopContainer() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::StopContainerRequest, ::runtime::StopContainerResponse>(std::bind(&WithStreamedUnaryMethod_StopContainer<BaseClass>::StreamedStopContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopContainer(::grpc::ServerContext* context, const ::runtime::StopContainerRequest* request, ::runtime::StopContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::StopContainerRequest,::runtime::StopContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RemoveContainer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::RemoveContainerRequest, ::runtime::RemoveContainerResponse>(std::bind(&WithStreamedUnaryMethod_RemoveContainer<BaseClass>::StreamedRemoveContainer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RemoveContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveContainer(::grpc::ServerContext* context, const ::runtime::RemoveContainerRequest* request, ::runtime::RemoveContainerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveContainer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::RemoveContainerRequest,::runtime::RemoveContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListContainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListContainers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ListContainersRequest, ::runtime::ListContainersResponse>(std::bind(&WithStreamedUnaryMethod_ListContainers<BaseClass>::StreamedListContainers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListContainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListContainers(::grpc::ServerContext* context, const ::runtime::ListContainersRequest* request, ::runtime::ListContainersResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListContainers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ListContainersRequest,::runtime::ListContainersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContainerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ContainerStatus() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ContainerStatusRequest, ::runtime::ContainerStatusResponse>(std::bind(&WithStreamedUnaryMethod_ContainerStatus<BaseClass>::StreamedContainerStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ContainerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContainerStatus(::grpc::ServerContext* context, const ::runtime::ContainerStatusRequest* request, ::runtime::ContainerStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContainerStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ContainerStatusRequest,::runtime::ContainerStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateContainerResources : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateContainerResources() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::UpdateContainerResourcesRequest, ::runtime::UpdateContainerResourcesResponse>(std::bind(&WithStreamedUnaryMethod_UpdateContainerResources<BaseClass>::StreamedUpdateContainerResources, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateContainerResources() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateContainerResources(::grpc::ServerContext* context, const ::runtime::UpdateContainerResourcesRequest* request, ::runtime::UpdateContainerResourcesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateContainerResources(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::UpdateContainerResourcesRequest,::runtime::UpdateContainerResourcesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecSync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ExecSync() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ExecSyncRequest, ::runtime::ExecSyncResponse>(std::bind(&WithStreamedUnaryMethod_ExecSync<BaseClass>::StreamedExecSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExecSync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecSync(::grpc::ServerContext* context, const ::runtime::ExecSyncRequest* request, ::runtime::ExecSyncResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ExecSyncRequest,::runtime::ExecSyncResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Exec() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ExecRequest, ::runtime::ExecResponse>(std::bind(&WithStreamedUnaryMethod_Exec<BaseClass>::StreamedExec, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Exec(::grpc::ServerContext* context, const ::runtime::ExecRequest* request, ::runtime::ExecResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ExecRequest,::runtime::ExecResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Attach() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::AttachRequest, ::runtime::AttachResponse>(std::bind(&WithStreamedUnaryMethod_Attach<BaseClass>::StreamedAttach, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Attach(::grpc::ServerContext* context, const ::runtime::AttachRequest* request, ::runtime::AttachResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAttach(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::AttachRequest,::runtime::AttachResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PortForward : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_PortForward() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::PortForwardRequest, ::runtime::PortForwardResponse>(std::bind(&WithStreamedUnaryMethod_PortForward<BaseClass>::StreamedPortForward, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PortForward() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PortForward(::grpc::ServerContext* context, const ::runtime::PortForwardRequest* request, ::runtime::PortForwardResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPortForward(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::PortForwardRequest,::runtime::PortForwardResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ContainerStats() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ContainerStatsRequest, ::runtime::ContainerStatsResponse>(std::bind(&WithStreamedUnaryMethod_ContainerStats<BaseClass>::StreamedContainerStats, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ContainerStats(::grpc::ServerContext* context, const ::runtime::ContainerStatsRequest* request, ::runtime::ContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedContainerStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ContainerStatsRequest,::runtime::ContainerStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListContainerStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListContainerStats() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ListContainerStatsRequest, ::runtime::ListContainerStatsResponse>(std::bind(&WithStreamedUnaryMethod_ListContainerStats<BaseClass>::StreamedListContainerStats, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListContainerStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListContainerStats(::grpc::ServerContext* context, const ::runtime::ListContainerStatsRequest* request, ::runtime::ListContainerStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListContainerStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ListContainerStatsRequest,::runtime::ListContainerStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateRuntimeConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateRuntimeConfig() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::UpdateRuntimeConfigRequest, ::runtime::UpdateRuntimeConfigResponse>(std::bind(&WithStreamedUnaryMethod_UpdateRuntimeConfig<BaseClass>::StreamedUpdateRuntimeConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateRuntimeConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateRuntimeConfig(::grpc::ServerContext* context, const ::runtime::UpdateRuntimeConfigRequest* request, ::runtime::UpdateRuntimeConfigResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateRuntimeConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::UpdateRuntimeConfigRequest,::runtime::UpdateRuntimeConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Status() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::StatusRequest, ::runtime::StatusResponse>(std::bind(&WithStreamedUnaryMethod_Status<BaseClass>::StreamedStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Status(::grpc::ServerContext* context, const ::runtime::StatusRequest* request, ::runtime::StatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::StatusRequest,::runtime::StatusResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_RunPodSandbox<WithStreamedUnaryMethod_StopPodSandbox<WithStreamedUnaryMethod_RemovePodSandbox<WithStreamedUnaryMethod_PodSandboxStatus<WithStreamedUnaryMethod_ListPodSandbox<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_StartContainer<WithStreamedUnaryMethod_StopContainer<WithStreamedUnaryMethod_RemoveContainer<WithStreamedUnaryMethod_ListContainers<WithStreamedUnaryMethod_ContainerStatus<WithStreamedUnaryMethod_UpdateContainerResources<WithStreamedUnaryMethod_ExecSync<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Attach<WithStreamedUnaryMethod_PortForward<WithStreamedUnaryMethod_ContainerStats<WithStreamedUnaryMethod_ListContainerStats<WithStreamedUnaryMethod_UpdateRuntimeConfig<WithStreamedUnaryMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_RunPodSandbox<WithStreamedUnaryMethod_StopPodSandbox<WithStreamedUnaryMethod_RemovePodSandbox<WithStreamedUnaryMethod_PodSandboxStatus<WithStreamedUnaryMethod_ListPodSandbox<WithStreamedUnaryMethod_CreateContainer<WithStreamedUnaryMethod_StartContainer<WithStreamedUnaryMethod_StopContainer<WithStreamedUnaryMethod_RemoveContainer<WithStreamedUnaryMethod_ListContainers<WithStreamedUnaryMethod_ContainerStatus<WithStreamedUnaryMethod_UpdateContainerResources<WithStreamedUnaryMethod_ExecSync<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Attach<WithStreamedUnaryMethod_PortForward<WithStreamedUnaryMethod_ContainerStats<WithStreamedUnaryMethod_ListContainerStats<WithStreamedUnaryMethod_UpdateRuntimeConfig<WithStreamedUnaryMethod_Status<Service > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

// ImageService defines the public APIs for managing images.
class ImageService final {
 public:
  static constexpr char const* service_full_name() {
    return "runtime.ImageService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ListImages lists existing images.
    virtual ::grpc::Status ListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::runtime::ListImagesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>> AsyncListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>>(AsyncListImagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>> PrepareAsyncListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>>(PrepareAsyncListImagesRaw(context, request, cq));
    }
    // ImageStatus returns the status of the image. If the image is not
    // present, returns a response with ImageStatusResponse.Image set to
    // nil.
    virtual ::grpc::Status ImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::runtime::ImageStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>> AsyncImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>>(AsyncImageStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>> PrepareAsyncImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>>(PrepareAsyncImageStatusRaw(context, request, cq));
    }
    // PullImage pulls an image with authentication config.
    virtual ::grpc::Status PullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::runtime::PullImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>> AsyncPullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>>(AsyncPullImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>> PrepareAsyncPullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>>(PrepareAsyncPullImageRaw(context, request, cq));
    }
    // RemoveImage removes the image.
    // This call is idempotent, and must not return an error if the image has
    // already been removed.
    virtual ::grpc::Status RemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::runtime::RemoveImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>> AsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>>(AsyncRemoveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>> PrepareAsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>>(PrepareAsyncRemoveImageRaw(context, request, cq));
    }
    // ImageFSInfo returns information of the filesystem that is used to store images.
    virtual ::grpc::Status ImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::runtime::ImageFsInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>> AsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>>(AsyncImageFsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>> PrepareAsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>>(PrepareAsyncImageFsInfoRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>* AsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ListImagesResponse>* PrepareAsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>* AsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageStatusResponse>* PrepareAsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>* AsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::PullImageResponse>* PrepareAsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>* AsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::RemoveImageResponse>* PrepareAsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>* AsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::runtime::ImageFsInfoResponse>* PrepareAsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::runtime::ListImagesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>> AsyncListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>>(AsyncListImagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>> PrepareAsyncListImages(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>>(PrepareAsyncListImagesRaw(context, request, cq));
    }
    ::grpc::Status ImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::runtime::ImageStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>> AsyncImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>>(AsyncImageStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>> PrepareAsyncImageStatus(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>>(PrepareAsyncImageStatusRaw(context, request, cq));
    }
    ::grpc::Status PullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::runtime::PullImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>> AsyncPullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>>(AsyncPullImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>> PrepareAsyncPullImage(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>>(PrepareAsyncPullImageRaw(context, request, cq));
    }
    ::grpc::Status RemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::runtime::RemoveImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>> AsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>>(AsyncRemoveImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>> PrepareAsyncRemoveImage(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>>(PrepareAsyncRemoveImageRaw(context, request, cq));
    }
    ::grpc::Status ImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::runtime::ImageFsInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>> AsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>>(AsyncImageFsInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>> PrepareAsyncImageFsInfo(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>>(PrepareAsyncImageFsInfoRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>* AsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ListImagesResponse>* PrepareAsyncListImagesRaw(::grpc::ClientContext* context, const ::runtime::ListImagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>* AsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ImageStatusResponse>* PrepareAsyncImageStatusRaw(::grpc::ClientContext* context, const ::runtime::ImageStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>* AsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::PullImageResponse>* PrepareAsyncPullImageRaw(::grpc::ClientContext* context, const ::runtime::PullImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>* AsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::RemoveImageResponse>* PrepareAsyncRemoveImageRaw(::grpc::ClientContext* context, const ::runtime::RemoveImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>* AsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::runtime::ImageFsInfoResponse>* PrepareAsyncImageFsInfoRaw(::grpc::ClientContext* context, const ::runtime::ImageFsInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListImages_;
    const ::grpc::internal::RpcMethod rpcmethod_ImageStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_PullImage_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveImage_;
    const ::grpc::internal::RpcMethod rpcmethod_ImageFsInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ListImages lists existing images.
    virtual ::grpc::Status ListImages(::grpc::ServerContext* context, const ::runtime::ListImagesRequest* request, ::runtime::ListImagesResponse* response);
    // ImageStatus returns the status of the image. If the image is not
    // present, returns a response with ImageStatusResponse.Image set to
    // nil.
    virtual ::grpc::Status ImageStatus(::grpc::ServerContext* context, const ::runtime::ImageStatusRequest* request, ::runtime::ImageStatusResponse* response);
    // PullImage pulls an image with authentication config.
    virtual ::grpc::Status PullImage(::grpc::ServerContext* context, const ::runtime::PullImageRequest* request, ::runtime::PullImageResponse* response);
    // RemoveImage removes the image.
    // This call is idempotent, and must not return an error if the image has
    // already been removed.
    virtual ::grpc::Status RemoveImage(::grpc::ServerContext* context, const ::runtime::RemoveImageRequest* request, ::runtime::RemoveImageResponse* response);
    // ImageFSInfo returns information of the filesystem that is used to store images.
    virtual ::grpc::Status ImageFsInfo(::grpc::ServerContext* context, const ::runtime::ImageFsInfoRequest* request, ::runtime::ImageFsInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListImages() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* context, const ::runtime::ListImagesRequest* request, ::runtime::ListImagesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListImages(::grpc::ServerContext* context, ::runtime::ListImagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ListImagesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ImageStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* context, const ::runtime::ImageStatusRequest* request, ::runtime::ImageStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageStatus(::grpc::ServerContext* context, ::runtime::ImageStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ImageStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PullImage() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* context, const ::runtime::PullImageRequest* request, ::runtime::PullImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPullImage(::grpc::ServerContext* context, ::runtime::PullImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::PullImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RemoveImage() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* context, const ::runtime::RemoveImageRequest* request, ::runtime::RemoveImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveImage(::grpc::ServerContext* context, ::runtime::RemoveImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::RemoveImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* context, const ::runtime::ImageFsInfoRequest* request, ::runtime::ImageFsInfoResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageFsInfo(::grpc::ServerContext* context, ::runtime::ImageFsInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::runtime::ImageFsInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListImages<WithAsyncMethod_ImageStatus<WithAsyncMethod_PullImage<WithAsyncMethod_RemoveImage<WithAsyncMethod_ImageFsInfo<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListImages() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* context, const ::runtime::ListImagesRequest* request, ::runtime::ListImagesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ImageStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* context, const ::runtime::ImageStatusRequest* request, ::runtime::ImageStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PullImage() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* context, const ::runtime::PullImageRequest* request, ::runtime::PullImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RemoveImage() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* context, const ::runtime::RemoveImageRequest* request, ::runtime::RemoveImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* context, const ::runtime::ImageFsInfoRequest* request, ::runtime::ImageFsInfoResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListImages() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ListImagesRequest, ::runtime::ListImagesResponse>(std::bind(&WithStreamedUnaryMethod_ListImages<BaseClass>::StreamedListImages, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListImages(::grpc::ServerContext* context, const ::runtime::ListImagesRequest* request, ::runtime::ListImagesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListImages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ListImagesRequest,::runtime::ListImagesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ImageStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ImageStatusRequest, ::runtime::ImageStatusResponse>(std::bind(&WithStreamedUnaryMethod_ImageStatus<BaseClass>::StreamedImageStatus, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ImageStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageStatus(::grpc::ServerContext* context, const ::runtime::ImageStatusRequest* request, ::runtime::ImageStatusResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ImageStatusRequest,::runtime::ImageStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PullImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_PullImage() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::PullImageRequest, ::runtime::PullImageResponse>(std::bind(&WithStreamedUnaryMethod_PullImage<BaseClass>::StreamedPullImage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PullImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PullImage(::grpc::ServerContext* context, const ::runtime::PullImageRequest* request, ::runtime::PullImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPullImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::PullImageRequest,::runtime::PullImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_RemoveImage() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::RemoveImageRequest, ::runtime::RemoveImageResponse>(std::bind(&WithStreamedUnaryMethod_RemoveImage<BaseClass>::StreamedRemoveImage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_RemoveImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveImage(::grpc::ServerContext* context, const ::runtime::RemoveImageRequest* request, ::runtime::RemoveImageResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::RemoveImageRequest,::runtime::RemoveImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageFsInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ImageFsInfo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::runtime::ImageFsInfoRequest, ::runtime::ImageFsInfoResponse>(std::bind(&WithStreamedUnaryMethod_ImageFsInfo<BaseClass>::StreamedImageFsInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ImageFsInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageFsInfo(::grpc::ServerContext* context, const ::runtime::ImageFsInfoRequest* request, ::runtime::ImageFsInfoResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageFsInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::runtime::ImageFsInfoRequest,::runtime::ImageFsInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListImages<WithStreamedUnaryMethod_ImageStatus<WithStreamedUnaryMethod_PullImage<WithStreamedUnaryMethod_RemoveImage<WithStreamedUnaryMethod_ImageFsInfo<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListImages<WithStreamedUnaryMethod_ImageStatus<WithStreamedUnaryMethod_PullImage<WithStreamedUnaryMethod_RemoveImage<WithStreamedUnaryMethod_ImageFsInfo<Service > > > > > StreamedService;
};

}  // namespace runtime


#endif  // GRPC_cri_2dapi_2eproto__INCLUDED
